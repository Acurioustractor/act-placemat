# Database Backup and High Availability Configuration
# Comprehensive backup strategy with Australian compliance and disaster recovery

---
# Database Backup Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: database-backup-config
  namespace: act-placemat
  labels:
    component: database
    operation-type: backup
    data-residency: australia
  annotations:
    description: "Database backup configuration with Australian compliance"
    compliance.framework: "australian-privacy-act"
data:
  backup_config: |
    # Backup strategy configuration
    backup_strategy:
      automated_backups:
        enabled: true
        start_time: "02:00"  # 2 AM AEDT
        retention_days: 30
        location: "australia-southeast1"
        
      point_in_time_recovery:
        enabled: true
        log_retention_days: 7
        
      binary_log_enabled: true
      transaction_log_retention_days: 7
      
    # Backup types and schedules
    backup_schedules:
      # Full daily backups
      full_backup:
        schedule: "0 2 * * *"  # Daily at 2 AM AEDT
        retention: "30 days"
        location: "australia-southeast1"
        encryption: true
        
      # Incremental backups every 6 hours
      incremental_backup:
        schedule: "0 */6 * * *"  # Every 6 hours
        retention: "7 days"
        location: "australia-southeast1"
        encryption: true
        
      # Weekly archival backups
      archival_backup:
        schedule: "0 1 * * 0"  # Sunday at 1 AM AEDT
        retention: "1 year"
        location: "australia-southeast1"
        compression: true
        encryption: true
        
      # Monthly compliance backups
      compliance_backup:
        schedule: "0 0 1 * *"  # First day of month
        retention: "7 years"  # Australian Privacy Act requirement
        location: "australia-southeast1"
        encryption: true
        immutable: true

  # Recovery procedures
  recovery_config: |
    # Recovery time objectives (RTO) and recovery point objectives (RPO)
    recovery_objectives:
      rto_target: "15 minutes"  # Recovery Time Objective
      rpo_target: "1 minute"   # Recovery Point Objective
      
    # Recovery procedures
    recovery_procedures:
      automated_failover:
        enabled: true
        timeout: "30 seconds"
        
      point_in_time_recovery:
        enabled: true
        granularity: "1 second"
        
      cross_region_recovery:
        enabled: true
        target_region: "australia-southeast2"
        
    # Recovery testing
    recovery_testing:
      schedule: "monthly"
      test_types:
        - "point_in_time_recovery"
        - "full_database_restore"
        - "failover_simulation"

  # Australian compliance for backups
  compliance_config: |
    # Privacy Act 1988 compliance
    privacy_act_compliance:
      data_retention: "7 years"
      encryption_at_rest: "required"
      encryption_in_transit: "required"
      access_logging: "comprehensive"
      data_residency: "australia_only"
      
    # Security requirements
    security_requirements:
      backup_encryption: "AES-256"
      access_controls: "role_based"
      audit_trail: "complete"
      data_classification: "restricted"
      
    # Compliance validation
    validation_requirements:
      backup_integrity_checks: "daily"
      compliance_audits: "quarterly"
      data_residency_verification: "continuous"

---
# Database Backup Service Account
apiVersion: v1
kind: ServiceAccount
metadata:
  name: database-backup-service
  namespace: act-placemat
  labels:
    component: database
    role: backup-service
    data-residency: australia
  annotations:
    description: "Service account for database backup operations"
    compliance.framework: "australian-privacy-act"
    iam.gke.io/gcp-service-account: "database-backup-service@act-placemat-intelligence-hub.iam.gserviceaccount.com"
    data.classification: "restricted"
    audit.required: "true"
automountServiceAccountToken: true

---
# Database Backup CronJob - Full Backup
apiVersion: batch/v1
kind: CronJob
metadata:
  name: database-full-backup
  namespace: act-placemat
  labels:
    component: database
    operation: full-backup
    data-residency: australia
  annotations:
    description: "Daily full database backup with Australian compliance"
    compliance.framework: "australian-privacy-act"
spec:
  schedule: "0 2 * * *"  # Daily at 2 AM AEDT
  timeZone: "Australia/Sydney"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 7
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            component: database-full-backup
            data-residency: australia
        spec:
          serviceAccountName: database-backup-service
          restartPolicy: OnFailure
          securityContext:
            runAsNonRoot: true
            runAsUser: 1001
            fsGroup: 1001
          containers:
          - name: full-backup
            image: google/cloud-sdk:alpine
            env:
            - name: TZ
              value: "Australia/Sydney"
            - name: DATA_RESIDENCY
              value: "australia"
            - name: COMPLIANCE_FRAMEWORK
              value: "australian-privacy-act"
            - name: PROJECT_ID
              value: "act-placemat-intelligence-hub"
            - name: INSTANCE_ID
              value: "act-placemat-intelligence-hub-postgres"
            - name: BACKUP_LOCATION
              value: "australia-southeast1"
            command:
            - /bin/sh
            - -c
            - |
              echo "Starting full database backup at $(date)"
              
              # Function to create full backup
              create_full_backup() {
                local backup_id="full-backup-$(date +%Y%m%d-%H%M%S)"
                
                echo "Creating full backup: $backup_id"
                
                # Create Cloud SQL backup
                if gcloud sql backups create \
                  --instance="$INSTANCE_ID" \
                  --project="$PROJECT_ID" \
                  --location="$BACKUP_LOCATION" \
                  --description="Full automated backup - Australian compliance" \
                  --type="ON_DEMAND" 2>&1; then
                  
                  echo "‚úÖ Full backup created: $backup_id"
                  
                  # Get backup details
                  BACKUP_DETAILS=$(gcloud sql backups list \
                    --instance="$INSTANCE_ID" \
                    --project="$PROJECT_ID" \
                    --limit=1 \
                    --format="value(id,startTime,endTime,type,status)" 2>/dev/null)
                    
                  echo "üìä Backup details: $BACKUP_DETAILS"
                  
                  # Create backup completion event
                  kubectl create event database-full-backup-completed-$(date +%s) \
                    --message="Full database backup completed successfully: $backup_id" \
                    --reason="DatabaseBackupCompleted" \
                    --type="Normal" \
                    --source="database-full-backup" \
                    --namespace=act-placemat
                    
                  return 0
                else
                  echo "‚ùå Full backup failed"
                  
                  # Create backup failure event
                  kubectl create event database-full-backup-failed-$(date +%s) \
                    --message="Full database backup failed" \
                    --reason="DatabaseBackupFailed" \
                    --type="Warning" \
                    --source="database-full-backup" \
                    --namespace=act-placemat
                    
                  return 1
                fi
              }
              
              # Function to validate backup integrity
              validate_backup_integrity() {
                echo "Validating backup integrity..."
                
                # List recent backups
                RECENT_BACKUPS=$(gcloud sql backups list \
                  --instance="$INSTANCE_ID" \
                  --project="$PROJECT_ID" \
                  --limit=5 \
                  --format="value(id,status)" 2>/dev/null)
                  
                echo "Recent backups: $RECENT_BACKUPS"
                
                # Check if latest backup is successful
                LATEST_BACKUP_STATUS=$(echo "$RECENT_BACKUPS" | head -1 | cut -d$'\t' -f2)
                
                if [ "$LATEST_BACKUP_STATUS" = "SUCCESSFUL" ]; then
                  echo "‚úÖ Latest backup integrity validated"
                  return 0
                else
                  echo "‚ùå Latest backup integrity check failed: $LATEST_BACKUP_STATUS"
                  return 1
                fi
              }
              
              # Function to cleanup old backups
              cleanup_old_backups() {
                echo "Cleaning up old backups (retention: 30 days)..."
                
                # Get backups older than 30 days
                CUTOFF_DATE=$(date -d '30 days ago' -u +%Y-%m-%dT%H:%M:%SZ)
                
                OLD_BACKUPS=$(gcloud sql backups list \
                  --instance="$INSTANCE_ID" \
                  --project="$PROJECT_ID" \
                  --filter="startTime<'$CUTOFF_DATE' AND type='ON_DEMAND'" \
                  --format="value(id)" 2>/dev/null)
                  
                if [ -n "$OLD_BACKUPS" ]; then
                  echo "Found old backups to delete:"
                  echo "$OLD_BACKUPS"
                  
                  # Delete old backups
                  for backup_id in $OLD_BACKUPS; do
                    echo "Deleting old backup: $backup_id"
                    gcloud sql backups delete "$backup_id" \
                      --instance="$INSTANCE_ID" \
                      --project="$PROJECT_ID" \
                      --quiet 2>/dev/null || true
                  done
                  
                  echo "‚úÖ Old backups cleaned up"
                else
                  echo "‚úÖ No old backups to clean up"
                fi
              }
              
              # Run backup operations
              BACKUP_FAILURES=0
              
              if ! create_full_backup; then
                BACKUP_FAILURES=$((BACKUP_FAILURES + 1))
              fi
              
              if ! validate_backup_integrity; then
                BACKUP_FAILURES=$((BACKUP_FAILURES + 1))
              fi
              
              cleanup_old_backups
              
              # Generate backup report
              BACKUP_STATUS="SUCCESS"
              if [ $BACKUP_FAILURES -gt 0 ]; then
                BACKUP_STATUS="FAILED"
              fi
              
              cat > /tmp/full-backup-report.json << EOF
              {
                "backup_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
                "backup_type": "full_backup",
                "backup_status": "$BACKUP_STATUS",
                "compliance_framework": "Australian Privacy Act 1988",
                "data_residency": "australia",
                "instance_id": "$INSTANCE_ID",
                "backup_location": "$BACKUP_LOCATION",
                "backup_failures": $BACKUP_FAILURES,
                "next_backup": "$(date -d '+1 day' -u +%Y-%m-%dT%H:%M:%SZ)"
              }
              EOF
              
              # Store backup report
              kubectl create configmap database-full-backup-report-$(date +%Y%m%d) \
                --from-file=report.json=/tmp/full-backup-report.json \
                --from-literal="backup_status=$BACKUP_STATUS" \
                --from-literal="backup_failures=$BACKUP_FAILURES" \
                --from-literal="compliance_framework=australian-privacy-act" \
                --from-literal="data_residency=australia" \
                -n act-placemat --dry-run=client -o yaml | kubectl apply -f -
              
              echo "Full database backup completed at $(date)"
              echo "Backup status: $BACKUP_STATUS"
              
              # Exit with appropriate code
              exit $BACKUP_FAILURES
            resources:
              limits:
                cpu: 300m
                memory: 512Mi
              requests:
                cpu: 150m
                memory: 256Mi
            securityContext:
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              runAsNonRoot: true
              runAsUser: 1001
              capabilities:
                drop:
                - ALL
            volumeMounts:
            - name: tmp
              mountPath: /tmp
            - name: gcp-credentials
              mountPath: /var/secrets/google
              readOnly: true
          volumes:
          - name: tmp
            emptyDir: {}
          - name: gcp-credentials
            secret:
              secretName: database-backup-service-gcp-credentials
          imagePullSecrets:
          - name: registry-credentials
          nodeSelector:
            data-residency: australia

---
# Database Backup CronJob - Incremental Backup
apiVersion: batch/v1
kind: CronJob
metadata:
  name: database-incremental-backup
  namespace: act-placemat
  labels:
    component: database
    operation: incremental-backup
    data-residency: australia
  annotations:
    description: "Incremental database backup every 6 hours"
    compliance.framework: "australian-privacy-act"
spec:
  schedule: "0 */6 * * *"  # Every 6 hours
  timeZone: "Australia/Sydney"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 4
  failedJobsHistoryLimit: 2
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            component: database-incremental-backup
            data-residency: australia
        spec:
          serviceAccountName: database-backup-service
          restartPolicy: OnFailure
          securityContext:
            runAsNonRoot: true
            runAsUser: 1001
            fsGroup: 1001
          containers:
          - name: incremental-backup
            image: postgres:16-alpine
            env:
            - name: TZ
              value: "Australia/Sydney"
            - name: DATA_RESIDENCY
              value: "australia"
            - name: COMPLIANCE_FRAMEWORK
              value: "australian-privacy-act"
            - name: PGHOST
              value: "cloudsql-proxy-service.act-placemat.svc.cluster.local"
            - name: PGPORT
              value: "5432"
            - name: PGUSER
              valueFrom:
                secretKeyRef:
                  name: database-connection-config
                  key: postgres-username
            - name: PGPASSWORD
              valueFrom:
                secretKeyRef:
                  name: database-connection-config
                  key: postgres-password
            - name: PGSSLMODE
              value: "require"
            command:
            - /bin/sh
            - -c
            - |
              echo "Starting incremental database backup at $(date)"
              
              # Function to create incremental backup using pg_dump
              create_incremental_backup() {
                local backup_timestamp=$(date +%Y%m%d-%H%M%S)
                local backup_dir="/tmp/incremental-backup-$backup_timestamp"
                
                mkdir -p "$backup_dir"
                
                echo "Creating incremental backup: $backup_timestamp"
                
                # Backup agent state database
                echo "Backing up agent_state_db..."
                if pg_dump -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d agent_state_db \
                  --verbose --format=custom --compress=9 \
                  --file="$backup_dir/agent_state_db-$backup_timestamp.dump" 2>&1; then
                  echo "‚úÖ agent_state_db backup completed"
                else
                  echo "‚ùå agent_state_db backup failed"
                  return 1
                fi
                
                # Backup task queue database
                echo "Backing up task_queue_db..."
                if pg_dump -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d task_queue_db \
                  --verbose --format=custom --compress=9 \
                  --file="$backup_dir/task_queue_db-$backup_timestamp.dump" 2>&1; then
                  echo "‚úÖ task_queue_db backup completed"
                else
                  echo "‚ùå task_queue_db backup failed"
                  return 1
                fi
                
                # Create backup manifest
                cat > "$backup_dir/backup-manifest.json" << EOF
              {
                "backup_timestamp": "$backup_timestamp",
                "backup_type": "incremental",
                "databases": ["agent_state_db", "task_queue_db"],
                "compliance_framework": "Australian Privacy Act 1988",
                "data_residency": "australia",
                "backup_size": "$(du -sh $backup_dir | cut -f1)",
                "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
              }
              EOF
                
                echo "‚úÖ Incremental backup manifest created"
                
                # Simulate upload to Australian storage (in real implementation, this would be GCS)
                echo "üì§ Uploading incremental backup to Australian storage..."
                
                # Create backup completion event
                kubectl create event database-incremental-backup-completed-$(date +%s) \
                  --message="Incremental database backup completed: $backup_timestamp" \
                  --reason="DatabaseIncrementalBackupCompleted" \
                  --type="Normal" \
                  --source="database-incremental-backup" \
                  --namespace=act-placemat
                  
                return 0
              }
              
              # Function to validate incremental backup
              validate_incremental_backup() {
                echo "Validating incremental backup..."
                
                # Check if backup files were created
                BACKUP_FILES=$(find /tmp -name "*incremental-backup*" -type d | wc -l)
                
                if [ "$BACKUP_FILES" -gt 0 ]; then
                  echo "‚úÖ Incremental backup files validated: $BACKUP_FILES backups"
                  return 0
                else
                  echo "‚ùå No incremental backup files found"
                  return 1
                fi
              }
              
              # Run incremental backup
              BACKUP_FAILURES=0
              
              if ! create_incremental_backup; then
                BACKUP_FAILURES=$((BACKUP_FAILURES + 1))
              fi
              
              if ! validate_incremental_backup; then
                BACKUP_FAILURES=$((BACKUP_FAILURES + 1))
              fi
              
              # Generate incremental backup report
              BACKUP_STATUS="SUCCESS"
              if [ $BACKUP_FAILURES -gt 0 ]; then
                BACKUP_STATUS="FAILED"
              fi
              
              cat > /tmp/incremental-backup-report.json << EOF
              {
                "backup_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
                "backup_type": "incremental_backup",
                "backup_status": "$BACKUP_STATUS",
                "compliance_framework": "Australian Privacy Act 1988",
                "data_residency": "australia",
                "databases_backed_up": ["agent_state_db", "task_queue_db"],
                "backup_failures": $BACKUP_FAILURES,
                "next_backup": "$(date -d '+6 hours' -u +%Y-%m-%dT%H:%M:%SZ)"
              }
              EOF
              
              # Store backup report
              kubectl create configmap database-incremental-backup-report-$(date +%Y%m%d-%H%M) \
                --from-file=report.json=/tmp/incremental-backup-report.json \
                --from-literal="backup_status=$BACKUP_STATUS" \
                --from-literal="backup_failures=$BACKUP_FAILURES" \
                --from-literal="compliance_framework=australian-privacy-act" \
                --from-literal="data_residency=australia" \
                -n act-placemat --dry-run=client -o yaml | kubectl apply -f -
              
              echo "Incremental database backup completed at $(date)"
              echo "Backup status: $BACKUP_STATUS"
              
              # Exit with appropriate code
              exit $BACKUP_FAILURES
            resources:
              limits:
                cpu: 300m
                memory: 512Mi
              requests:
                cpu: 150m
                memory: 256Mi
            securityContext:
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              runAsNonRoot: true
              runAsUser: 1001
              capabilities:
                drop:
                - ALL
            volumeMounts:
            - name: tmp
              mountPath: /tmp
          volumes:
          - name: tmp
            emptyDir: {}
          imagePullSecrets:
          - name: registry-credentials
          nodeSelector:
            data-residency: australia

---
# Database High Availability Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: database-ha-config
  namespace: act-placemat
  labels:
    component: database
    configuration-type: high-availability
    data-residency: australia
  annotations:
    description: "High availability configuration for Cloud SQL"
    compliance.framework: "australian-privacy-act"
data:
  ha_config: |
    # High availability settings
    high_availability:
      availability_type: "REGIONAL"  # Multi-zone high availability
      enabled: true
      
    # Failover configuration  
    failover:
      automatic_failover: true
      failover_timeout: "30 seconds"
      replica_lag_threshold: "60 seconds"
      
    # Read replicas for load distribution
    read_replicas:
      enabled: true
      count: 2
      regions: ["australia-southeast1", "australia-southeast2"]
      tier: "db-custom-2-8192"  # 2 vCPUs, 8GB RAM
      
    # Connection pooling for reliability
    connection_pooling:
      enabled: true
      max_connections: 100
      pool_size: 25
      
    # Monitoring and alerting
    monitoring:
      availability_sla: "99.95%"
      health_check_interval: "30 seconds"
      alert_on_failover: true
      alert_on_high_latency: true

  # Disaster recovery procedures
  disaster_recovery: |
    # Recovery procedures
    recovery_procedures:
      cross_region_recovery:
        enabled: true
        target_region: "australia-southeast2"
        recovery_time_objective: "15 minutes"
        recovery_point_objective: "1 minute"
        
      backup_restoration:
        automated: true
        point_in_time_recovery: true
        
      data_validation:
        post_recovery_checks: true
        integrity_validation: true
        
    # Business continuity
    business_continuity:
      maximum_tolerable_downtime: "15 minutes"
      critical_business_functions:
        - "agent_state_persistence"
        - "task_queue_processing"
        - "compliance_audit_logging"

---
# Database HA Monitoring Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: database-ha-monitor
  namespace: act-placemat
  labels:
    component: database
    monitor-type: high-availability
    data-residency: australia
  annotations:
    description: "High availability monitoring for Cloud SQL database"
    compliance.framework: "australian-privacy-act"
spec:
  replicas: 1
  selector:
    matchLabels:
      component: database-ha-monitor
      data-residency: australia
  template:
    metadata:
      labels:
        component: database-ha-monitor
        data-residency: australia
      annotations:
        compliance.framework: "australian-privacy-act"
        data.classification: "restricted"
        audit.required: "true"
    spec:
      serviceAccountName: database-ha-monitor-service
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
        fsGroup: 1001
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: "kubernetes.io/zone"
                operator: In
                values:
                - "australia-southeast1-a"
                - "australia-southeast1-b"
                - "australia-southeast1-c"
      containers:
      - name: ha-monitor
        image: registry.actplacemat.org.au:5000/act-placemat/database-ha-monitor:latest
        imagePullPolicy: Always
        env:
        - name: TZ
          value: "Australia/Sydney"
        - name: DATA_RESIDENCY
          value: "australia"
        - name: COMPLIANCE_FRAMEWORK
          value: "australian-privacy-act"
        - name: PROJECT_ID
          value: "act-placemat-intelligence-hub"
        - name: INSTANCE_ID
          value: "act-placemat-intelligence-hub-postgres"
        - name: MONITORING_INTERVAL
          value: "30"
        ports:
        - name: metrics
          containerPort: 8080
          protocol: TCP
        - name: health
          containerPort: 8081
          protocol: TCP
        livenessProbe:
          httpGet:
            path: /health
            port: health
          initialDelaySeconds: 30
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /ready
            port: health
          initialDelaySeconds: 5
          periodSeconds: 10
        resources:
          limits:
            cpu: 300m
            memory: 512Mi
          requests:
            cpu: 150m
            memory: 256Mi
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 1001
          capabilities:
            drop:
            - ALL
        volumeMounts:
        - name: tmp
          mountPath: /tmp
        - name: config
          mountPath: /etc/ha-config
          readOnly: true
        - name: gcp-credentials
          mountPath: /var/secrets/google
          readOnly: true
      volumes:
      - name: tmp
        emptyDir: {}
      - name: config
        configMap:
          name: database-ha-config
      - name: gcp-credentials
        secret:
          secretName: database-ha-monitor-service-gcp-credentials
      imagePullSecrets:
      - name: registry-credentials
      nodeSelector:
        data-residency: australia

---
# Database HA Monitor Service Account
apiVersion: v1
kind: ServiceAccount
metadata:
  name: database-ha-monitor-service
  namespace: act-placemat
  labels:
    component: database
    role: ha-monitor
    data-residency: australia
  annotations:
    description: "Service account for database HA monitoring"
    compliance.framework: "australian-privacy-act"
    iam.gke.io/gcp-service-account: "database-ha-monitor@act-placemat-intelligence-hub.iam.gserviceaccount.com"
    data.classification: "restricted"
    audit.required: "true"
automountServiceAccountToken: true

---
# Database HA Monitor Service
apiVersion: v1
kind: Service
metadata:
  name: database-ha-monitor-metrics
  namespace: act-placemat
  labels:
    component: database
    monitor-type: high-availability
    data-residency: australia
  annotations:
    description: "Metrics service for database HA monitoring"
    compliance.framework: "australian-privacy-act"
spec:
  selector:
    component: database-ha-monitor
    data-residency: australia
  ports:
  - name: metrics
    port: 8080
    targetPort: metrics
    protocol: TCP
  - name: health
    port: 8081
    targetPort: health
    protocol: TCP
  type: ClusterIP

---
# Database Backup RBAC Role
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: database-backup-service
  namespace: act-placemat
  labels:
    component: database
    data-residency: australia
  annotations:
    description: "Role for database backup operations"
    compliance.framework: "australian-privacy-act"
rules:
# Event creation for backup status
- apiGroups: [""]
  resources: ["events"]
  verbs: ["create", "patch"]
# ConfigMap creation for backup reports
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["create", "update", "patch"]
  resourceNames: ["database-*-backup-report-*"]

---
# Database Backup Role Binding
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: database-backup-service-binding
  namespace: act-placemat
  labels:
    component: database
    data-residency: australia
  annotations:
    description: "Binds database-backup-service to backup operations role"
    compliance.framework: "australian-privacy-act"
subjects:
- kind: ServiceAccount
  name: database-backup-service
  namespace: act-placemat
roleRef:
  kind: Role
  name: database-backup-service
  apiGroup: rbac.authorization.k8s.io