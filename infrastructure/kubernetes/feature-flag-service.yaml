# ACT Placemat Feature Flag Service with Cultural Sensitivity Controls
# Advanced feature flag management with Indigenous data sovereignty compliance

---
# ========================================
# FEATURE FLAG SERVICE DEPLOYMENT
# ========================================

apiVersion: apps/v1
kind: Deployment
metadata:
  name: feature-flag-service
  namespace: act-production
  labels:
    app: feature-flag-service
    component: deployment-management
spec:
  replicas: 3
  selector:
    matchLabels:
      app: feature-flag-service
  template:
    metadata:
      labels:
        app: feature-flag-service
        component: deployment-management
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      containers:
      - name: feature-flag-service
        image: node:18-alpine
        ports:
        - containerPort: 8080
          name: http
        - containerPort: 9090
          name: metrics
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-secrets
              key: postgres-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-secrets
              key: redis-url
        - name: CULTURAL_ADVISOR_SERVICE_URL
          value: "http://cultural-advisor-service:8080"
        - name: ELDER_CONSULTATION_SERVICE_URL
          value: "http://elder-consultation-service:8080"
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: auth-secrets
              key: jwt-secret
        volumeMounts:
        - name: feature-flag-config
          mountPath: /app/config
        - name: feature-flag-source
          mountPath: /app
        command: ["node", "server.js"]
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: feature-flag-config
        configMap:
          name: feature-flag-config
      - name: feature-flag-source
        configMap:
          name: feature-flag-source-code

---
apiVersion: v1
kind: Service
metadata:
  name: feature-flag-service
  namespace: act-production
  labels:
    app: feature-flag-service
spec:
  selector:
    app: feature-flag-service
  ports:
  - name: http
    port: 8080
    targetPort: 8080
  - name: metrics
    port: 9090
    targetPort: 9090
  type: ClusterIP

---
# ========================================
# FEATURE FLAG CONFIGURATION
# ========================================

apiVersion: v1
kind: ConfigMap
metadata:
  name: feature-flag-config
  namespace: act-production
data:
  config.yaml: |
    # Feature Flag Service Configuration
    
    server:
      port: 8080
      metrics_port: 9090
      environment: production
      
    database:
      pool_size: 20
      connection_timeout: 5000
      idle_timeout: 300000
      
    redis:
      pool_size: 15
      connection_timeout: 1000
      key_prefix: "act_feature_flags:"
      ttl: 300  # 5 minutes
    
    # Cultural Sensitivity Controls
    cultural_controls:
      default_elder_approval_required: false
      default_cultural_advisor_review: true
      cultural_impact_assessment_required: true
      traditional_owner_notification_required: false
      
      # Classification-based controls
      classification_controls:
        sacred:
          elder_approval_required: true
          cultural_advisor_review: true
          traditional_owner_notification: true
          rollout_speed_limit: "manual_only"
          community_consultation_required: true
          
        sensitive:
          elder_approval_required: false
          cultural_advisor_review: true
          traditional_owner_notification: true
          rollout_speed_limit: "conservative"  # 5% steps max
          community_consultation_required: true
          
        general:
          elder_approval_required: false
          cultural_advisor_review: true
          traditional_owner_notification: false
          rollout_speed_limit: "standard"  # 25% steps max
          community_consultation_required: false
    
    # Rollout Configuration
    rollout:
      default_strategy: "progressive"
      max_rollout_speed: 0.1  # 10% per hour max
      cultural_community_first: true
      
      stages:
        canary:
          percentage: 1
          duration_hours: 24
          target_groups: ["cultural_advisors", "beta_testers"]
          
        early:
          percentage: 5  
          duration_hours: 48
          target_groups: ["community_leaders", "early_adopters"]
          
        progressive:
          percentages: [15, 30, 50, 75]
          duration_hours: 72
          target_groups: ["community_members", "general_users"]
          
        full:
          percentage: 100
          requires_approval: true
    
    # Security and Permissions
    security:
      jwt_validation: true
      role_based_access: true
      elder_override_capability: true
      cultural_advisor_veto_power: true
      
      roles:
        elder_council:
          can_approve_sacred: true
          can_veto_any: true
          can_emergency_rollback: true
          
        cultural_advisor:
          can_approve_sensitive: true
          can_veto_cultural_impact: true
          can_request_rollback: true
          
        admin:
          can_manage_general: true
          can_view_all: true
          can_technical_rollback: true
          
        developer:
          can_create_flags: true
          can_test: true
          can_view_own: true
    
    # Monitoring and Alerting
    monitoring:
      cultural_compliance_checks: true
      community_impact_tracking: true
      elder_consultation_monitoring: true
      performance_impact_tracking: true
      
      alerts:
        cultural_violation_threshold: 0  # Zero tolerance
        community_dissatisfaction_threshold: 6.0  # Out of 10
        elder_concern_threshold: 1
        performance_degradation_threshold: 0.95  # 5% degradation max

---
# ========================================
# FEATURE FLAG SERVICE SOURCE CODE
# ========================================

apiVersion: v1
kind: ConfigMap
metadata:
  name: feature-flag-source-code
  namespace: act-production
data:
  server.js: |
    const express = require('express');
    const { Pool } = require('pg');
    const Redis = require('ioredis');
    const yaml = require('js-yaml');
    const fs = require('fs');
    const jwt = require('jsonwebtoken');
    const axios = require('axios');
    const prometheus = require('prom-client');
    const rateLimit = require('express-rate-limit');

    // Load configuration
    const config = yaml.load(fs.readFileSync('/app/config/config.yaml', 'utf8'));

    // Initialize Express app
    const app = express();
    app.use(express.json());

    // Rate limiting
    const limiter = rateLimit({
      windowMs: 60 * 1000, // 1 minute
      max: 100 // limit each IP to 100 requests per windowMs
    });
    app.use(limiter);

    // Initialize database and Redis connections
    const db = new Pool({ connectionString: process.env.DATABASE_URL });
    const redis = new Redis(process.env.REDIS_URL);

    // Prometheus metrics
    const featureFlagRequests = new prometheus.Counter({
      name: 'feature_flag_requests_total',
      help: 'Total number of feature flag requests',
      labelNames: ['flag_name', 'user_segment', 'result']
    });

    const culturalApprovalRequests = new prometheus.Counter({
      name: 'cultural_approval_requests_total',
      help: 'Total number of cultural approval requests',
      labelNames: ['approval_type', 'status']
    });

    const featureFlagExposure = new prometheus.Gauge({
      name: 'feature_flag_exposure_percentage',
      help: 'Current exposure percentage for feature flags',
      labelNames: ['flag_name', 'segment']
    });

    const culturalProtocolViolations = new prometheus.Counter({
      name: 'cultural_protocol_violations_total',
      help: 'Total number of cultural protocol violations',
      labelNames: ['violation_type', 'flag_name']
    });

    // Feature Flag Management Service
    class FeatureFlagService {
      constructor() {
        this.culturalValidator = new CulturalValidator();
        this.rolloutManager = new RolloutManager();
        this.approvalWorkflow = new ApprovalWorkflow();
      }

      async initializeDatabase() {
        // Create feature flags tables
        await db.query(`
          CREATE TABLE IF NOT EXISTS feature_flags (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            name VARCHAR(255) UNIQUE NOT NULL,
            description TEXT,
            classification VARCHAR(50) NOT NULL DEFAULT 'general',
            created_by VARCHAR(255) NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            
            -- Configuration
            enabled BOOLEAN DEFAULT false,
            rollout_percentage FLOAT DEFAULT 0.0,
            rollout_strategy VARCHAR(50) DEFAULT 'progressive',
            target_segments JSONB DEFAULT '[]',
            
            -- Cultural controls
            cultural_impact_score INTEGER DEFAULT 5,
            requires_elder_approval BOOLEAN DEFAULT false,
            requires_cultural_advisor_review BOOLEAN DEFAULT true,
            traditional_owner_groups JSONB DEFAULT '[]',
            cultural_considerations TEXT,
            
            -- Status tracking
            approval_status VARCHAR(50) DEFAULT 'pending',
            rollout_status VARCHAR(50) DEFAULT 'not_started',
            emergency_disabled BOOLEAN DEFAULT false,
            disabled_reason TEXT,
            
            -- Metadata
            metadata JSONB DEFAULT '{}',
            rollout_history JSONB DEFAULT '[]'
          );
        `);

        await db.query(`
          CREATE TABLE IF NOT EXISTS cultural_approvals (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            feature_flag_id UUID NOT NULL REFERENCES feature_flags(id),
            approval_type VARCHAR(50) NOT NULL,
            approver_type VARCHAR(50) NOT NULL,
            approver_id VARCHAR(255) NOT NULL,
            status VARCHAR(50) DEFAULT 'pending',
            comments TEXT,
            cultural_concerns JSONB,
            approved_at TIMESTAMP,
            expires_at TIMESTAMP,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            
            UNIQUE(feature_flag_id, approval_type)
          );
        `);

        await db.query(`
          CREATE TABLE IF NOT EXISTS rollout_events (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            feature_flag_id UUID NOT NULL REFERENCES feature_flags(id),
            event_type VARCHAR(50) NOT NULL,
            previous_percentage FLOAT,
            new_percentage FLOAT,
            target_segments JSONB,
            triggered_by VARCHAR(255) NOT NULL,
            trigger_reason TEXT,
            cultural_check_passed BOOLEAN,
            event_metadata JSONB,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );
        `);

        await db.query(`
          CREATE TABLE IF NOT EXISTS cultural_impact_assessments (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            feature_flag_id UUID NOT NULL REFERENCES feature_flags(id),
            assessment_type VARCHAR(50) NOT NULL,
            cultural_risk_level VARCHAR(50) NOT NULL,
            sacred_content_impact BOOLEAN DEFAULT false,
            traditional_knowledge_impact BOOLEAN DEFAULT false,
            community_consultation_required BOOLEAN DEFAULT false,
            elder_guidance_required BOOLEAN DEFAULT false,
            assessment_details JSONB,
            assessed_by VARCHAR(255) NOT NULL,
            assessed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            valid_until TIMESTAMP
          );
        `);

        // Create indexes for performance
        await db.query(`
          CREATE INDEX IF NOT EXISTS idx_feature_flags_name ON feature_flags(name);
          CREATE INDEX IF NOT EXISTS idx_feature_flags_classification ON feature_flags(classification);
          CREATE INDEX IF NOT EXISTS idx_feature_flags_enabled ON feature_flags(enabled);
          CREATE INDEX IF NOT EXISTS idx_cultural_approvals_feature_flag ON cultural_approvals(feature_flag_id);
          CREATE INDEX IF NOT EXISTS idx_rollout_events_feature_flag ON rollout_events(feature_flag_id);
        `);

        console.log('Feature Flag Service database initialized');
      }

      async createFeatureFlag(flagData, createdBy) {
        try {
          // Cultural sensitivity validation
          const culturalValidation = await this.culturalValidator.validateNewFlag(flagData);
          if (!culturalValidation.valid) {
            return {
              success: false,
              error: 'Cultural validation failed',
              details: culturalValidation.issues
            };
          }

          // Determine cultural controls based on classification
          const culturalControls = this.determineCulturalControls(flagData.classification);

          // Create feature flag
          const result = await db.query(`
            INSERT INTO feature_flags (
              name, description, classification, created_by,
              cultural_impact_score, requires_elder_approval, requires_cultural_advisor_review,
              traditional_owner_groups, cultural_considerations
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
            RETURNING *
          `, [
            flagData.name,
            flagData.description,
            flagData.classification || 'general',
            createdBy,
            flagData.cultural_impact_score || 5,
            culturalControls.requires_elder_approval,
            culturalControls.requires_cultural_advisor_review,
            JSON.stringify(flagData.traditional_owner_groups || []),
            flagData.cultural_considerations || ''
          ]);

          const featureFlag = result.rows[0];

          // Initiate cultural impact assessment
          await this.initiateculturalImpactAssessment(featureFlag.id, createdBy);

          // Start approval workflow if required
          if (culturalControls.requires_elder_approval || culturalControls.requires_cultural_advisor_review) {
            await this.approvalWorkflow.initiateApproval(featureFlag.id, culturalControls);
          }

          return {
            success: true,
            feature_flag: featureFlag,
            cultural_controls: culturalControls
          };

        } catch (error) {
          console.error('Error creating feature flag:', error);
          throw error;
        }
      }

      determineCulturalControls(classification) {
        const controls = config.cultural_controls.classification_controls[classification] || 
                        config.cultural_controls.classification_controls.general;
        
        return {
          requires_elder_approval: controls.elder_approval_required,
          requires_cultural_advisor_review: controls.cultural_advisor_review,
          traditional_owner_notification: controls.traditional_owner_notification,
          rollout_speed_limit: controls.rollout_speed_limit,
          community_consultation_required: controls.community_consultation_required
        };
      }

      async initiateculturalImpactAssessment(featureFlagId, assessedBy) {
        try {
          // Get feature flag details
          const flagResult = await db.query('SELECT * FROM feature_flags WHERE id = $1', [featureFlagId]);
          const featureFlag = flagResult.rows[0];

          if (!featureFlag) {
            throw new Error('Feature flag not found');
          }

          // Perform cultural impact analysis
          const culturalAnalysis = await this.culturalValidator.assessCulturalImpact(featureFlag);

          // Store assessment
          await db.query(`
            INSERT INTO cultural_impact_assessments (
              feature_flag_id, assessment_type, cultural_risk_level,
              sacred_content_impact, traditional_knowledge_impact,
              community_consultation_required, elder_guidance_required,
              assessment_details, assessed_by, valid_until
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
          `, [
            featureFlagId,
            'initial',
            culturalAnalysis.risk_level,
            culturalAnalysis.sacred_content_impact,
            culturalAnalysis.traditional_knowledge_impact,
            culturalAnalysis.community_consultation_required,
            culturalAnalysis.elder_guidance_required,
            JSON.stringify(culturalAnalysis.details),
            assessedBy,
            new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // Valid for 30 days
          ]);

          console.log(`Cultural impact assessment completed for feature flag: ${featureFlag.name}`);
          return culturalAnalysis;

        } catch (error) {
          console.error('Error in cultural impact assessment:', error);
          throw error;
        }
      }

      async evaluateFeatureFlag(flagName, userId, userContext = {}) {
        try {
          featureFlagRequests.labels(flagName, userContext.segment || 'unknown', 'evaluated').inc();

          // Try cache first
          const cacheKey = `${config.redis.key_prefix}${flagName}:${userId}`;
          let cachedResult = await redis.get(cacheKey);
          
          if (cachedResult) {
            const result = JSON.parse(cachedResult);
            featureFlagRequests.labels(flagName, userContext.segment || 'unknown', 'cache_hit').inc();
            return result;
          }

          // Get feature flag from database
          const flagResult = await db.query('SELECT * FROM feature_flags WHERE name = $1', [flagName]);
          
          if (flagResult.rows.length === 0) {
            return { enabled: false, reason: 'flag_not_found' };
          }

          const featureFlag = flagResult.rows[0];

          // Check if feature flag is enabled
          if (!featureFlag.enabled || featureFlag.emergency_disabled) {
            return { 
              enabled: false, 
              reason: featureFlag.emergency_disabled ? 'emergency_disabled' : 'flag_disabled'
            };
          }

          // Check cultural permissions
          const culturalCheck = await this.checkCulturalPermissions(featureFlag, userId, userContext);
          if (!culturalCheck.allowed) {
            culturalProtocolViolations.labels('access_denied', flagName).inc();
            return {
              enabled: false,
              reason: 'cultural_restriction',
              cultural_context: culturalCheck.reason
            };
          }

          // Check rollout percentage and user assignment
          const rolloutResult = await this.rolloutManager.checkUserInRollout(
            featureFlag,
            userId,
            userContext
          );

          // Cache result
          const result = {
            enabled: rolloutResult.included,
            reason: rolloutResult.reason,
            rollout_percentage: featureFlag.rollout_percentage,
            cultural_context: culturalCheck,
            metadata: {
              flag_id: featureFlag.id,
              evaluated_at: new Date().toISOString()
            }
          };

          await redis.setex(cacheKey, config.redis.ttl, JSON.stringify(result));

          featureFlagRequests.labels(flagName, userContext.segment || 'unknown', 'database_hit').inc();
          return result;

        } catch (error) {
          console.error('Error evaluating feature flag:', error);
          featureFlagRequests.labels(flagName, userContext.segment || 'unknown', 'error').inc();
          return { enabled: false, reason: 'evaluation_error' };
        }
      }

      async checkCulturalPermissions(featureFlag, userId, userContext) {
        try {
          // Get user's cultural context
          const userCulturalContext = await this.getUserCulturalContext(userId, userContext);

          // Check classification-based restrictions
          switch (featureFlag.classification) {
            case 'sacred':
              return await this.checkSacredDataAccess(featureFlag, userCulturalContext);
            case 'sensitive':
              return await this.checkSensitiveCulturalAccess(featureFlag, userCulturalContext);
            case 'general':
              return { allowed: true, reason: 'general_classification' };
            default:
              return { allowed: true, reason: 'default_permission' };
          }

        } catch (error) {
          console.error('Error checking cultural permissions:', error);
          return { allowed: false, reason: 'permission_check_error' };
        }
      }

      async checkSacredDataAccess(featureFlag, userCulturalContext) {
        // Sacred data access requires Elder approval and specific cultural permissions
        if (!userCulturalContext.elderApprovedAccess) {
          return { 
            allowed: false, 
            reason: 'sacred_data_requires_elder_approval'
          };
        }

        if (!userCulturalContext.culturallyAuthorized) {
          return { 
            allowed: false, 
            reason: 'insufficient_cultural_authorization'
          };
        }

        // Check if user belongs to relevant Traditional Owner groups
        const flagTraditionalOwnerGroups = featureFlag.traditional_owner_groups || [];
        const userTraditionalOwnerGroups = userCulturalContext.traditionalOwnerGroups || [];

        if (flagTraditionalOwnerGroups.length > 0) {
          const hasRelevantGroupMembership = flagTraditionalOwnerGroups.some(group =>
            userTraditionalOwnerGroups.includes(group)
          );

          if (!hasRelevantGroupMembership) {
            return { 
              allowed: false, 
              reason: 'not_member_of_relevant_traditional_owner_group'
            };
          }
        }

        return { 
          allowed: true, 
          reason: 'sacred_data_access_authorized',
          cultural_context: userCulturalContext
        };
      }

      async getUserCulturalContext(userId, userContext) {
        try {
          // Try cache first
          const cacheKey = `${config.redis.key_prefix}cultural_context:${userId}`;
          let cachedContext = await redis.get(cacheKey);
          
          if (cachedContext) {
            return JSON.parse(cachedContext);
          }

          // Fetch from Cultural Advisor Service
          const response = await axios.get(
            `${process.env.CULTURAL_ADVISOR_SERVICE_URL}/users/${userId}/cultural-context`,
            { timeout: 5000 }
          );

          const culturalContext = response.data;

          // Cache for 1 hour
          await redis.setex(cacheKey, 3600, JSON.stringify(culturalContext));

          return culturalContext;

        } catch (error) {
          console.error('Error getting user cultural context:', error);
          // Return safe defaults
          return {
            elderApprovedAccess: false,
            culturallyAuthorized: false,
            traditionalOwnerGroups: [],
            culturalSensitivityLevel: 'standard'
          };
        }
      }

      async updateRolloutPercentage(flagName, newPercentage, updatedBy, reason) {
        try {
          // Get current feature flag
          const flagResult = await db.query('SELECT * FROM feature_flags WHERE name = $1', [flagName]);
          
          if (flagResult.rows.length === 0) {
            throw new Error('Feature flag not found');
          }

          const featureFlag = flagResult.rows[0];
          const oldPercentage = featureFlag.rollout_percentage;

          // Cultural validation for rollout changes
          const culturalValidation = await this.culturalValidator.validateRolloutChange(
            featureFlag,
            oldPercentage,
            newPercentage
          );

          if (!culturalValidation.valid) {
            return {
              success: false,
              error: 'Cultural validation failed for rollout change',
              details: culturalValidation.issues
            };
          }

          // Update feature flag
          await db.query(`
            UPDATE feature_flags 
            SET rollout_percentage = $1, updated_at = CURRENT_TIMESTAMP
            WHERE id = $2
          `, [newPercentage, featureFlag.id]);

          // Log rollout event
          await db.query(`
            INSERT INTO rollout_events (
              feature_flag_id, event_type, previous_percentage, new_percentage,
              triggered_by, trigger_reason, cultural_check_passed
            ) VALUES ($1, $2, $3, $4, $5, $6, $7)
          `, [
            featureFlag.id,
            'percentage_update',
            oldPercentage,
            newPercentage,
            updatedBy,
            reason,
            true
          ]);

          // Clear cache
          await this.clearFeatureFlagCache(flagName);

          // Update metrics
          featureFlagExposure.labels(flagName, 'all').set(newPercentage);

          console.log(`Feature flag ${flagName} rollout updated: ${oldPercentage}% â†’ ${newPercentage}%`);

          return {
            success: true,
            previous_percentage: oldPercentage,
            new_percentage: newPercentage,
            cultural_validation: culturalValidation
          };

        } catch (error) {
          console.error('Error updating rollout percentage:', error);
          throw error;
        }
      }

      async emergencyRollback(flagName, rollbackReason, triggeredBy, isElderDecision = false) {
        try {
          console.log(`EMERGENCY ROLLBACK initiated for: ${flagName}`);
          console.log(`Reason: ${rollbackReason}`);
          console.log(`Triggered by: ${triggeredBy}`);
          console.log(`Elder Decision: ${isElderDecision}`);

          // Get feature flag
          const flagResult = await db.query('SELECT * FROM feature_flags WHERE name = $1', [flagName]);
          
          if (flagResult.rows.length === 0) {
            throw new Error('Feature flag not found');
          }

          const featureFlag = flagResult.rows[0];
          const previousPercentage = featureFlag.rollout_percentage;

          // Immediate disable
          await db.query(`
            UPDATE feature_flags 
            SET enabled = false, 
                rollout_percentage = 0, 
                emergency_disabled = true,
                disabled_reason = $1,
                updated_at = CURRENT_TIMESTAMP
            WHERE id = $2
          `, [rollbackReason, featureFlag.id]);

          // Log emergency rollback event
          await db.query(`
            INSERT INTO rollout_events (
              feature_flag_id, event_type, previous_percentage, new_percentage,
              triggered_by, trigger_reason, cultural_check_passed, event_metadata
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
          `, [
            featureFlag.id,
            'emergency_rollback',
            previousPercentage,
            0,
            triggeredBy,
            rollbackReason,
            true,
            JSON.stringify({
              elder_decision: isElderDecision,
              rollback_timestamp: new Date().toISOString()
            })
          ]);

          // Clear all caches immediately
          await this.clearAllFeatureFlagCaches(flagName);

          // Update metrics
          featureFlagExposure.labels(flagName, 'all').set(0);

          // Send notifications
          if (isElderDecision) {
            await this.notifyElderEmergencyRollback(flagName, rollbackReason, triggeredBy);
          } else {
            await this.notifyEmergencyRollback(flagName, rollbackReason, triggeredBy);
          }

          console.log(`Emergency rollback completed for: ${flagName}`);

          return {
            success: true,
            message: 'Emergency rollback completed',
            previous_percentage: previousPercentage,
            rollback_reason: rollbackReason,
            is_elder_decision: isElderDecision
          };

        } catch (error) {
          console.error('Error in emergency rollback:', error);
          throw error;
        }
      }

      async clearFeatureFlagCache(flagName) {
        const pattern = `${config.redis.key_prefix}${flagName}:*`;
        const keys = await redis.keys(pattern);
        
        if (keys.length > 0) {
          await redis.del(...keys);
        }
      }

      async clearAllFeatureFlagCaches(flagName) {
        // Clear user-specific caches
        await this.clearFeatureFlagCache(flagName);
        
        // Clear general cache
        await redis.del(`${config.redis.key_prefix}${flagName}`);
        
        console.log(`All caches cleared for feature flag: ${flagName}`);
      }

      async notifyElderEmergencyRollback(flagName, reason, triggeredBy) {
        try {
          const notification = {
            type: 'elder_emergency_rollback',
            feature_flag: flagName,
            reason: reason,
            triggered_by: triggeredBy,
            timestamp: new Date().toISOString(),
            priority: 'urgent'
          };

          // Notify Cultural Advisors and Admin Team
          await axios.post(`${process.env.CULTURAL_ADVISOR_SERVICE_URL}/notifications/emergency`, {
            ...notification,
            recipients: ['cultural_advisors', 'admin_team']
          });

          console.log(`Elder emergency rollback notifications sent for: ${flagName}`);

        } catch (error) {
          console.error('Error sending emergency rollback notifications:', error);
        }
      }
    }

    // Cultural Validation Service
    class CulturalValidator {
      async validateNewFlag(flagData) {
        const issues = [];

        // Check cultural classification
        if (!['sacred', 'sensitive', 'general'].includes(flagData.classification)) {
          issues.push('Invalid cultural classification');
        }

        // Validate cultural impact score
        if (flagData.cultural_impact_score < 1 || flagData.cultural_impact_score > 10) {
          issues.push('Cultural impact score must be between 1-10');
        }

        // Check for cultural keywords in name/description
        const culturalKeywords = ['sacred', 'elder', 'traditional', 'ceremony', 'cultural'];
        const flagText = `${flagData.name} ${flagData.description}`.toLowerCase();
        
        const containsCulturalContent = culturalKeywords.some(keyword => 
          flagText.includes(keyword)
        );

        if (containsCulturalContent && flagData.classification === 'general') {
          issues.push('Flag contains cultural content but is classified as general');
        }

        return {
          valid: issues.length === 0,
          issues: issues
        };
      }

      async assessCulturalImpact(featureFlag) {
        // Analyze cultural impact based on various factors
        const assessment = {
          risk_level: 'low',
          sacred_content_impact: false,
          traditional_knowledge_impact: false,
          community_consultation_required: false,
          elder_guidance_required: false,
          details: {}
        };

        // Determine risk level based on classification and impact score
        switch (featureFlag.classification) {
          case 'sacred':
            assessment.risk_level = 'critical';
            assessment.sacred_content_impact = true;
            assessment.elder_guidance_required = true;
            assessment.community_consultation_required = true;
            break;
            
          case 'sensitive':
            assessment.risk_level = 'high';
            assessment.traditional_knowledge_impact = true;
            assessment.community_consultation_required = true;
            break;
            
          case 'general':
            if (featureFlag.cultural_impact_score >= 7) {
              assessment.risk_level = 'medium';
              assessment.community_consultation_required = true;
            }
            break;
        }

        assessment.details = {
          classification: featureFlag.classification,
          impact_score: featureFlag.cultural_impact_score,
          assessment_timestamp: new Date().toISOString()
        };

        return assessment;
      }

      async validateRolloutChange(featureFlag, oldPercentage, newPercentage) {
        const issues = [];

        // Check rollout speed limits based on classification
        const controls = config.cultural_controls.classification_controls[featureFlag.classification];
        
        if (controls && controls.rollout_speed_limit === 'manual_only') {
          // Manual approval required for each change
          issues.push('Manual approval required for rollout changes on this classification');
        }

        // Check percentage increase limits
        const percentageIncrease = newPercentage - oldPercentage;
        const maxIncrease = this.getMaxPercentageIncrease(featureFlag.classification);

        if (percentageIncrease > maxIncrease) {
          issues.push(`Percentage increase too large: ${percentageIncrease}% (max: ${maxIncrease}%)`);
        }

        return {
          valid: issues.length === 0,
          issues: issues
        };
      }

      getMaxPercentageIncrease(classification) {
        switch (classification) {
          case 'sacred':
            return 5;   // 5% max increase
          case 'sensitive':
            return 15;  // 15% max increase
          case 'general':
            return 25;  // 25% max increase
          default:
            return 10;  // 10% default
        }
      }
    }

    // Rollout Management Service
    class RolloutManager {
      async checkUserInRollout(featureFlag, userId, userContext) {
        try {
          // Generate deterministic hash for consistent assignment
          const hash = this.generateUserHash(userId, featureFlag.name);
          const userPercentile = (hash % 100) / 100;

          // Check if user falls within rollout percentage
          const included = userPercentile <= (featureFlag.rollout_percentage / 100);

          // Apply cultural community prioritization
          if (this.isCulturalCommunityMember(userContext) && config.rollout.cultural_community_first) {
            // Cultural community members get priority access
            const culturalPriorityThreshold = Math.min(featureFlag.rollout_percentage * 1.2, 100) / 100;
            const culturalIncluded = userPercentile <= culturalPriorityThreshold;
            
            return {
              included: culturalIncluded,
              reason: culturalIncluded ? 'cultural_community_priority' : 'not_in_cultural_priority_rollout',
              user_percentile: userPercentile,
              rollout_threshold: culturalPriorityThreshold
            };
          }

          return {
            included: included,
            reason: included ? 'in_rollout' : 'not_in_rollout',
            user_percentile: userPercentile,
            rollout_threshold: featureFlag.rollout_percentage / 100
          };

        } catch (error) {
          console.error('Error checking user in rollout:', error);
          return {
            included: false,
            reason: 'rollout_check_error'
          };
        }
      }

      generateUserHash(userId, flagName) {
        const crypto = require('crypto');
        const hash = crypto.createHash('sha256');
        hash.update(userId + flagName + 'act_placemat_salt');
        return parseInt(hash.digest('hex').substring(0, 8), 16);
      }

      isCulturalCommunityMember(userContext) {
        return userContext.cultural_community_member === true ||
               userContext.indigenous_community_member === true ||
               userContext.cultural_advisor === true ||
               userContext.elder_council_member === true;
      }
    }

    // Approval Workflow Service
    class ApprovalWorkflow {
      async initiateApproval(featureFlagId, culturalControls) {
        try {
          console.log(`Initiating approval workflow for feature flag ID: ${featureFlagId}`);

          // Create elder approval request if required
          if (culturalControls.requires_elder_approval) {
            await db.query(`
              INSERT INTO cultural_approvals (
                feature_flag_id, approval_type, approver_type, 
                approver_id, status, created_at
              ) VALUES ($1, $2, $3, $4, $5, CURRENT_TIMESTAMP)
            `, [featureFlagId, 'elder_approval', 'elder_council', 'pending', 'pending']);

            // Notify Elder Council
            await this.notifyElderCouncil(featureFlagId);
          }

          // Create cultural advisor review if required
          if (culturalControls.requires_cultural_advisor_review) {
            await db.query(`
              INSERT INTO cultural_approvals (
                feature_flag_id, approval_type, approver_type,
                approver_id, status, created_at
              ) VALUES ($1, $2, $3, $4, $5, CURRENT_TIMESTAMP)
            `, [featureFlagId, 'cultural_advisor_review', 'cultural_advisor', 'pending', 'pending']);

            // Notify Cultural Advisors
            await this.notifyCulturalAdvisors(featureFlagId);
          }

          console.log(`Approval workflow initiated for feature flag ID: ${featureFlagId}`);

        } catch (error) {
          console.error('Error initiating approval workflow:', error);
          throw error;
        }
      }

      async notifyElderCouncil(featureFlagId) {
        try {
          // Get feature flag details
          const flagResult = await db.query('SELECT * FROM feature_flags WHERE id = $1', [featureFlagId]);
          const featureFlag = flagResult.rows[0];

          const notification = {
            type: 'elder_approval_request',
            feature_flag: {
              id: featureFlag.id,
              name: featureFlag.name,
              description: featureFlag.description,
              classification: featureFlag.classification,
              cultural_considerations: featureFlag.cultural_considerations
            },
            approval_required: 'elder_council',
            priority: featureFlag.classification === 'sacred' ? 'high' : 'normal'
          };

          await axios.post(`${process.env.ELDER_CONSULTATION_SERVICE_URL}/approval-requests`, notification);

          console.log(`Elder Council notified for feature flag: ${featureFlag.name}`);

        } catch (error) {
          console.error('Error notifying Elder Council:', error);
        }
      }

      async notifyCulturalAdvisors(featureFlagId) {
        try {
          // Get feature flag details
          const flagResult = await db.query('SELECT * FROM feature_flags WHERE id = $1', [featureFlagId]);
          const featureFlag = flagResult.rows[0];

          const notification = {
            type: 'cultural_advisor_review_request',
            feature_flag: {
              id: featureFlag.id,
              name: featureFlag.name,
              description: featureFlag.description,
              classification: featureFlag.classification,
              cultural_impact_score: featureFlag.cultural_impact_score
            },
            review_required: 'cultural_advisor'
          };

          await axios.post(`${process.env.CULTURAL_ADVISOR_SERVICE_URL}/review-requests`, notification);

          console.log(`Cultural Advisors notified for feature flag: ${featureFlag.name}`);

        } catch (error) {
          console.error('Error notifying Cultural Advisors:', error);
        }
      }
    }

    // Initialize service
    const featureFlagService = new FeatureFlagService();

    // JWT Authentication Middleware
    const authenticateToken = (req, res, next) => {
      const authHeader = req.headers['authorization'];
      const token = authHeader && authHeader.split(' ')[1];

      if (!token) {
        return res.sendStatus(401);
      }

      jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
        if (err) return res.sendStatus(403);
        req.user = user;
        next();
      });
    };

    // API Routes

    // Create new feature flag
    app.post('/flags', authenticateToken, async (req, res) => {
      try {
        const result = await featureFlagService.createFeatureFlag(req.body, req.user.id);
        
        if (result.success) {
          res.json(result);
        } else {
          res.status(400).json(result);
        }
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // Evaluate feature flag for user
    app.post('/evaluate/:flagName', authenticateToken, async (req, res) => {
      try {
        const { flagName } = req.params;
        const { userId, userContext } = req.body;

        const result = await featureFlagService.evaluateFeatureFlag(
          flagName, 
          userId || req.user.id, 
          userContext
        );
        
        res.json(result);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // Update rollout percentage
    app.put('/flags/:flagName/rollout', authenticateToken, async (req, res) => {
      try {
        const { flagName } = req.params;
        const { percentage, reason } = req.body;

        const result = await featureFlagService.updateRolloutPercentage(
          flagName,
          percentage,
          req.user.id,
          reason
        );

        if (result.success) {
          res.json(result);
        } else {
          res.status(400).json(result);
        }
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // Emergency rollback
    app.post('/flags/:flagName/emergency-rollback', authenticateToken, async (req, res) => {
      try {
        const { flagName } = req.params;
        const { reason, is_elder_decision } = req.body;

        const result = await featureFlagService.emergencyRollback(
          flagName,
          reason,
          req.user.id,
          is_elder_decision || false
        );

        res.json(result);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // Elder Council emergency rollback (special endpoint)
    app.post('/elder-emergency-rollback', async (req, res) => {
      try {
        // Special elder authorization check
        const elderToken = req.headers['authorization'];
        if (!elderToken || !elderToken.includes('elder-council')) {
          return res.status(403).json({ error: 'Elder Council authorization required' });
        }

        const { feature_name, rollback_reason, elder_authorization } = req.body;

        const result = await featureFlagService.emergencyRollback(
          feature_name,
          rollback_reason,
          elder_authorization,
          true  // Elder decision
        );

        res.json(result);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // Get feature flag details
    app.get('/flags/:flagName', authenticateToken, async (req, res) => {
      try {
        const { flagName } = req.params;
        
        const result = await db.query(`
          SELECT f.*, 
                 array_agg(ca.*) as approvals,
                 array_agg(cia.*) as assessments
          FROM feature_flags f
          LEFT JOIN cultural_approvals ca ON f.id = ca.feature_flag_id
          LEFT JOIN cultural_impact_assessments cia ON f.id = cia.feature_flag_id
          WHERE f.name = $1
          GROUP BY f.id
        `, [flagName]);

        if (result.rows.length === 0) {
          return res.status(404).json({ error: 'Feature flag not found' });
        }

        res.json(result.rows[0]);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // Health check endpoint
    app.get('/health', (req, res) => {
      res.json({ 
        status: 'healthy', 
        timestamp: new Date().toISOString(),
        service: 'feature-flag-service'
      });
    });

    // Readiness check endpoint
    app.get('/ready', async (req, res) => {
      try {
        await db.query('SELECT 1');
        await redis.ping();
        res.json({ status: 'ready' });
      } catch (error) {
        res.status(503).json({ status: 'not ready', error: error.message });
      }
    });

    // Metrics endpoint
    app.get('/metrics', (req, res) => {
      res.set('Content-Type', prometheus.register.contentType);
      res.end(prometheus.register.metrics());
    });

    // Initialize and start server
    async function start() {
      try {
        await featureFlagService.initializeDatabase();
        
        const port = config.server.port;
        app.listen(port, () => {
          console.log(`Feature Flag service running on port ${port}`);
          console.log('Cultural sensitivity controls enabled');
        });
      } catch (error) {
        console.error('Failed to start Feature Flag service:', error);
        process.exit(1);
      }
    }

    // Graceful shutdown
    process.on('SIGTERM', async () => {
      console.log('Shutting down gracefully...');
      process.exit(0);
    });

    start();

  package.json: |
    {
      "name": "act-placemat-feature-flag-service",
      "version": "1.0.0",
      "description": "Feature Flag Service with Cultural Sensitivity Controls for ACT Placemat",
      "main": "server.js",
      "dependencies": {
        "express": "^4.18.2",
        "pg": "^8.11.0",
        "ioredis": "^5.3.2",
        "js-yaml": "^4.1.0",
        "jsonwebtoken": "^9.0.0",
        "axios": "^1.4.0",
        "prom-client": "^14.2.0",
        "express-rate-limit": "^6.7.0"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    }