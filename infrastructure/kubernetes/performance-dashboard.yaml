# ACT Placemat Performance Dashboard with Cultural Sensitivity Metrics
# Real-time monitoring dashboard for performance and cultural compliance

---
# ========================================
# PERFORMANCE DASHBOARD UI
# ========================================

apiVersion: apps/v1
kind: Deployment
metadata:
  name: performance-dashboard
  namespace: act-production
  labels:
    app: performance-dashboard
    component: monitoring
spec:
  replicas: 2
  selector:
    matchLabels:
      app: performance-dashboard
  template:
    metadata:
      labels:
        app: performance-dashboard
        component: monitoring
    spec:
      containers:
      - name: dashboard-ui
        image: node:18-alpine
        ports:
        - containerPort: 3000
          name: http
        env:
        - name: NODE_ENV
          value: "production"
        - name: PROFILING_API_URL
          value: "http://performance-profiling-service:8080"
        - name: PROMETHEUS_URL
          value: "http://prometheus:9090"
        - name: JAEGER_URL
          value: "http://jaeger-query:16686"
        volumeMounts:
        - name: dashboard-config
          mountPath: /app/config
        - name: dashboard-source
          mountPath: /app
        command: ["npm", "start"]
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "300m"
      volumes:
      - name: dashboard-config
        configMap:
          name: dashboard-config
      - name: dashboard-source
        configMap:
          name: dashboard-source-code

---
apiVersion: v1
kind: Service
metadata:
  name: performance-dashboard
  namespace: act-production
  labels:
    app: performance-dashboard
spec:
  selector:
    app: performance-dashboard
  ports:
  - name: http
    port: 3000
    targetPort: 3000
  type: ClusterIP

---
# ========================================
# LOAD TESTING SERVICE
# ========================================

apiVersion: apps/v1
kind: Deployment
metadata:
  name: load-testing-service
  namespace: act-production
  labels:
    app: load-testing-service
    component: testing
spec:
  replicas: 1
  selector:
    matchLabels:
      app: load-testing-service
  template:
    metadata:
      labels:
        app: load-testing-service
        component: testing
    spec:
      containers:
      - name: load-tester
        image: node:18-alpine
        ports:
        - containerPort: 8080
          name: http
        env:
        - name: NODE_ENV
          value: "production"
        - name: TARGET_BASE_URL
          value: "http://act-placemat-api:8080"
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-secrets
              key: redis-url
        volumeMounts:
        - name: load-testing-config
          mountPath: /app/config
        - name: load-testing-source
          mountPath: /app
        command: ["node", "server.js"]
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
      volumes:
      - name: load-testing-config
        configMap:
          name: load-testing-config
      - name: load-testing-source
        configMap:
          name: load-testing-source-code

---
apiVersion: v1
kind: Service
metadata:
  name: load-testing-service
  namespace: act-production
  labels:
    app: load-testing-service
spec:
  selector:
    app: load-testing-service
  ports:
  - name: http
    port: 8080
    targetPort: 8080
  type: ClusterIP

---
# ========================================
# DASHBOARD CONFIGURATION
# ========================================

apiVersion: v1
kind: ConfigMap
metadata:
  name: dashboard-config
  namespace: act-production
data:
  config.json: |
    {
      "app": {
        "name": "ACT Placemat Performance Dashboard",
        "version": "1.0.0",
        "environment": "production"
      },
      "api": {
        "profiling_service": "http://performance-profiling-service:8080",
        "prometheus": "http://prometheus:9090",
        "jaeger": "http://jaeger-query:16686"
      },
      "dashboard": {
        "refresh_interval": 5000,
        "data_retention": 86400000,
        "cultural_metrics": true,
        "real_time_updates": true
      },
      "cultural": {
        "show_indigenous_metrics": true,
        "elder_consultation_tracking": true,
        "sacred_content_monitoring": true,
        "community_impact_visibility": true
      },
      "alerts": {
        "enabled": true,
        "cultural_sla_breach": true,
        "performance_degradation": true,
        "elder_consultation_overdue": true
      }
    }

---
# ========================================
# LOAD TESTING CONFIGURATION
# ========================================

apiVersion: v1
kind: ConfigMap
metadata:
  name: load-testing-config
  namespace: act-production
data:
  config.yaml: |
    # Load Testing Configuration
    
    server:
      port: 8080
      environment: production
      
    testing:
      default_duration: 600  # 10 minutes
      ramp_up_time: 60  # 1 minute
      max_virtual_users: 500
      think_time: 1000  # 1 second
      
    scenarios:
      normal_load:
        virtual_users: 50
        duration: 300  # 5 minutes
        endpoints:
          - path: "/api/health"
            method: "GET"
            weight: 10
          - path: "/api/communities"
            method: "GET"
            weight: 20
          - path: "/api/stories"
            method: "GET"
            weight: 30
          - path: "/api/opportunities"
            method: "GET"
            weight: 25
          - path: "/api/users/profile"
            method: "GET"
            weight: 15
            
      cultural_content_load:
        virtual_users: 20
        duration: 600  # 10 minutes
        cultural_context: true
        endpoints:
          - path: "/api/cultural/reviews"
            method: "GET"
            weight: 30
          - path: "/api/stories/cultural"
            method: "GET"
            weight: 40
          - path: "/api/elder/consultations"
            method: "GET"
            weight: 20
          - path: "/api/indigenous/data"
            method: "GET"
            weight: 10
            
      peak_traffic:
        virtual_users: 200
        duration: 180  # 3 minutes
        ramp_up: 30  # 30 seconds
        endpoints:
          - path: "/api/communities"
            method: "GET"
            weight: 40
          - path: "/api/stories"
            method: "GET"
            weight: 35
          - path: "/api/opportunities/search"
            method: "POST"
            weight: 25
            
      elder_consultation_stress:
        virtual_users: 5  # Low volume but high importance
        duration: 1800  # 30 minutes
        cultural_sensitivity: "high"
        endpoints:
          - path: "/api/elder/consultation/request"
            method: "POST"
            weight: 50
          - path: "/api/cultural/review/sacred"
            method: "POST"
            weight: 30
          - path: "/api/indigenous/data/access"
            method: "GET"
            weight: 20
            
    # Cultural Protection During Testing
    cultural_protection:
      max_indigenous_community_impact: 0.01  # 1% during testing
      exclude_sacred_content: true
      elder_notification_required: true
      community_consent_bypass: false
      test_data_only: true
      
    # Monitoring During Tests
    monitoring:
      collect_metrics: true
      cultural_impact_tracking: true
      real_time_alerts: true
      performance_degradation_threshold: 50  # 50% degradation triggers alert
      
    # Reporting
    reporting:
      generate_cultural_impact_report: true
      performance_baseline_comparison: true
      bottleneck_identification: true
      capacity_recommendations: true

---
# ========================================
# DASHBOARD SOURCE CODE
# ========================================

apiVersion: v1
kind: ConfigMap
metadata:
  name: dashboard-source-code
  namespace: act-production
data:
  package.json: |
    {
      "name": "act-placemat-performance-dashboard",
      "version": "1.0.0",
      "description": "Performance Dashboard with Cultural Sensitivity Metrics",
      "main": "server.js",
      "scripts": {
        "start": "node server.js",
        "dev": "nodemon server.js"
      },
      "dependencies": {
        "express": "^4.18.2",
        "next": "^13.4.0",
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "socket.io": "^4.7.0",
        "socket.io-client": "^4.7.0",
        "axios": "^1.4.0",
        "recharts": "^2.6.2",
        "styled-components": "^6.0.0",
        "date-fns": "^2.30.0",
        "lodash": "^4.17.21"
      }
    }

  server.js: |
    const express = require('express');
    const next = require('next');
    const http = require('http');
    const socketIo = require('socket.io');
    const axios = require('axios');
    const fs = require('fs');

    const dev = process.env.NODE_ENV !== 'production';
    const nextApp = next({ dev, dir: '/app/ui' });
    const handle = nextApp.getRequestHandler();

    // Load configuration
    const config = JSON.parse(fs.readFileSync('/app/config/config.json', 'utf8'));

    nextApp.prepare().then(() => {
      const app = express();
      const server = http.createServer(app);
      const io = socketIo(server, {
        cors: {
          origin: "*",
          methods: ["GET", "POST"]
        }
      });

      app.use(express.json());

      // Real-time metrics collection and broadcasting
      const metricsCollector = {
        intervals: new Map(),
        
        start() {
          // Collect performance metrics every 5 seconds
          this.intervals.set('performance', setInterval(async () => {
            try {
              const metrics = await this.collectPerformanceMetrics();
              io.emit('performance_metrics', metrics);
            } catch (error) {
              console.error('Failed to collect performance metrics:', error);
            }
          }, 5000));

          // Collect cultural metrics every 10 seconds
          this.intervals.set('cultural', setInterval(async () => {
            try {
              const metrics = await this.collectCulturalMetrics();
              io.emit('cultural_metrics', metrics);
            } catch (error) {
              console.error('Failed to collect cultural metrics:', error);
            }
          }, 10000));

          // Collect bottleneck data every 30 seconds
          this.intervals.set('bottlenecks', setInterval(async () => {
            try {
              const bottlenecks = await this.collectBottlenecks();
              io.emit('bottleneck_updates', bottlenecks);
            } catch (error) {
              console.error('Failed to collect bottlenecks:', error);
            }
          }, 30000));
        },

        stop() {
          this.intervals.forEach(interval => clearInterval(interval));
          this.intervals.clear();
        },

        async collectPerformanceMetrics() {
          const response = await axios.get(`${config.api.profiling_service}/dashboard`);
          return {
            timestamp: new Date().toISOString(),
            ...response.data
          };
        },

        async collectCulturalMetrics() {
          const response = await axios.get(`${config.api.profiling_service}/cultural-metrics`);
          return {
            timestamp: new Date().toISOString(),
            elderConsultations: response.data.elderConsultations || {},
            culturalReviews: response.data.culturalReviews || {},
            indigenousDataAccess: response.data.indigenousDataAccess || {},
            communityImpact: response.data.communityImpact || {}
          };
        },

        async collectBottlenecks() {
          const response = await axios.get(`${config.api.profiling_service}/bottlenecks`);
          return {
            timestamp: new Date().toISOString(),
            bottlenecks: response.data.bottlenecks || []
          };
        }
      };

      // Socket.io connection handling
      io.on('connection', (socket) => {
        console.log('Dashboard client connected:', socket.id);
        
        socket.on('disconnect', () => {
          console.log('Dashboard client disconnected:', socket.id);
        });
        
        socket.on('request_initial_data', async () => {
          try {
            const [performance, cultural, bottlenecks] = await Promise.all([
              metricsCollector.collectPerformanceMetrics(),
              metricsCollector.collectCulturalMetrics(),
              metricsCollector.collectBottlenecks()
            ]);
            
            socket.emit('initial_data', {
              performance,
              cultural,
              bottlenecks
            });
          } catch (error) {
            socket.emit('error', { message: 'Failed to load initial data' });
          }
        });
      });

      // API routes
      app.get('/api/metrics/performance', async (req, res) => {
        try {
          const metrics = await metricsCollector.collectPerformanceMetrics();
          res.json(metrics);
        } catch (error) {
          res.status(500).json({ error: error.message });
        }
      });

      app.get('/api/metrics/cultural', async (req, res) => {
        try {
          const metrics = await metricsCollector.collectCulturalMetrics();
          res.json(metrics);
        } catch (error) {
          res.status(500).json({ error: error.message });
        }
      });

      app.get('/api/bottlenecks', async (req, res) => {
        try {
          const bottlenecks = await metricsCollector.collectBottlenecks();
          res.json(bottlenecks);
        } catch (error) {
          res.status(500).json({ error: error.message });
        }
      });

      // Handle all other routes with Next.js
      app.all('*', (req, res) => {
        return handle(req, res);
      });

      // Start metrics collection
      metricsCollector.start();

      // Graceful shutdown
      process.on('SIGTERM', () => {
        console.log('Shutting down gracefully...');
        metricsCollector.stop();
        server.close();
      });

      const port = 3000;
      server.listen(port, () => {
        console.log(`Performance Dashboard ready on http://localhost:${port}`);
      });
    });

  ui/pages/index.js: |
    import React, { useState, useEffect } from 'react';
    import io from 'socket.io-client';
    import styled from 'styled-components';
    import { LineChart, Line, AreaChart, Area, BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
    import { format } from 'date-fns';

    const DashboardContainer = styled.div`
      min-height: 100vh;
      background: #f8fafc;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    `;

    const Header = styled.header`
      background: white;
      border-bottom: 1px solid #e2e8f0;
      padding: 1rem 2rem;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    `;

    const Title = styled.h1`
      margin: 0;
      color: #1a202c;
      font-size: 1.5rem;
      font-weight: 600;
    `;

    const Subtitle = styled.p`
      margin: 0.5rem 0 0;
      color: #718096;
      font-size: 0.9rem;
    `;

    const MainContent = styled.main`
      padding: 2rem;
      max-width: 1400px;
      margin: 0 auto;
    `;

    const MetricsGrid = styled.div`
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    `;

    const MetricCard = styled.div`
      background: white;
      border-radius: 8px;
      padding: 1.5rem;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      border-left: 4px solid ${props => props.borderColor || '#667eea'};
    `;

    const MetricTitle = styled.h3`
      margin: 0 0 1rem;
      color: #2d3748;
      font-size: 0.9rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    `;

    const MetricValue = styled.div`
      font-size: 2rem;
      font-weight: 700;
      color: ${props => props.color || '#2d3748'};
      margin-bottom: 0.5rem;
    `;

    const MetricSubtext = styled.div`
      font-size: 0.875rem;
      color: #718096;
    `;

    const ChartSection = styled.div`
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 2rem;
      margin-bottom: 2rem;
    `;

    const ChartCard = styled.div`
      background: white;
      border-radius: 8px;
      padding: 1.5rem;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    `;

    const ChartTitle = styled.h4`
      margin: 0 0 1rem;
      color: #2d3748;
      font-size: 1rem;
      font-weight: 600;
    `;

    const AlertPanel = styled.div`
      background: ${props => props.type === 'critical' ? '#fed7d7' : props.type === 'warning' ? '#feebc8' : '#c6f6d5'};
      border: 1px solid ${props => props.type === 'critical' ? '#fc8181' : props.type === 'warning' ? '#f6ad55' : '#68d391'};
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
      color: ${props => props.type === 'critical' ? '#742a2a' : props.type === 'warning' ? '#7b341e' : '#22543d'};
    `;

    const BottleneckList = styled.div`
      max-height: 400px;
      overflow-y: auto;
    `;

    const BottleneckItem = styled.div`
      padding: 0.75rem;
      border-bottom: 1px solid #e2e8f0;
      
      &:last-child {
        border-bottom: none;
      }
    `;

    const BottleneckType = styled.div`
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 0.25rem;
    `;

    const BottleneckDescription = styled.div`
      font-size: 0.875rem;
      color: #4a5568;
      margin-bottom: 0.25rem;
    `;

    const BottleneckMeta = styled.div`
      font-size: 0.75rem;
      color: #718096;
    `;

    const StatusIndicator = styled.div`
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: ${props => 
        props.status === 'healthy' ? '#48bb78' :
        props.status === 'warning' ? '#ed8936' :
        '#f56565'
      };
      margin-right: 0.5rem;
    `;

    export default function PerformanceDashboard() {
      const [socket, setSocket] = useState(null);
      const [performanceMetrics, setPerformanceMetrics] = useState({});
      const [culturalMetrics, setCulturalMetrics] = useState({});
      const [bottlenecks, setBottlenecks] = useState([]);
      const [performanceHistory, setPerformanceHistory] = useState([]);
      const [connectionStatus, setConnectionStatus] = useState('disconnected');

      useEffect(() => {
        const newSocket = io();
        setSocket(newSocket);

        newSocket.on('connect', () => {
          console.log('Connected to dashboard server');
          setConnectionStatus('connected');
          newSocket.emit('request_initial_data');
        });

        newSocket.on('disconnect', () => {
          console.log('Disconnected from dashboard server');
          setConnectionStatus('disconnected');
        });

        newSocket.on('initial_data', (data) => {
          setPerformanceMetrics(data.performance);
          setCulturalMetrics(data.cultural);
          setBottlenecks(data.bottlenecks.bottlenecks || []);
        });

        newSocket.on('performance_metrics', (metrics) => {
          setPerformanceMetrics(metrics);
          setPerformanceHistory(prev => {
            const updated = [...prev, {
              timestamp: metrics.timestamp,
              cpu: metrics.cpu?.usage || 0,
              memory: metrics.memory?.heapUsed || 0,
              requests: metrics.requests?.total || 0
            }];
            // Keep only last 50 data points
            return updated.slice(-50);
          });
        });

        newSocket.on('cultural_metrics', (metrics) => {
          setCulturalMetrics(metrics);
        });

        newSocket.on('bottleneck_updates', (data) => {
          setBottlenecks(data.bottlenecks || []);
        });

        return () => {
          newSocket.close();
        };
      }, []);

      const getSystemHealthStatus = () => {
        if (bottlenecks.length === 0) return 'healthy';
        const criticalBottlenecks = bottlenecks.filter(b => b.severity === 'critical');
        if (criticalBottlenecks.length > 0) return 'critical';
        const highBottlenecks = bottlenecks.filter(b => b.severity === 'high');
        if (highBottlenecks.length > 0) return 'warning';
        return 'warning';
      };

      const getCulturalComplianceStatus = () => {
        const overdueConsultations = culturalMetrics.elderConsultations?.overdue || 0;
        const pendingReviews = culturalMetrics.culturalReviews?.pending || 0;
        
        if (overdueConsultations > 0) return 'critical';
        if (pendingReviews > 10) return 'warning';
        return 'healthy';
      };

      return (
        <DashboardContainer>
          <Header>
            <Title>
              <StatusIndicator status={connectionStatus === 'connected' ? 'healthy' : 'critical'} />
              ACT Placemat Performance Dashboard
            </Title>
            <Subtitle>
              Real-time monitoring with cultural sensitivity tracking
            </Subtitle>
          </Header>

          <MainContent>
            {/* System Health Alerts */}
            {bottlenecks.filter(b => b.severity === 'critical').map(bottleneck => (
              <AlertPanel key={bottleneck.id} type="critical">
                <strong>Critical Bottleneck:</strong> {bottleneck.description}
                {bottleneck.cultural_impact?.impactLevel === 'critical' && (
                  <div style={{ marginTop: '0.5rem' }}>
                    <strong>Cultural Impact:</strong> This issue may affect Elder consultations or Indigenous data access.
                  </div>
                )}
              </AlertPanel>
            ))}

            {culturalMetrics.elderConsultations?.overdue > 0 && (
              <AlertPanel type="critical">
                <strong>Elder Consultation SLA Breach:</strong> {culturalMetrics.elderConsultations.overdue} consultations are overdue.
                Sacred knowledge processes may be impacted.
              </AlertPanel>
            )}

            {/* Key Metrics */}
            <MetricsGrid>
              <MetricCard borderColor="#48bb78">
                <MetricTitle>System Health</MetricTitle>
                <MetricValue color={
                  getSystemHealthStatus() === 'healthy' ? '#48bb78' :
                  getSystemHealthStatus() === 'warning' ? '#ed8936' :
                  '#f56565'
                }>
                  {getSystemHealthStatus() === 'healthy' ? 'Healthy' :
                   getSystemHealthStatus() === 'warning' ? 'Warning' : 'Critical'}
                </MetricValue>
                <MetricSubtext>
                  {bottlenecks.length} active bottlenecks
                </MetricSubtext>
              </MetricCard>

              <MetricCard borderColor="#667eea">
                <MetricTitle>Cultural Compliance</MetricTitle>
                <MetricValue color={
                  getCulturalComplianceStatus() === 'healthy' ? '#48bb78' :
                  getCulturalComplianceStatus() === 'warning' ? '#ed8936' :
                  '#f56565'
                }>
                  {getCulturalComplianceStatus() === 'healthy' ? 'Compliant' :
                   getCulturalComplianceStatus() === 'warning' ? 'Attention' : 'Breach'}
                </MetricValue>
                <MetricSubtext>
                  Elder consultations: {culturalMetrics.elderConsultations?.active || 0} active
                </MetricSubtext>
              </MetricCard>

              <MetricCard borderColor="#ed8936">
                <MetricTitle>Response Time P95</MetricTitle>
                <MetricValue>
                  {performanceMetrics.responseTime?.p95 || 0}ms
                </MetricValue>
                <MetricSubtext>
                  Target: &lt; 2000ms
                </MetricSubtext>
              </MetricCard>

              <MetricCard borderColor="#38b2ac">
                <MetricTitle>Indigenous Data Access</MetricTitle>
                <MetricValue>
                  {culturalMetrics.indigenousDataAccess?.avgAccessTime || 0}ms
                </MetricValue>
                <MetricSubtext>
                  {culturalMetrics.indigenousDataAccess?.accessCount || 0} accesses today
                </MetricSubtext>
              </MetricCard>

              <MetricCard borderColor="#9f7aea">
                <MetricTitle>Community Load Balance</MetricTitle>
                <MetricValue>
                  {performanceMetrics.communityBalance?.efficiency || 100}%
                </MetricValue>
                <MetricSubtext>
                  Balanced across {performanceMetrics.communityBalance?.activeRegions || 0} regions
                </MetricSubtext>
              </MetricCard>

              <MetricCard borderColor="#f093fb">
                <MetricTitle>Elder Consultation SLA</MetricTitle>
                <MetricValue color={
                  (culturalMetrics.elderConsultations?.slaCompliance || 100) >= 95 ? '#48bb78' :
                  (culturalMetrics.elderConsultations?.slaCompliance || 100) >= 80 ? '#ed8936' :
                  '#f56565'
                }>
                  {culturalMetrics.elderConsultations?.slaCompliance || 100}%
                </MetricValue>
                <MetricSubtext>
                  24-hour SLA compliance rate
                </MetricSubtext>
              </MetricCard>
            </MetricsGrid>

            {/* Charts Section */}
            <ChartSection>
              <ChartCard>
                <ChartTitle>Performance Trends</ChartTitle>
                <ResponsiveContainer width="100%" height={300}>
                  <LineChart data={performanceHistory}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis 
                      dataKey="timestamp" 
                      tickFormatter={(timestamp) => format(new Date(timestamp), 'HH:mm')}
                    />
                    <YAxis />
                    <Tooltip 
                      labelFormatter={(timestamp) => format(new Date(timestamp), 'MMM d, HH:mm:ss')}
                    />
                    <Legend />
                    <Line type="monotone" dataKey="cpu" stroke="#f56565" name="CPU %" strokeWidth={2} />
                    <Line type="monotone" dataKey="memory" stroke="#48bb78" name="Memory (MB)" strokeWidth={2} />
                    <Line type="monotone" dataKey="requests" stroke="#667eea" name="Requests/min" strokeWidth={2} />
                  </LineChart>
                </ResponsiveContainer>
              </ChartCard>

              <ChartCard>
                <ChartTitle>Active Bottlenecks</ChartTitle>
                <BottleneckList>
                  {bottlenecks.length === 0 ? (
                    <div style={{ textAlign: 'center', color: '#718096', padding: '2rem' }}>
                      <div style={{ fontSize: '2rem', marginBottom: '0.5rem' }}>ðŸŒŸ</div>
                      <div>No active bottlenecks detected!</div>
                      <div style={{ fontSize: '0.875rem', marginTop: '0.25rem' }}>
                        System is performing optimally
                      </div>
                    </div>
                  ) : (
                    bottlenecks.map(bottleneck => (
                      <BottleneckItem key={bottleneck.id}>
                        <BottleneckType>
                          <StatusIndicator status={
                            bottleneck.severity === 'critical' ? 'critical' :
                            bottleneck.severity === 'high' ? 'warning' :
                            'healthy'
                          } />
                          {bottleneck.bottleneck_type.replace(/_/g, ' ').toUpperCase()}
                        </BottleneckType>
                        <BottleneckDescription>
                          {bottleneck.description}
                        </BottleneckDescription>
                        <BottleneckMeta>
                          {bottleneck.component} â€¢ {format(new Date(bottleneck.created_at), 'MMM d, HH:mm')}
                          {bottleneck.cultural_impact?.impactLevel === 'high' && (
                            <span style={{ marginLeft: '0.5rem', color: '#d53f8c' }}>â€¢ Cultural Impact</span>
                          )}
                        </BottleneckMeta>
                      </BottleneckItem>
                    ))
                  )}
                </BottleneckList>
              </ChartCard>
            </ChartSection>

            {/* Cultural Metrics Section */}
            <ChartSection>
              <ChartCard>
                <ChartTitle>Cultural Review Process Health</ChartTitle>
                <ResponsiveContainer width="100%" height={250}>
                  <BarChart data={[
                    {
                      name: 'Reviews',
                      pending: culturalMetrics.culturalReviews?.pending || 0,
                      approved: culturalMetrics.culturalReviews?.approved || 0,
                      elder_review: culturalMetrics.culturalReviews?.elderReview || 0
                    }
                  ]}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="name" />
                    <YAxis />
                    <Tooltip />
                    <Legend />
                    <Bar dataKey="pending" fill="#ed8936" name="Pending" />
                    <Bar dataKey="approved" fill="#48bb78" name="Approved" />
                    <Bar dataKey="elder_review" fill="#9f7aea" name="Elder Review" />
                  </BarChart>
                </ResponsiveContainer>
              </ChartCard>

              <ChartCard>
                <ChartTitle>Community Impact Distribution</ChartTitle>
                <div style={{ padding: '1rem 0' }}>
                  <div style={{ marginBottom: '1rem' }}>
                    <div style={{ 
                      display: 'flex', 
                      justifyContent: 'space-between', 
                      alignItems: 'center',
                      marginBottom: '0.5rem'
                    }}>
                      <span>Indigenous Communities</span>
                      <span>{culturalMetrics.communityImpact?.indigenous || '0%'}</span>
                    </div>
                    <div style={{ 
                      width: '100%', 
                      height: '8px', 
                      backgroundColor: '#e2e8f0', 
                      borderRadius: '4px',
                      overflow: 'hidden'
                    }}>
                      <div style={{ 
                        width: culturalMetrics.communityImpact?.indigenous || '0%',
                        height: '100%', 
                        backgroundColor: '#9f7aea',
                        transition: 'width 0.3s ease'
                      }} />
                    </div>
                  </div>

                  <div style={{ marginBottom: '1rem' }}>
                    <div style={{ 
                      display: 'flex', 
                      justifyContent: 'space-between', 
                      alignItems: 'center',
                      marginBottom: '0.5rem'
                    }}>
                      <span>Mixed Communities</span>
                      <span>{culturalMetrics.communityImpact?.mixed || '0%'}</span>
                    </div>
                    <div style={{ 
                      width: '100%', 
                      height: '8px', 
                      backgroundColor: '#e2e8f0', 
                      borderRadius: '4px',
                      overflow: 'hidden'
                    }}>
                      <div style={{ 
                        width: culturalMetrics.communityImpact?.mixed || '0%',
                        height: '100%', 
                        backgroundColor: '#38b2ac',
                        transition: 'width 0.3s ease'
                      }} />
                    </div>
                  </div>

                  <div>
                    <div style={{ 
                      display: 'flex', 
                      justifyContent: 'space-between', 
                      alignItems: 'center',
                      marginBottom: '0.5rem'
                    }}>
                      <span>General Communities</span>
                      <span>{culturalMetrics.communityImpact?.general || '0%'}</span>
                    </div>
                    <div style={{ 
                      width: '100%', 
                      height: '8px', 
                      backgroundColor: '#e2e8f0', 
                      borderRadius: '4px',
                      overflow: 'hidden'
                    }}>
                      <div style={{ 
                        width: culturalMetrics.communityImpact?.general || '0%',
                        height: '100%', 
                        backgroundColor: '#48bb78',
                        transition: 'width 0.3s ease'
                      }} />
                    </div>
                  </div>
                </div>
              </ChartCard>
            </ChartSection>
          </MainContent>
        </DashboardContainer>
      );
    }

---
# ========================================
# LOAD TESTING SOURCE CODE
# ========================================

apiVersion: v1
kind: ConfigMap
metadata:
  name: load-testing-source-code
  namespace: act-production
data:
  server.js: |
    const express = require('express');
    const Redis = require('ioredis');
    const yaml = require('js-yaml');
    const fs = require('fs');
    const axios = require('axios');
    const cluster = require('cluster');
    const numCPUs = require('os').cpus().length;

    // Load configuration
    const config = yaml.load(fs.readFileSync('/app/config/config.yaml', 'utf8'));

    const app = express();
    app.use(express.json());

    // Initialize Redis for coordination
    const redis = new Redis(process.env.REDIS_URL);

    class LoadTestingService {
      constructor() {
        this.activeTests = new Map();
        this.testResults = new Map();
        this.culturalProtections = config.cultural_protection;
      }

      async runLoadTest(scenarioName, customConfig = {}) {
        const scenario = config.scenarios[scenarioName];
        if (!scenario) {
          throw new Error(`Scenario '${scenarioName}' not found`);
        }

        // Merge scenario config with custom overrides
        const testConfig = { ...scenario, ...customConfig };
        
        // Cultural protection check
        if (scenario.cultural_context || scenario.cultural_sensitivity === 'high') {
          const approval = await this.checkCulturalApproval(scenario);
          if (!approval.approved) {
            throw new Error(`Cultural protection: ${approval.reason}`);
          }
        }

        const testId = this.generateTestId();
        
        // Initialize test state
        this.activeTests.set(testId, {
          scenario: scenarioName,
          config: testConfig,
          startTime: new Date(),
          status: 'running',
          virtualUsers: [],
          metrics: {
            totalRequests: 0,
            successfulRequests: 0,
            failedRequests: 0,
            responseTimes: [],
            errors: []
          },
          culturalImpact: {
            indigenousCommunityRequests: 0,
            sacredContentAccess: 0,
            elderConsultationTriggers: 0
          }
        });

        // Start the load test
        await this.executeLoadTest(testId, testConfig);
        
        return testId;
      }

      async executeLoadTest(testId, testConfig) {
        const test = this.activeTests.get(testId);
        const baseUrl = process.env.TARGET_BASE_URL;
        
        // Ramp-up phase
        const rampUpInterval = (testConfig.ramp_up || 60) * 1000 / testConfig.virtual_users;
        
        for (let i = 0; i < testConfig.virtual_users; i++) {
          setTimeout(() => {
            this.startVirtualUser(testId, i, testConfig, baseUrl);
          }, i * rampUpInterval);
        }

        // Set test duration timeout
        setTimeout(() => {
          this.stopLoadTest(testId);
        }, testConfig.duration * 1000);
      }

      async startVirtualUser(testId, userId, testConfig, baseUrl) {
        const test = this.activeTests.get(testId);
        if (!test || test.status !== 'running') return;

        const virtualUser = {
          id: userId,
          status: 'active',
          requestCount: 0,
          startTime: new Date()
        };

        test.virtualUsers.push(virtualUser);

        // Virtual user request loop
        const makeRequest = async () => {
          if (!this.activeTests.has(testId) || this.activeTests.get(testId).status !== 'running') {
            return;
          }

          try {
            const endpoint = this.selectEndpoint(testConfig.endpoints);
            const startTime = Date.now();
            
            // Add cultural context headers if needed
            const headers = {
              'Content-Type': 'application/json'
            };
            
            if (testConfig.cultural_context) {
              headers['Cultural-Context'] = testConfig.cultural_sensitivity || 'medium';
            }

            // Make request
            const response = await axios({
              method: endpoint.method,
              url: `${baseUrl}${endpoint.path}`,
              headers,
              timeout: 30000
            });

            const responseTime = Date.now() - startTime;
            
            // Record metrics
            test.metrics.totalRequests++;
            test.metrics.successfulRequests++;
            test.metrics.responseTimes.push(responseTime);
            virtualUser.requestCount++;

            // Track cultural impact
            if (endpoint.path.includes('cultural') || endpoint.path.includes('indigenous')) {
              test.culturalImpact.indigenousCommunityRequests++;
            }
            if (endpoint.path.includes('sacred') || endpoint.path.includes('elder')) {
              test.culturalImpact.sacredContentAccess++;
            }

            console.log(`VU${userId}: ${response.status} ${endpoint.method} ${endpoint.path} - ${responseTime}ms`);

          } catch (error) {
            test.metrics.totalRequests++;
            test.metrics.failedRequests++;
            test.metrics.errors.push({
              timestamp: new Date(),
              error: error.message,
              endpoint: endpoint?.path || 'unknown'
            });
            
            console.error(`VU${userId} Error:`, error.message);
          }

          // Think time before next request
          const thinkTime = testConfig.think_time || 1000;
          setTimeout(makeRequest, thinkTime + Math.random() * thinkTime * 0.5); // Add 0-50% jitter
        };

        // Start making requests
        makeRequest();
      }

      selectEndpoint(endpoints) {
        const totalWeight = endpoints.reduce((sum, ep) => sum + ep.weight, 0);
        let random = Math.random() * totalWeight;
        
        for (const endpoint of endpoints) {
          random -= endpoint.weight;
          if (random <= 0) {
            return endpoint;
          }
        }
        
        return endpoints[0]; // Fallback
      }

      async checkCulturalApproval(scenario) {
        // Check if cultural content testing is approved
        if (scenario.cultural_sensitivity === 'high') {
          // In production, this would check with Cultural Advisors
          return {
            approved: true,
            reason: 'High cultural sensitivity testing approved for limited scope'
          };
        }

        if (scenario.cultural_context && !this.culturalProtections.test_data_only) {
          return {
            approved: false,
            reason: 'Cultural content testing requires test data isolation'
          };
        }

        return { approved: true };
      }

      stopLoadTest(testId) {
        const test = this.activeTests.get(testId);
        if (!test) return;

        test.status = 'completed';
        test.endTime = new Date();
        
        // Calculate final metrics
        const results = this.calculateResults(test);
        this.testResults.set(testId, results);

        console.log(`Load test ${testId} completed:`, results.summary);
        
        // Store results in Redis for persistence
        redis.setex(`load_test_results:${testId}`, 86400, JSON.stringify(results));
      }

      calculateResults(test) {
        const responseTimes = test.metrics.responseTimes.sort((a, b) => a - b);
        const duration = (test.endTime - test.startTime) / 1000; // seconds

        const results = {
          testId: test.testId,
          scenario: test.scenario,
          duration: duration,
          summary: {
            totalRequests: test.metrics.totalRequests,
            successfulRequests: test.metrics.successfulRequests,
            failedRequests: test.metrics.failedRequests,
            requestRate: test.metrics.totalRequests / duration,
            errorRate: test.metrics.failedRequests / test.metrics.totalRequests
          },
          responseTimes: {
            min: responseTimes[0] || 0,
            max: responseTimes[responseTimes.length - 1] || 0,
            avg: responseTimes.reduce((sum, rt) => sum + rt, 0) / responseTimes.length || 0,
            p50: this.percentile(responseTimes, 0.5),
            p95: this.percentile(responseTimes, 0.95),
            p99: this.percentile(responseTimes, 0.99)
          },
          culturalImpact: test.culturalImpact,
          errors: test.metrics.errors,
          recommendations: this.generateRecommendations(test)
        };

        return results;
      }

      percentile(sortedArray, p) {
        if (sortedArray.length === 0) return 0;
        const index = Math.ceil(sortedArray.length * p) - 1;
        return sortedArray[Math.max(0, index)];
      }

      generateRecommendations(test) {
        const recommendations = [];
        const results = test.metrics;
        const errorRate = results.failedRequests / results.totalRequests;

        if (errorRate > 0.05) {
          recommendations.push({
            type: 'error_rate',
            severity: 'high',
            description: `High error rate (${(errorRate * 100).toFixed(2)}%) indicates system instability`,
            action: 'Investigate error patterns and scale resources'
          });
        }

        const avgResponseTime = results.responseTimes.reduce((sum, rt) => sum + rt, 0) / results.responseTimes.length;
        if (avgResponseTime > 2000) {
          recommendations.push({
            type: 'response_time',
            severity: 'medium',
            description: `Average response time (${avgResponseTime.toFixed(0)}ms) exceeds target`,
            action: 'Consider caching, CDN, or horizontal scaling'
          });
        }

        if (test.culturalImpact.sacredContentAccess > 0) {
          recommendations.push({
            type: 'cultural_impact',
            severity: 'high',
            description: 'Sacred content accessed during testing',
            action: 'Review cultural protection mechanisms and test data isolation'
          });
        }

        return recommendations;
      }

      generateTestId() {
        return `test_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      }

      async getActiveTests() {
        const tests = Array.from(this.activeTests.values()).map(test => ({
          testId: test.testId,
          scenario: test.scenario,
          status: test.status,
          startTime: test.startTime,
          virtualUsers: test.virtualUsers.length,
          metrics: {
            totalRequests: test.metrics.totalRequests,
            successRate: test.metrics.successfulRequests / test.metrics.totalRequests,
            avgResponseTime: test.metrics.responseTimes.reduce((sum, rt) => sum + rt, 0) / test.metrics.responseTimes.length
          }
        }));

        return tests;
      }

      async getTestResults(testId) {
        let results = this.testResults.get(testId);
        
        if (!results) {
          // Try to get from Redis
          const cached = await redis.get(`load_test_results:${testId}`);
          if (cached) {
            results = JSON.parse(cached);
          }
        }

        return results;
      }
    }

    const loadTester = new LoadTestingService();

    // API Routes
    app.post('/tests/start', async (req, res) => {
      try {
        const { scenario, config } = req.body;
        const testId = await loadTester.runLoadTest(scenario, config);
        res.json({ testId, status: 'started' });
      } catch (error) {
        res.status(400).json({ error: error.message });
      }
    });

    app.post('/tests/:testId/stop', async (req, res) => {
      try {
        const { testId } = req.params;
        loadTester.stopLoadTest(testId);
        res.json({ testId, status: 'stopped' });
      } catch (error) {
        res.status(400).json({ error: error.message });
      }
    });

    app.get('/tests/active', async (req, res) => {
      try {
        const tests = await loadTester.getActiveTests();
        res.json({ tests });
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    app.get('/tests/:testId/results', async (req, res) => {
      try {
        const { testId } = req.params;
        const results = await loadTester.getTestResults(testId);
        
        if (!results) {
          return res.status(404).json({ error: 'Test results not found' });
        }
        
        res.json(results);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    app.get('/scenarios', (req, res) => {
      res.json({ scenarios: Object.keys(config.scenarios) });
    });

    app.get('/health', (req, res) => {
      res.json({ status: 'healthy', timestamp: new Date().toISOString() });
    });

    const port = config.server.port;
    app.listen(port, () => {
      console.log(`Load Testing service running on port ${port}`);
    });

  package.json: |
    {
      "name": "act-placemat-load-testing",
      "version": "1.0.0",
      "description": "Load Testing Service with Cultural Protection",
      "main": "server.js",
      "dependencies": {
        "express": "^4.18.2",
        "ioredis": "^5.3.2",
        "js-yaml": "^4.1.0",
        "axios": "^1.4.0"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    }