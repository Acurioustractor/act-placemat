# ACT Placemat User Segmentation and Randomization Service
# Advanced user segmentation for culturally-aware A/B testing

---
# ========================================
# USER SEGMENTATION SERVICE
# ========================================

apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-segmentation-service
  namespace: act-production
  labels:
    app: user-segmentation-service
    component: experimentation
spec:
  replicas: 2
  selector:
    matchLabels:
      app: user-segmentation-service
  template:
    metadata:
      labels:
        app: user-segmentation-service
        component: experimentation
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      containers:
      - name: segmentation-service
        image: node:18-alpine
        ports:
        - containerPort: 8080
          name: http
        - containerPort: 9090
          name: metrics
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-secrets
              key: postgres-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-secrets
              key: redis-url
        - name: USER_SERVICE_URL
          value: "http://user-service:8080"
        - name: COMMUNITY_SERVICE_URL
          value: "http://community-service:8080"
        volumeMounts:
        - name: segmentation-config
          mountPath: /app/config
        - name: segmentation-source
          mountPath: /app
        command: ["node", "server.js"]
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: segmentation-config
        configMap:
          name: segmentation-config
      - name: segmentation-source
        configMap:
          name: segmentation-source-code

---
apiVersion: v1
kind: Service
metadata:
  name: user-segmentation-service
  namespace: act-production
  labels:
    app: user-segmentation-service
spec:
  selector:
    app: user-segmentation-service
  ports:
  - name: http
    port: 8080
    targetPort: 8080
  - name: metrics
    port: 9090
    targetPort: 9090
  type: ClusterIP

---
# ========================================
# SEGMENTATION CONFIGURATION
# ========================================

apiVersion: v1
kind: ConfigMap
metadata:
  name: segmentation-config
  namespace: act-production
data:
  config.yaml: |
    # User Segmentation Configuration
    
    server:
      port: 8080
      metrics_port: 9090
      environment: production
      
    database:
      pool_size: 15
      connection_timeout: 5000
      idle_timeout: 300000
      
    redis:
      pool_size: 10
      connection_timeout: 1000
      key_prefix: "act_segmentation:"
      ttl: 86400  # 24 hours
    
    # Segmentation Rules
    segmentation:
      user_lifecycle:
        new_user_threshold: 7  # days
        active_user_threshold: 30  # days
        returning_user_threshold: 90  # days
        
      community_engagement:
        low_engagement_threshold: 2  # interactions per week
        medium_engagement_threshold: 10
        high_engagement_threshold: 25
        
      cultural_context:
        indigenous_community_weight: 0.8  # Higher weight for cultural protection
        general_community_weight: 1.0
        mixed_community_weight: 0.9
        
      geographic_segments:
        metro_areas: ["Sydney", "Melbourne", "Brisbane", "Perth", "Adelaide", "Canberra", "Darwin", "Hobart"]
        regional_threshold: 100000  # population
        remote_threshold: 10000  # population
        
    # Randomization Settings
    randomization:
      hash_algorithm: "sha256"
      salt_rotation_days: 30
      consistent_assignment: true
      traffic_allocation:
        default: 1.0  # 100% of users
        cautious: 0.1  # 10% for high-risk experiments
        gradual_rollout: 0.05  # 5% for very sensitive tests
        
    # Cultural Protection Rules
    cultural_protection:
      indigenous_community_max_participation: 0.05  # 5%
      sacred_content_max_participation: 0.02  # 2%
      elder_approval_required_threshold: 0.03  # 3%
      community_consultation_threshold: 0.1  # 10%
      
    # Privacy and Consent
    privacy:
      anonymize_segments: true
      consent_required: true
      opt_out_respect: true
      data_retention_days: 365
      
    # Performance
    performance:
      cache_segment_results: true
      cache_ttl: 3600  # 1 hour
      batch_processing: true
      batch_size: 1000

---
# ========================================
# SEGMENTATION SERVICE SOURCE CODE
# ========================================

apiVersion: v1
kind: ConfigMap
metadata:
  name: segmentation-source-code
  namespace: act-production
data:
  server.js: |
    const express = require('express');
    const { Pool } = require('pg');
    const Redis = require('ioredis');
    const yaml = require('js-yaml');
    const fs = require('fs');
    const crypto = require('crypto');
    const axios = require('axios');
    const prometheus = require('prom-client');

    // Load configuration
    const config = yaml.load(fs.readFileSync('/app/config/config.yaml', 'utf8'));

    // Initialize Express app
    const app = express();
    app.use(express.json());

    // Initialize database and Redis connections
    const db = new Pool({ connectionString: process.env.DATABASE_URL });
    const redis = new Redis(process.env.REDIS_URL);

    // Prometheus metrics
    const segmentationRequests = new prometheus.Counter({
      name: 'segmentation_requests_total',
      help: 'Total number of segmentation requests',
      labelNames: ['segment_type', 'experiment_id']
    });

    const segmentAssignments = new prometheus.Counter({
      name: 'segment_assignments_total',
      help: 'Total number of segment assignments',
      labelNames: ['segment', 'variant']
    });

    const culturalProtectionTriggers = new prometheus.Counter({
      name: 'cultural_protection_triggers_total',
      help: 'Total number of cultural protection rule triggers',
      labelNames: ['protection_type', 'severity']
    });

    // User Segmentation Service
    class UserSegmentationService {
      constructor() {
        this.segmentCache = new Map();
        this.saltRotationInterval = null;
        this.currentSalt = this.generateSalt();
        this.initializeSaltRotation();
      }

      async initializeDatabase() {
        // Create segmentation tables
        await db.query(`
          CREATE TABLE IF NOT EXISTS user_segments (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            user_id VARCHAR(255) NOT NULL,
            segment_type VARCHAR(100) NOT NULL,
            segment_value VARCHAR(100) NOT NULL,
            metadata JSONB,
            cultural_context JSONB,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            UNIQUE(user_id, segment_type)
          );
        `);

        await db.query(`
          CREATE TABLE IF NOT EXISTS experiment_segments (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            experiment_id UUID NOT NULL,
            segment_rules JSONB NOT NULL,
            allocation_rules JSONB NOT NULL,
            cultural_constraints JSONB,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );
        `);

        await db.query(`
          CREATE TABLE IF NOT EXISTS segment_assignments (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            user_id VARCHAR(255) NOT NULL,
            experiment_id UUID NOT NULL,
            segment JSONB NOT NULL,
            variant VARCHAR(100) NOT NULL,
            cultural_context JSONB,
            assignment_metadata JSONB,
            assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            UNIQUE(user_id, experiment_id)
          );
        `);

        // Create indexes for performance
        await db.query(`
          CREATE INDEX IF NOT EXISTS idx_user_segments_user_id 
          ON user_segments(user_id);
        `);

        await db.query(`
          CREATE INDEX IF NOT EXISTS idx_segment_assignments_experiment 
          ON segment_assignments(experiment_id);
        `);

        await db.query(`
          CREATE INDEX IF NOT EXISTS idx_segment_assignments_user 
          ON segment_assignments(user_id);
        `);
      }

      generateSalt() {
        return crypto.randomBytes(32).toString('hex');
      }

      initializeSaltRotation() {
        const rotationInterval = config.randomization.salt_rotation_days * 24 * 60 * 60 * 1000;
        this.saltRotationInterval = setInterval(() => {
          this.currentSalt = this.generateSalt();
          console.log('Salt rotated for enhanced randomization security');
        }, rotationInterval);
      }

      async getUserProfile(userId) {
        // Get user profile from cache or service
        const cacheKey = `${config.redis.key_prefix}profile:${userId}`;
        let profile = await redis.get(cacheKey);

        if (!profile) {
          try {
            const response = await axios.get(`${process.env.USER_SERVICE_URL}/users/${userId}`);
            profile = response.data;
            await redis.setex(cacheKey, 3600, JSON.stringify(profile)); // Cache for 1 hour
          } catch (error) {
            console.error('Failed to fetch user profile:', error);
            return null;
          }
        } else {
          profile = JSON.parse(profile);
        }

        return profile;
      }

      async getCommunityContext(userId) {
        // Get user's community memberships and cultural context
        try {
          const response = await axios.get(`${process.env.COMMUNITY_SERVICE_URL}/users/${userId}/communities`);
          return response.data.communities || [];
        } catch (error) {
          console.error('Failed to fetch community context:', error);
          return [];
        }
      }

      async segmentUser(userId, segmentTypes = ['lifecycle', 'engagement', 'cultural', 'geographic']) {
        const segments = {};
        const profile = await this.getUserProfile(userId);
        
        if (!profile) {
          return { error: 'User profile not found' };
        }

        const communities = await this.getCommunityContext(userId);
        const culturalContext = this.analyzeCulturalContext(communities);

        // User Lifecycle Segmentation
        if (segmentTypes.includes('lifecycle')) {
          segments.lifecycle = this.segmentByLifecycle(profile);
        }

        // Engagement Level Segmentation
        if (segmentTypes.includes('engagement')) {
          segments.engagement = this.segmentByEngagement(profile);
        }

        // Cultural Context Segmentation
        if (segmentTypes.includes('cultural')) {
          segments.cultural = this.segmentByCulturalContext(culturalContext);
        }

        // Geographic Segmentation
        if (segmentTypes.includes('geographic')) {
          segments.geographic = this.segmentByGeography(profile);
        }

        // Community Role Segmentation
        if (segmentTypes.includes('role')) {
          segments.role = this.segmentByRole(communities);
        }

        // Store segments in database and cache
        await this.storeUserSegments(userId, segments, culturalContext);

        return {
          userId,
          segments,
          culturalContext,
          segmentedAt: new Date().toISOString()
        };
      }

      segmentByLifecycle(profile) {
        const accountAge = this.calculateAccountAge(profile.created_at);
        const lastActivity = this.calculateDaysSinceLastActivity(profile.last_active_at);

        if (accountAge <= config.segmentation.user_lifecycle.new_user_threshold) {
          return 'new_user';
        }

        if (lastActivity <= config.segmentation.user_lifecycle.active_user_threshold) {
          return 'active_user';
        }

        if (lastActivity <= config.segmentation.user_lifecycle.returning_user_threshold) {
          return 'returning_user';
        }

        return 'dormant_user';
      }

      segmentByEngagement(profile) {
        const weeklyInteractions = profile.weekly_interactions || 0;

        if (weeklyInteractions >= config.segmentation.community_engagement.high_engagement_threshold) {
          return 'high_engagement';
        }

        if (weeklyInteractions >= config.segmentation.community_engagement.medium_engagement_threshold) {
          return 'medium_engagement';
        }

        if (weeklyInteractions >= config.segmentation.community_engagement.low_engagement_threshold) {
          return 'low_engagement';
        }

        return 'minimal_engagement';
      }

      segmentByCulturalContext(culturalContext) {
        if (culturalContext.indigenousCommunityMember) {
          return 'indigenous_community';
        }

        if (culturalContext.culturallyDiverseCommunityMember) {
          return 'culturally_diverse_community';
        }

        if (culturalContext.mixedCommunityMember) {
          return 'mixed_community';
        }

        return 'general_community';
      }

      segmentByGeography(profile) {
        const location = profile.location;
        if (!location) return 'unknown';

        if (config.segmentation.geographic_segments.metro_areas.includes(location.city)) {
          return 'metropolitan';
        }

        if (location.population > config.segmentation.geographic_segments.regional_threshold) {
          return 'regional';
        }

        if (location.population > config.segmentation.geographic_segments.remote_threshold) {
          return 'rural';
        }

        return 'remote';
      }

      segmentByRole(communities) {
        const roles = communities.map(c => c.user_role).filter(Boolean);

        if (roles.includes('elder') || roles.includes('cultural_advisor')) {
          return 'cultural_leader';
        }

        if (roles.includes('moderator') || roles.includes('admin')) {
          return 'community_leader';
        }

        if (roles.includes('mentor') || roles.includes('facilitator')) {
          return 'community_supporter';
        }

        return 'community_member';
      }

      analyzeCulturalContext(communities) {
        const context = {
          indigenousCommunityMember: false,
          culturallyDiverseCommunityMember: false,
          mixedCommunityMember: false,
          culturalSensitivityLevel: 'standard',
          communityTypes: [],
          elderConsultationRequired: false,
          maxExperimentParticipation: 1.0
        };

        for (const community of communities) {
          context.communityTypes.push(community.type);

          if (community.type === 'indigenous' || community.cultural_significance === 'indigenous') {
            context.indigenousCommunityMember = true;
            context.culturalSensitivityLevel = 'high';
            context.maxExperimentParticipation = Math.min(
              context.maxExperimentParticipation,
              config.cultural_protection.indigenous_community_max_participation
            );
          }

          if (community.cultural_significance === 'high') {
            context.culturallyDiverseCommunityMember = true;
            context.culturalSensitivityLevel = 'medium';
          }

          if (community.type === 'mixed' && context.indigenousCommunityMember) {
            context.mixedCommunityMember = true;
          }
        }

        // Determine if Elder consultation is required for this user
        context.elderConsultationRequired = context.indigenousCommunityMember && 
          context.culturalSensitivityLevel === 'high';

        return context;
      }

      async assignUserToVariant(userId, experimentId, experimentConfig) {
        try {
          // Check if user is already assigned
          const existingAssignment = await this.getExistingAssignment(userId, experimentId);
          if (existingAssignment) {
            return existingAssignment;
          }

          // Get user segments
          const segmentResult = await this.segmentUser(userId);
          if (segmentResult.error) {
            throw new Error(segmentResult.error);
          }

          // Check cultural protection rules
          const culturalCheck = await this.checkCulturalProtection(
            segmentResult, 
            experimentConfig
          );

          if (!culturalCheck.allowed) {
            return {
              error: 'Cultural protection rules prevent assignment',
              reason: culturalCheck.reason,
              culturalContext: segmentResult.culturalContext
            };
          }

          // Perform traffic allocation check
          const trafficCheck = this.checkTrafficAllocation(
            segmentResult, 
            experimentConfig
          );

          if (!trafficCheck.included) {
            return {
              assigned: false,
              reason: 'Not included in traffic allocation',
              trafficAllocation: trafficCheck.allocation
            };
          }

          // Assign variant using consistent hashing
          const variant = this.assignVariant(userId, experimentConfig, segmentResult);

          // Store assignment
          const assignment = await this.storeAssignment(
            userId, 
            experimentId, 
            segmentResult.segments, 
            variant, 
            segmentResult.culturalContext
          );

          // Update metrics
          segmentAssignments.labels(
            JSON.stringify(segmentResult.segments),
            variant
          ).inc();

          return assignment;

        } catch (error) {
          console.error('Error assigning user to variant:', error);
          throw error;
        }
      }

      async checkCulturalProtection(segmentResult, experimentConfig) {
        const culturalContext = segmentResult.culturalContext;
        const protectionRules = experimentConfig.culturalConstraints || {};

        // Check Indigenous community participation limits
        if (culturalContext.indigenousCommunityMember) {
          const currentParticipation = await this.getIndigenousCommunityParticipation(
            experimentConfig.id
          );

          if (currentParticipation >= config.cultural_protection.indigenous_community_max_participation) {
            culturalProtectionTriggers.labels('indigenous_limit', 'high').inc();
            return {
              allowed: false,
              reason: 'Indigenous community participation limit reached'
            };
          }
        }

        // Check sacred content rules
        if (protectionRules.involvesSacredContent && culturalContext.elderConsultationRequired) {
          const currentSacredParticipation = await this.getSacredContentParticipation(
            experimentConfig.id
          );

          if (currentSacredParticipation >= config.cultural_protection.sacred_content_max_participation) {
            culturalProtectionTriggers.labels('sacred_content_limit', 'critical').inc();
            return {
              allowed: false,
              reason: 'Sacred content participation limit reached'
            };
          }
        }

        // Check Elder approval requirement
        if (protectionRules.requiresElderApproval && 
            !experimentConfig.elder_approval_status === 'approved') {
          culturalProtectionTriggers.labels('elder_approval', 'medium').inc();
          return {
            allowed: false,
            reason: 'Elder approval required but not granted'
          };
        }

        return { allowed: true };
      }

      checkTrafficAllocation(segmentResult, experimentConfig) {
        const allocation = experimentConfig.trafficAllocation || 1.0;
        const culturalWeight = this.getCulturalWeight(segmentResult.culturalContext);
        const adjustedAllocation = allocation * culturalWeight;

        const hash = this.generateUserHash(
          segmentResult.userId + experimentConfig.id + 'traffic'
        );

        const included = (hash % 100) / 100 <= adjustedAllocation;

        return {
          included,
          allocation: adjustedAllocation,
          culturalWeight
        };
      }

      getCulturalWeight(culturalContext) {
        if (culturalContext.indigenousCommunityMember) {
          return config.segmentation.cultural_context.indigenous_community_weight;
        }

        if (culturalContext.mixedCommunityMember) {
          return config.segmentation.cultural_context.mixed_community_weight;
        }

        return config.segmentation.cultural_context.general_community_weight;
      }

      assignVariant(userId, experimentConfig, segmentResult) {
        const variants = experimentConfig.variants;
        const hash = this.generateUserHash(userId + experimentConfig.id);
        
        // Calculate total weight
        const totalWeight = variants.reduce((sum, variant) => sum + (variant.weight || 1), 0);
        
        // Normalize hash to 0-1 range
        const normalizedHash = (hash % totalWeight) / totalWeight;
        
        // Select variant based on cumulative weights
        let cumulativeWeight = 0;
        for (const variant of variants) {
          cumulativeWeight += (variant.weight || 1) / totalWeight;
          if (normalizedHash <= cumulativeWeight) {
            return variant.name;
          }
        }
        
        // Fallback to first variant
        return variants[0].name;
      }

      generateUserHash(input) {
        return parseInt(
          crypto.createHash(config.randomization.hash_algorithm)
            .update(input + this.currentSalt)
            .digest('hex')
            .substring(0, 8),
          16
        );
      }

      async storeUserSegments(userId, segments, culturalContext) {
        for (const [segmentType, segmentValue] of Object.entries(segments)) {
          await db.query(`
            INSERT INTO user_segments (user_id, segment_type, segment_value, metadata, cultural_context)
            VALUES ($1, $2, $3, $4, $5)
            ON CONFLICT (user_id, segment_type)
            DO UPDATE SET 
              segment_value = $3,
              metadata = $4,
              cultural_context = $5,
              updated_at = CURRENT_TIMESTAMP
          `, [
            userId,
            segmentType,
            segmentValue,
            JSON.stringify({ generatedAt: new Date().toISOString() }),
            JSON.stringify(culturalContext)
          ]);
        }

        // Cache segments
        const cacheKey = `${config.redis.key_prefix}segments:${userId}`;
        await redis.setex(cacheKey, config.performance.cache_ttl, JSON.stringify({
          segments,
          culturalContext,
          cachedAt: new Date().toISOString()
        }));
      }

      async storeAssignment(userId, experimentId, segments, variant, culturalContext) {
        const assignment = await db.query(`
          INSERT INTO segment_assignments (user_id, experiment_id, segment, variant, cultural_context, assignment_metadata)
          VALUES ($1, $2, $3, $4, $5, $6)
          RETURNING *
        `, [
          userId,
          experimentId,
          JSON.stringify(segments),
          variant,
          JSON.stringify(culturalContext),
          JSON.stringify({
            assignedAt: new Date().toISOString(),
            salt: crypto.createHash('sha256').update(this.currentSalt).digest('hex').substring(0, 16)
          })
        ]);

        return assignment.rows[0];
      }

      async getExistingAssignment(userId, experimentId) {
        const result = await db.query(`
          SELECT * FROM segment_assignments
          WHERE user_id = $1 AND experiment_id = $2
        `, [userId, experimentId]);

        return result.rows.length > 0 ? result.rows[0] : null;
      }

      async getIndigenousCommunityParticipation(experimentId) {
        const result = await db.query(`
          SELECT COUNT(*)::float / 
                 (SELECT COUNT(*) FROM users WHERE cultural_context->>'indigenousCommunityMember' = 'true') as participation_rate
          FROM segment_assignments sa
          WHERE sa.experiment_id = $1 
            AND sa.cultural_context->>'indigenousCommunityMember' = 'true'
        `, [experimentId]);

        return parseFloat(result.rows[0].participation_rate || 0);
      }

      async getSacredContentParticipation(experimentId) {
        const result = await db.query(`
          SELECT COUNT(*)::float /
                 (SELECT COUNT(*) FROM users WHERE cultural_context->>'elderConsultationRequired' = 'true') as participation_rate
          FROM segment_assignments sa
          WHERE sa.experiment_id = $1 
            AND sa.cultural_context->>'elderConsultationRequired' = 'true'
        `, [experimentId]);

        return parseFloat(result.rows[0].participation_rate || 0);
      }

      calculateAccountAge(createdAt) {
        const now = new Date();
        const created = new Date(createdAt);
        return Math.floor((now - created) / (1000 * 60 * 60 * 24));
      }

      calculateDaysSinceLastActivity(lastActiveAt) {
        if (!lastActiveAt) return Infinity;
        
        const now = new Date();
        const lastActive = new Date(lastActiveAt);
        return Math.floor((now - lastActive) / (1000 * 60 * 60 * 24));
      }

      async getSegmentStatistics() {
        const stats = await db.query(`
          SELECT 
            segment_type,
            segment_value,
            COUNT(*) as count,
            COUNT(CASE WHEN cultural_context->>'indigenousCommunityMember' = 'true' THEN 1 END) as indigenous_count,
            AVG(CASE WHEN cultural_context->>'culturalSensitivityLevel' = 'high' THEN 1.0 ELSE 0.0 END) as high_cultural_sensitivity_rate
          FROM user_segments
          GROUP BY segment_type, segment_value
          ORDER BY segment_type, count DESC
        `);

        return stats.rows;
      }

      // Cleanup method
      async cleanup() {
        if (this.saltRotationInterval) {
          clearInterval(this.saltRotationInterval);
        }
      }
    }

    // Initialize segmentation service
    const segmentationService = new UserSegmentationService();

    // API Routes
    app.post('/segment/:userId', async (req, res) => {
      try {
        segmentationRequests.labels('user_segmentation', 'manual').inc();
        
        const { userId } = req.params;
        const { segmentTypes } = req.body;

        const result = await segmentationService.segmentUser(userId, segmentTypes);
        res.json(result);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    app.post('/assign/:userId/:experimentId', async (req, res) => {
      try {
        segmentationRequests.labels('variant_assignment', req.params.experimentId).inc();
        
        const { userId, experimentId } = req.params;
        const experimentConfig = req.body;

        const assignment = await segmentationService.assignUserToVariant(
          userId, 
          experimentId, 
          experimentConfig
        );
        
        res.json(assignment);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    app.get('/segments/:userId', async (req, res) => {
      try {
        const { userId } = req.params;
        
        // Try cache first
        const cacheKey = `${config.redis.key_prefix}segments:${userId}`;
        let segments = await redis.get(cacheKey);
        
        if (segments) {
          return res.json(JSON.parse(segments));
        }

        // Fallback to database
        const result = await db.query(`
          SELECT segment_type, segment_value, cultural_context, updated_at
          FROM user_segments
          WHERE user_id = $1
        `, [userId]);

        const segmentData = result.rows.reduce((acc, row) => {
          acc.segments = acc.segments || {};
          acc.segments[row.segment_type] = row.segment_value;
          acc.culturalContext = row.cultural_context;
          acc.lastUpdated = row.updated_at;
          return acc;
        }, {});

        res.json(segmentData);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    app.get('/statistics/segments', async (req, res) => {
      try {
        const stats = await segmentationService.getSegmentStatistics();
        res.json({ statistics: stats });
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    app.get('/health', (req, res) => {
      res.json({ status: 'healthy', timestamp: new Date().toISOString() });
    });

    app.get('/ready', async (req, res) => {
      try {
        await db.query('SELECT 1');
        await redis.ping();
        res.json({ status: 'ready' });
      } catch (error) {
        res.status(503).json({ status: 'not ready', error: error.message });
      }
    });

    app.get('/metrics', (req, res) => {
      res.set('Content-Type', prometheus.register.contentType);
      res.end(prometheus.register.metrics());
    });

    // Initialize and start server
    async function start() {
      try {
        await segmentationService.initializeDatabase();
        
        const port = config.server.port;
        app.listen(port, () => {
          console.log(`User Segmentation service running on port ${port}`);
        });
      } catch (error) {
        console.error('Failed to start User Segmentation service:', error);
        process.exit(1);
      }
    }

    // Graceful shutdown
    process.on('SIGTERM', async () => {
      console.log('Shutting down gracefully...');
      await segmentationService.cleanup();
      process.exit(0);
    });

    start();

  package.json: |
    {
      "name": "act-placemat-user-segmentation",
      "version": "1.0.0",
      "description": "User Segmentation and Randomization Service for ACT Placemat A/B Testing",
      "main": "server.js",
      "dependencies": {
        "express": "^4.18.2",
        "pg": "^8.11.0",
        "ioredis": "^5.3.2",
        "js-yaml": "^4.1.0",
        "axios": "^1.4.0",
        "prom-client": "^14.2.0"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    }