# Redis Cluster Deployment with High Availability
# Australian compliance with fault tolerance and data residency enforcement

---
# Redis Cluster Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: redis-cluster-config
  namespace: act-placemat
  labels:
    component: task-queue
    service-type: redis-cluster
    data-residency: australia
  annotations:
    description: "Redis cluster configuration for task queue with Australian compliance"
    compliance.framework: "australian-privacy-act"
data:
  redis.conf: |
    # Redis Configuration for Task Queue Cluster
    # Optimized for Australian compliance and high availability
    
    # Basic configuration
    bind 0.0.0.0
    port 6379
    protected-mode yes
    tcp-backlog 511
    timeout 0
    tcp-keepalive 300
    
    # Cluster configuration
    cluster-enabled yes
    cluster-config-file nodes.conf
    cluster-node-timeout 15000
    cluster-announce-hostname yes
    cluster-require-full-coverage yes
    cluster-migration-barrier 1
    cluster-allow-reads-when-down no
    
    # Memory management
    maxmemory 1gb
    maxmemory-policy allkeys-lru
    maxmemory-samples 5
    
    # Persistence for Australian compliance
    save 900 1
    save 300 10
    save 60 10000
    stop-writes-on-bgsave-error yes
    rdbcompression yes
    rdbchecksum yes
    dbfilename dump.rdb
    dir /data
    
    # AOF configuration for durability
    appendonly yes
    appendfilename "appendonly.aof"
    appendfsync everysec
    no-appendfsync-on-rewrite no
    auto-aof-rewrite-percentage 100
    auto-aof-rewrite-min-size 64mb
    aof-load-truncated yes
    aof-use-rdb-preamble yes
    
    # Security settings
    requirepass ${REDIS_PASSWORD}
    masterauth ${REDIS_PASSWORD}
    
    # Logging for Australian compliance audit
    loglevel notice
    logfile /var/log/redis/redis-server.log
    syslog-enabled yes
    syslog-ident redis-task-queue
    syslog-facility local0
    
    # Slow log for performance monitoring
    slowlog-log-slower-than 10000
    slowlog-max-len 128
    
    # Client output buffer limits
    client-output-buffer-limit normal 0 0 0
    client-output-buffer-limit replica 256mb 64mb 60
    client-output-buffer-limit pubsub 32mb 8mb 60
    
    # Australian timezone
    timezone Australia/Sydney
    
    # Compliance and audit settings
    notify-keyspace-events "Ex"  # Enable keyspace notifications for audit
    
    # Performance tuning
    hz 10
    dynamic-hz yes
    aof-rewrite-incremental-fsync yes
    rdb-save-incremental-fsync yes
    
    # Replication settings
    repl-diskless-sync no
    repl-diskless-sync-delay 5
    repl-ping-replica-period 10
    repl-timeout 60
    repl-disable-tcp-nodelay no
    repl-backlog-size 1mb
    repl-backlog-ttl 3600
    replica-priority 100
    replica-read-only yes
    
    # Security enhancements
    rename-command FLUSHDB ""
    rename-command FLUSHALL ""
    rename-command DEBUG ""
    rename-command CONFIG "CONFIG_a8b9c0d1e2f3"
    
    # Memory optimization
    hash-max-ziplist-entries 512
    hash-max-ziplist-value 64
    list-max-ziplist-size -2
    list-compress-depth 0
    set-max-intset-entries 512
    zset-max-ziplist-entries 128
    zset-max-ziplist-value 64
    hll-sparse-max-bytes 3000
    stream-node-max-bytes 4096
    stream-node-max-entries 100
    activerehashing yes
    
    # Lua scripting
    lua-time-limit 5000

  # Australian compliance monitoring
  compliance_monitoring.lua: |
    -- Lua script for Australian compliance monitoring
    -- Monitors data residency and audit requirements
    
    local function audit_operation(operation, key, value)
        local audit_key = "audit:operations:" .. os.date("%Y%m%d")
        local audit_entry = {
            timestamp = os.time(),
            operation = operation,
            key = key,
            data_residency = "australia",
            compliance_framework = "australian-privacy-act"
        }
        redis.call('ZADD', audit_key, os.time(), cjson.encode(audit_entry))
        redis.call('EXPIRE', audit_key, 86400 * 2557)  -- 7 years retention
        return audit_entry
    end
    
    local function validate_data_residency(key)
        -- Ensure all data remains within Australian jurisdiction
        local region_key = "metadata:region:" .. key
        local region = redis.call('GET', region_key)
        if not region or region ~= "australia" then
            redis.call('SET', region_key, "australia")
            redis.call('EXPIRE', region_key, 86400 * 30)  -- 30 days metadata retention
        end
        return true
    end
    
    -- Register compliance functions globally
    _G.audit_operation = audit_operation
    _G.validate_data_residency = validate_data_residency

---
# Redis Cluster StatefulSet
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: redis-cluster
  namespace: act-placemat
  labels:
    component: task-queue
    service-type: redis-cluster
    data-residency: australia
  annotations:
    description: "Redis cluster for task queue with Australian compliance"
    compliance.framework: "australian-privacy-act"
spec:
  serviceName: redis-cluster-headless
  replicas: 6  # 3 masters + 3 replicas for high availability
  selector:
    matchLabels:
      component: redis-cluster
      data-residency: australia
  template:
    metadata:
      labels:
        component: redis-cluster
        data-residency: australia
      annotations:
        compliance.framework: "australian-privacy-act"
        data.classification: "restricted"
        audit.required: "true"
    spec:
      serviceAccountName: redis-cluster-service
      securityContext:
        runAsNonRoot: true
        runAsUser: 999  # Redis user
        fsGroup: 999
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: "kubernetes.io/zone"
                operator: In
                values:
                - "australia-southeast1-a"
                - "australia-southeast1-b"
                - "australia-southeast1-c"
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchLabels:
                component: redis-cluster
            topologyKey: kubernetes.io/hostname
      containers:
      - name: redis
        image: redis:7.2-alpine
        imagePullPolicy: Always
        env:
        - name: TZ
          value: "Australia/Sydney"
        - name: DATA_RESIDENCY
          value: "australia"
        - name: COMPLIANCE_FRAMEWORK
          value: "australian-privacy-act"
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: redis-cluster-auth
              key: password
        - name: POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        ports:
        - name: redis
          containerPort: 6379
          protocol: TCP
        - name: cluster-bus
          containerPort: 16379
          protocol: TCP
        command:
        - /bin/sh
        - -c
        - |
          # Redis cluster initialization script
          echo "Starting Redis cluster node: $POD_NAME"
          
          # Create data directory
          mkdir -p /data
          chown redis:redis /data
          
          # Copy configuration
          cp /etc/redis/redis.conf /data/redis.conf
          
          # Replace password placeholder
          sed -i "s/\${REDIS_PASSWORD}/$REDIS_PASSWORD/g" /data/redis.conf
          
          # Set cluster announce IP
          echo "cluster-announce-ip $POD_IP" >> /data/redis.conf
          echo "cluster-announce-port 6379" >> /data/redis.conf
          echo "cluster-announce-bus-port 16379" >> /data/redis.conf
          
          # Start Redis server
          exec redis-server /data/redis.conf
        livenessProbe:
          exec:
            command:
            - redis-cli
            - -a
            - "$REDIS_PASSWORD"
            - ping
          initialDelaySeconds: 30
          periodSeconds: 30
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          exec:
            command:
            - redis-cli
            - -a
            - "$REDIS_PASSWORD"
            - ping
          initialDelaySeconds: 5
          periodSeconds: 10
          timeoutSeconds: 3
          failureThreshold: 3
        resources:
          limits:
            cpu: 1000m
            memory: 2Gi
          requests:
            cpu: 500m
            memory: 1Gi
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: false  # Redis needs to write to data directory
          runAsNonRoot: true
          runAsUser: 999
          capabilities:
            drop:
            - ALL
        volumeMounts:
        - name: redis-data
          mountPath: /data
        - name: redis-config
          mountPath: /etc/redis
          readOnly: true
        - name: redis-logs
          mountPath: /var/log/redis
      - name: redis-exporter
        image: oliver006/redis_exporter:v1.55.0
        imagePullPolicy: Always
        env:
        - name: TZ
          value: "Australia/Sydney"
        - name: REDIS_ADDR
          value: "redis://localhost:6379"
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: redis-cluster-auth
              key: password
        - name: REDIS_EXPORTER_INCLUDE_SYSTEM_METRICS
          value: "true"
        - name: REDIS_EXPORTER_CHECK_KEYS
          value: "act:queue:*,audit:*"
        ports:
        - name: metrics
          containerPort: 9121
          protocol: TCP
        livenessProbe:
          httpGet:
            path: /metrics
            port: metrics
          initialDelaySeconds: 30
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /metrics
            port: metrics
          initialDelaySeconds: 5
          periodSeconds: 10
        resources:
          limits:
            cpu: 200m
            memory: 256Mi
          requests:
            cpu: 100m
            memory: 128Mi
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 1001
          capabilities:
            drop:
            - ALL
      volumes:
      - name: redis-config
        configMap:
          name: redis-cluster-config
      - name: redis-logs
        emptyDir: {}
      imagePullSecrets:
      - name: registry-credentials
      nodeSelector:
        data-residency: australia
  volumeClaimTemplates:
  - metadata:
      name: redis-data
      labels:
        component: task-queue
        data-residency: australia
    spec:
      accessModes: ["ReadWriteOnce"]
      storageClassName: "australia-ssd"
      resources:
        requests:
          storage: 20Gi

---
# Redis Cluster Service Account
apiVersion: v1
kind: ServiceAccount
metadata:
  name: redis-cluster-service
  namespace: act-placemat
  labels:
    component: task-queue
    role: redis-cluster
    data-residency: australia
  annotations:
    description: "Service account for Redis cluster operations"
    compliance.framework: "australian-privacy-act"
automountServiceAccountToken: true

---
# Redis Cluster Headless Service
apiVersion: v1
kind: Service
metadata:
  name: redis-cluster-headless
  namespace: act-placemat
  labels:
    component: task-queue
    service-type: redis-cluster-headless
    data-residency: australia
  annotations:
    description: "Headless service for Redis cluster discovery"
    compliance.framework: "australian-privacy-act"
spec:
  selector:
    component: redis-cluster
    data-residency: australia
  ports:
  - name: redis
    port: 6379
    targetPort: redis
    protocol: TCP
  - name: cluster-bus
    port: 16379
    targetPort: cluster-bus
    protocol: TCP
  clusterIP: None
  type: ClusterIP

---
# Redis Cluster Service
apiVersion: v1
kind: Service
metadata:
  name: redis-cluster-service
  namespace: act-placemat
  labels:
    component: task-queue
    service-type: redis-cluster
    data-residency: australia
  annotations:
    description: "Service for Redis cluster access"
    compliance.framework: "australian-privacy-act"
spec:
  selector:
    component: redis-cluster
    data-residency: australia
  ports:
  - name: redis
    port: 6379
    targetPort: redis
    protocol: TCP
  - name: metrics
    port: 9121
    targetPort: metrics
    protocol: TCP
  type: ClusterIP

---
# Redis Cluster Initialization Job
apiVersion: batch/v1
kind: Job
metadata:
  name: redis-cluster-init
  namespace: act-placemat
  labels:
    component: task-queue
    operation: cluster-init
    data-residency: australia
  annotations:
    description: "Initialize Redis cluster with Australian compliance"
    compliance.framework: "australian-privacy-act"
spec:
  template:
    metadata:
      labels:
        component: redis-cluster-init
        data-residency: australia
    spec:
      serviceAccountName: redis-cluster-service
      restartPolicy: OnFailure
      securityContext:
        runAsNonRoot: true
        runAsUser: 999
        fsGroup: 999
      containers:
      - name: cluster-init
        image: redis:7.2-alpine
        env:
        - name: TZ
          value: "Australia/Sydney"
        - name: DATA_RESIDENCY
          value: "australia"
        - name: COMPLIANCE_FRAMEWORK
          value: "australian-privacy-act"
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: redis-cluster-auth
              key: password
        command:
        - /bin/sh
        - -c
        - |
          echo "Initializing Redis cluster for Australian compliance..."
          
          # Wait for all Redis nodes to be ready
          sleep 30
          
          # Get Redis node IPs
          REDIS_NODES=""
          for i in $(seq 0 5); do
            NODE_IP=$(nslookup redis-cluster-$i.redis-cluster-headless.act-placemat.svc.cluster.local | grep Address | tail -1 | awk '{print $2}')
            if [ -n "$NODE_IP" ]; then
              REDIS_NODES="$REDIS_NODES $NODE_IP:6379"
            fi
          done
          
          echo "Redis nodes: $REDIS_NODES"
          
          # Test connectivity to all nodes
          for node in $REDIS_NODES; do
            echo "Testing connectivity to $node..."
            if redis-cli -h ${node%:*} -p ${node#*:} -a "$REDIS_PASSWORD" ping; then
              echo "‚úÖ $node is responsive"
            else
              echo "‚ùå $node is not responsive"
              exit 1
            fi
          done
          
          # Initialize cluster
          echo "Creating Redis cluster..."
          if echo "yes" | redis-cli --cluster create $REDIS_NODES \
            --cluster-replicas 1 \
            -a "$REDIS_PASSWORD"; then
            echo "‚úÖ Redis cluster created successfully"
          else
            echo "‚ùå Failed to create Redis cluster"
            exit 1
          fi
          
          # Verify cluster status
          echo "Verifying cluster status..."
          FIRST_NODE=$(echo $REDIS_NODES | awk '{print $1}')
          if redis-cli -h ${FIRST_NODE%:*} -p ${FIRST_NODE#*:} -a "$REDIS_PASSWORD" cluster info | grep "cluster_state:ok"; then
            echo "‚úÖ Cluster is healthy"
          else
            echo "‚ùå Cluster health check failed"
            exit 1
          fi
          
          # Load compliance Lua script
          echo "Loading Australian compliance monitoring script..."
          redis-cli -h ${FIRST_NODE%:*} -p ${FIRST_NODE#*:} -a "$REDIS_PASSWORD" \
            SCRIPT LOAD "$(cat /etc/redis-scripts/compliance_monitoring.lua)"
          
          # Set up initial compliance metadata
          echo "Setting up Australian compliance metadata..."
          redis-cli -h ${FIRST_NODE%:*} -p ${FIRST_NODE#*:} -a "$REDIS_PASSWORD" \
            SET "metadata:cluster:region" "australia" EX 86400
          redis-cli -h ${FIRST_NODE%:*} -p ${FIRST_NODE#*:} -a "$REDIS_PASSWORD" \
            SET "metadata:cluster:compliance_framework" "australian-privacy-act" EX 86400
          redis-cli -h ${FIRST_NODE%:*} -p ${FIRST_NODE#*:} -a "$REDIS_PASSWORD" \
            SET "metadata:cluster:data_classification" "restricted" EX 86400
          
          echo "üéâ Redis cluster initialization completed successfully"
        resources:
          limits:
            cpu: 500m
            memory: 512Mi
          requests:
            cpu: 200m
            memory: 256Mi
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 999
          capabilities:
            drop:
            - ALL
        volumeMounts:
        - name: redis-scripts
          mountPath: /etc/redis-scripts
          readOnly: true
      volumes:
      - name: redis-scripts
        configMap:
          name: redis-cluster-config
      imagePullSecrets:
      - name: registry-credentials
      nodeSelector:
        data-residency: australia

---
# Redis Cluster Authentication Secret
apiVersion: v1
kind: Secret
metadata:
  name: redis-cluster-auth
  namespace: act-placemat
  labels:
    component: task-queue
    secret-type: authentication
    data-residency: australia
  annotations:
    description: "Authentication credentials for Redis cluster"
    compliance.framework: "australian-privacy-act"
type: Opaque
data:
  # Base64 encoded strong password for Redis cluster
  # In production, this should be generated and managed by a secret management system
  password: QWN0UGxhY2VtYXRSZWRpc0NsdXN0ZXJQYXNzd29yZDIwMjQ=  # ActPlacematRedisClusterPassword2024

---
# Redis Cluster RBAC Role
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: redis-cluster-service
  namespace: act-placemat
  labels:
    component: task-queue
    data-residency: australia
  annotations:
    description: "Role for Redis cluster operations"
    compliance.framework: "australian-privacy-act"
rules:
# Pod management for cluster operations
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
# Service discovery
- apiGroups: [""]
  resources: ["services", "endpoints"]
  verbs: ["get", "list", "watch"]
# ConfigMap access for configuration
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["get", "list", "watch"]
# Event creation for operational logging
- apiGroups: [""]
  resources: ["events"]
  verbs: ["create", "patch"]

---
# Redis Cluster Role Binding
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: redis-cluster-service-binding
  namespace: act-placemat
  labels:
    component: task-queue
    data-residency: australia
  annotations:
    description: "Binds redis-cluster-service to cluster operations role"
    compliance.framework: "australian-privacy-act"
subjects:
- kind: ServiceAccount
  name: redis-cluster-service
  namespace: act-placemat
roleRef:
  kind: Role
  name: redis-cluster-service
  apiGroup: rbac.authorization.k8s.io