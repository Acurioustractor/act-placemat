
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectMember
 * 
 */
export type ProjectMember = $Result.DefaultSelection<Prisma.$ProjectMemberPayload>
/**
 * Model Story
 * 
 */
export type Story = $Result.DefaultSelection<Prisma.$StoryPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Opportunity
 * 
 */
export type Opportunity = $Result.DefaultSelection<Prisma.$OpportunityPayload>
/**
 * Model OpportunityApplication
 * 
 */
export type OpportunityApplication = $Result.DefaultSelection<Prisma.$OpportunityApplicationPayload>
/**
 * Model PageView
 * 
 */
export type PageView = $Result.DefaultSelection<Prisma.$PageViewPayload>
/**
 * Model SearchQuery
 * 
 */
export type SearchQuery = $Result.DefaultSelection<Prisma.$SearchQueryPayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model LifeOSProfile
 * 
 */
export type LifeOSProfile = $Result.DefaultSelection<Prisma.$LifeOSProfilePayload>
/**
 * Model Habit
 * 
 */
export type Habit = $Result.DefaultSelection<Prisma.$HabitPayload>
/**
 * Model HabitCompletion
 * 
 */
export type HabitCompletion = $Result.DefaultSelection<Prisma.$HabitCompletionPayload>
/**
 * Model Goal
 * 
 */
export type Goal = $Result.DefaultSelection<Prisma.$GoalPayload>
/**
 * Model GoalMilestone
 * 
 */
export type GoalMilestone = $Result.DefaultSelection<Prisma.$GoalMilestonePayload>
/**
 * Model GoalUpdate
 * 
 */
export type GoalUpdate = $Result.DefaultSelection<Prisma.$GoalUpdatePayload>
/**
 * Model MeditationSession
 * 
 */
export type MeditationSession = $Result.DefaultSelection<Prisma.$MeditationSessionPayload>
/**
 * Model MoodEntry
 * 
 */
export type MoodEntry = $Result.DefaultSelection<Prisma.$MoodEntryPayload>
/**
 * Model Journal
 * 
 */
export type Journal = $Result.DefaultSelection<Prisma.$JournalPayload>
/**
 * Model CalendarEvent
 * 
 */
export type CalendarEvent = $Result.DefaultSelection<Prisma.$CalendarEventPayload>
/**
 * Model EventAttendee
 * 
 */
export type EventAttendee = $Result.DefaultSelection<Prisma.$EventAttendeePayload>
/**
 * Model FinancialTransaction
 * 
 */
export type FinancialTransaction = $Result.DefaultSelection<Prisma.$FinancialTransactionPayload>
/**
 * Model Budget
 * 
 */
export type Budget = $Result.DefaultSelection<Prisma.$BudgetPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  MEMBER: 'MEMBER',
  MODERATOR: 'MODERATOR',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ProjectStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  PAUSED: 'PAUSED',
  ARCHIVED: 'ARCHIVED'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const Visibility: {
  PUBLIC: 'PUBLIC',
  PRIVATE: 'PRIVATE',
  COMMUNITY_ONLY: 'COMMUNITY_ONLY'
};

export type Visibility = (typeof Visibility)[keyof typeof Visibility]


export const ProjectRole: {
  MEMBER: 'MEMBER',
  CONTRIBUTOR: 'CONTRIBUTOR',
  LEAD: 'LEAD',
  OWNER: 'OWNER'
};

export type ProjectRole = (typeof ProjectRole)[keyof typeof ProjectRole]


export const StoryStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type StoryStatus = (typeof StoryStatus)[keyof typeof StoryStatus]


export const CommentStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  SPAM: 'SPAM'
};

export type CommentStatus = (typeof CommentStatus)[keyof typeof CommentStatus]


export const OpportunityType: {
  VOLUNTEER: 'VOLUNTEER',
  JOB: 'JOB',
  COLLABORATION: 'COLLABORATION',
  FUNDING: 'FUNDING',
  MENTORSHIP: 'MENTORSHIP',
  SKILL_SHARE: 'SKILL_SHARE'
};

export type OpportunityType = (typeof OpportunityType)[keyof typeof OpportunityType]


export const OpportunityStatus: {
  DRAFT: 'DRAFT',
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  FILLED: 'FILLED',
  CANCELLED: 'CANCELLED'
};

export type OpportunityStatus = (typeof OpportunityStatus)[keyof typeof OpportunityStatus]


export const ApplicationStatus: {
  PENDING: 'PENDING',
  REVIEWING: 'REVIEWING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  WITHDRAWN: 'WITHDRAWN'
};

export type ApplicationStatus = (typeof ApplicationStatus)[keyof typeof ApplicationStatus]


export const HabitFrequency: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  CUSTOM: 'CUSTOM'
};

export type HabitFrequency = (typeof HabitFrequency)[keyof typeof HabitFrequency]


export const GoalStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  ON_HOLD: 'ON_HOLD',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type GoalStatus = (typeof GoalStatus)[keyof typeof GoalStatus]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const MilestoneStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type MilestoneStatus = (typeof MilestoneStatus)[keyof typeof MilestoneStatus]


export const EventType: {
  PERSONAL: 'PERSONAL',
  WORK: 'WORK',
  COMMUNITY: 'COMMUNITY',
  HEALTH: 'HEALTH',
  EDUCATION: 'EDUCATION',
  SOCIAL: 'SOCIAL'
};

export type EventType = (typeof EventType)[keyof typeof EventType]


export const AttendeeStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED',
  TENTATIVE: 'TENTATIVE'
};

export type AttendeeStatus = (typeof AttendeeStatus)[keyof typeof AttendeeStatus]


export const TransactionType: {
  INCOME: 'INCOME',
  EXPENSE: 'EXPENSE',
  TRANSFER: 'TRANSFER',
  INVESTMENT: 'INVESTMENT'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const BudgetPeriod: {
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  QUARTERLY: 'QUARTERLY',
  YEARLY: 'YEARLY',
  CUSTOM: 'CUSTOM'
};

export type BudgetPeriod = (typeof BudgetPeriod)[keyof typeof BudgetPeriod]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type Visibility = $Enums.Visibility

export const Visibility: typeof $Enums.Visibility

export type ProjectRole = $Enums.ProjectRole

export const ProjectRole: typeof $Enums.ProjectRole

export type StoryStatus = $Enums.StoryStatus

export const StoryStatus: typeof $Enums.StoryStatus

export type CommentStatus = $Enums.CommentStatus

export const CommentStatus: typeof $Enums.CommentStatus

export type OpportunityType = $Enums.OpportunityType

export const OpportunityType: typeof $Enums.OpportunityType

export type OpportunityStatus = $Enums.OpportunityStatus

export const OpportunityStatus: typeof $Enums.OpportunityStatus

export type ApplicationStatus = $Enums.ApplicationStatus

export const ApplicationStatus: typeof $Enums.ApplicationStatus

export type HabitFrequency = $Enums.HabitFrequency

export const HabitFrequency: typeof $Enums.HabitFrequency

export type GoalStatus = $Enums.GoalStatus

export const GoalStatus: typeof $Enums.GoalStatus

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type MilestoneStatus = $Enums.MilestoneStatus

export const MilestoneStatus: typeof $Enums.MilestoneStatus

export type EventType = $Enums.EventType

export const EventType: typeof $Enums.EventType

export type AttendeeStatus = $Enums.AttendeeStatus

export const AttendeeStatus: typeof $Enums.AttendeeStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type BudgetPeriod = $Enums.BudgetPeriod

export const BudgetPeriod: typeof $Enums.BudgetPeriod

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.projectMember`: Exposes CRUD operations for the **ProjectMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMembers
    * const projectMembers = await prisma.projectMember.findMany()
    * ```
    */
  get projectMember(): Prisma.ProjectMemberDelegate<ExtArgs>;

  /**
   * `prisma.story`: Exposes CRUD operations for the **Story** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stories
    * const stories = await prisma.story.findMany()
    * ```
    */
  get story(): Prisma.StoryDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.opportunity`: Exposes CRUD operations for the **Opportunity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Opportunities
    * const opportunities = await prisma.opportunity.findMany()
    * ```
    */
  get opportunity(): Prisma.OpportunityDelegate<ExtArgs>;

  /**
   * `prisma.opportunityApplication`: Exposes CRUD operations for the **OpportunityApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OpportunityApplications
    * const opportunityApplications = await prisma.opportunityApplication.findMany()
    * ```
    */
  get opportunityApplication(): Prisma.OpportunityApplicationDelegate<ExtArgs>;

  /**
   * `prisma.pageView`: Exposes CRUD operations for the **PageView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PageViews
    * const pageViews = await prisma.pageView.findMany()
    * ```
    */
  get pageView(): Prisma.PageViewDelegate<ExtArgs>;

  /**
   * `prisma.searchQuery`: Exposes CRUD operations for the **SearchQuery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchQueries
    * const searchQueries = await prisma.searchQuery.findMany()
    * ```
    */
  get searchQuery(): Prisma.SearchQueryDelegate<ExtArgs>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs>;

  /**
   * `prisma.lifeOSProfile`: Exposes CRUD operations for the **LifeOSProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LifeOSProfiles
    * const lifeOSProfiles = await prisma.lifeOSProfile.findMany()
    * ```
    */
  get lifeOSProfile(): Prisma.LifeOSProfileDelegate<ExtArgs>;

  /**
   * `prisma.habit`: Exposes CRUD operations for the **Habit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Habits
    * const habits = await prisma.habit.findMany()
    * ```
    */
  get habit(): Prisma.HabitDelegate<ExtArgs>;

  /**
   * `prisma.habitCompletion`: Exposes CRUD operations for the **HabitCompletion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HabitCompletions
    * const habitCompletions = await prisma.habitCompletion.findMany()
    * ```
    */
  get habitCompletion(): Prisma.HabitCompletionDelegate<ExtArgs>;

  /**
   * `prisma.goal`: Exposes CRUD operations for the **Goal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Goals
    * const goals = await prisma.goal.findMany()
    * ```
    */
  get goal(): Prisma.GoalDelegate<ExtArgs>;

  /**
   * `prisma.goalMilestone`: Exposes CRUD operations for the **GoalMilestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GoalMilestones
    * const goalMilestones = await prisma.goalMilestone.findMany()
    * ```
    */
  get goalMilestone(): Prisma.GoalMilestoneDelegate<ExtArgs>;

  /**
   * `prisma.goalUpdate`: Exposes CRUD operations for the **GoalUpdate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GoalUpdates
    * const goalUpdates = await prisma.goalUpdate.findMany()
    * ```
    */
  get goalUpdate(): Prisma.GoalUpdateDelegate<ExtArgs>;

  /**
   * `prisma.meditationSession`: Exposes CRUD operations for the **MeditationSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MeditationSessions
    * const meditationSessions = await prisma.meditationSession.findMany()
    * ```
    */
  get meditationSession(): Prisma.MeditationSessionDelegate<ExtArgs>;

  /**
   * `prisma.moodEntry`: Exposes CRUD operations for the **MoodEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MoodEntries
    * const moodEntries = await prisma.moodEntry.findMany()
    * ```
    */
  get moodEntry(): Prisma.MoodEntryDelegate<ExtArgs>;

  /**
   * `prisma.journal`: Exposes CRUD operations for the **Journal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Journals
    * const journals = await prisma.journal.findMany()
    * ```
    */
  get journal(): Prisma.JournalDelegate<ExtArgs>;

  /**
   * `prisma.calendarEvent`: Exposes CRUD operations for the **CalendarEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarEvents
    * const calendarEvents = await prisma.calendarEvent.findMany()
    * ```
    */
  get calendarEvent(): Prisma.CalendarEventDelegate<ExtArgs>;

  /**
   * `prisma.eventAttendee`: Exposes CRUD operations for the **EventAttendee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventAttendees
    * const eventAttendees = await prisma.eventAttendee.findMany()
    * ```
    */
  get eventAttendee(): Prisma.EventAttendeeDelegate<ExtArgs>;

  /**
   * `prisma.financialTransaction`: Exposes CRUD operations for the **FinancialTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialTransactions
    * const financialTransactions = await prisma.financialTransaction.findMany()
    * ```
    */
  get financialTransaction(): Prisma.FinancialTransactionDelegate<ExtArgs>;

  /**
   * `prisma.budget`: Exposes CRUD operations for the **Budget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budgets
    * const budgets = await prisma.budget.findMany()
    * ```
    */
  get budget(): Prisma.BudgetDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Project: 'Project',
    ProjectMember: 'ProjectMember',
    Story: 'Story',
    Comment: 'Comment',
    Opportunity: 'Opportunity',
    OpportunityApplication: 'OpportunityApplication',
    PageView: 'PageView',
    SearchQuery: 'SearchQuery',
    Setting: 'Setting',
    Media: 'Media',
    LifeOSProfile: 'LifeOSProfile',
    Habit: 'Habit',
    HabitCompletion: 'HabitCompletion',
    Goal: 'Goal',
    GoalMilestone: 'GoalMilestone',
    GoalUpdate: 'GoalUpdate',
    MeditationSession: 'MeditationSession',
    MoodEntry: 'MoodEntry',
    Journal: 'Journal',
    CalendarEvent: 'CalendarEvent',
    EventAttendee: 'EventAttendee',
    FinancialTransaction: 'FinancialTransaction',
    Budget: 'Budget'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "project" | "projectMember" | "story" | "comment" | "opportunity" | "opportunityApplication" | "pageView" | "searchQuery" | "setting" | "media" | "lifeOSProfile" | "habit" | "habitCompletion" | "goal" | "goalMilestone" | "goalUpdate" | "meditationSession" | "moodEntry" | "journal" | "calendarEvent" | "eventAttendee" | "financialTransaction" | "budget"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectMember: {
        payload: Prisma.$ProjectMemberPayload<ExtArgs>
        fields: Prisma.ProjectMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findFirst: {
            args: Prisma.ProjectMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findMany: {
            args: Prisma.ProjectMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          create: {
            args: Prisma.ProjectMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          createMany: {
            args: Prisma.ProjectMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          delete: {
            args: Prisma.ProjectMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          update: {
            args: Prisma.ProjectMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          deleteMany: {
            args: Prisma.ProjectMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          aggregate: {
            args: Prisma.ProjectMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMember>
          }
          groupBy: {
            args: Prisma.ProjectMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberCountAggregateOutputType> | number
          }
        }
      }
      Story: {
        payload: Prisma.$StoryPayload<ExtArgs>
        fields: Prisma.StoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          findFirst: {
            args: Prisma.StoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          findMany: {
            args: Prisma.StoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>[]
          }
          create: {
            args: Prisma.StoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          createMany: {
            args: Prisma.StoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>[]
          }
          delete: {
            args: Prisma.StoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          update: {
            args: Prisma.StoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          deleteMany: {
            args: Prisma.StoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          aggregate: {
            args: Prisma.StoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStory>
          }
          groupBy: {
            args: Prisma.StoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryCountArgs<ExtArgs>
            result: $Utils.Optional<StoryCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Opportunity: {
        payload: Prisma.$OpportunityPayload<ExtArgs>
        fields: Prisma.OpportunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpportunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpportunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          findFirst: {
            args: Prisma.OpportunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpportunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          findMany: {
            args: Prisma.OpportunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          create: {
            args: Prisma.OpportunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          createMany: {
            args: Prisma.OpportunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpportunityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          delete: {
            args: Prisma.OpportunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          update: {
            args: Prisma.OpportunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          deleteMany: {
            args: Prisma.OpportunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpportunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OpportunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          aggregate: {
            args: Prisma.OpportunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpportunity>
          }
          groupBy: {
            args: Prisma.OpportunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpportunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpportunityCountArgs<ExtArgs>
            result: $Utils.Optional<OpportunityCountAggregateOutputType> | number
          }
        }
      }
      OpportunityApplication: {
        payload: Prisma.$OpportunityApplicationPayload<ExtArgs>
        fields: Prisma.OpportunityApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpportunityApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpportunityApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityApplicationPayload>
          }
          findFirst: {
            args: Prisma.OpportunityApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpportunityApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityApplicationPayload>
          }
          findMany: {
            args: Prisma.OpportunityApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityApplicationPayload>[]
          }
          create: {
            args: Prisma.OpportunityApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityApplicationPayload>
          }
          createMany: {
            args: Prisma.OpportunityApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpportunityApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityApplicationPayload>[]
          }
          delete: {
            args: Prisma.OpportunityApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityApplicationPayload>
          }
          update: {
            args: Prisma.OpportunityApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityApplicationPayload>
          }
          deleteMany: {
            args: Prisma.OpportunityApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpportunityApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OpportunityApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityApplicationPayload>
          }
          aggregate: {
            args: Prisma.OpportunityApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpportunityApplication>
          }
          groupBy: {
            args: Prisma.OpportunityApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpportunityApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpportunityApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<OpportunityApplicationCountAggregateOutputType> | number
          }
        }
      }
      PageView: {
        payload: Prisma.$PageViewPayload<ExtArgs>
        fields: Prisma.PageViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageViewPayload>
          }
          findFirst: {
            args: Prisma.PageViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageViewPayload>
          }
          findMany: {
            args: Prisma.PageViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageViewPayload>[]
          }
          create: {
            args: Prisma.PageViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageViewPayload>
          }
          createMany: {
            args: Prisma.PageViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageViewPayload>[]
          }
          delete: {
            args: Prisma.PageViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageViewPayload>
          }
          update: {
            args: Prisma.PageViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageViewPayload>
          }
          deleteMany: {
            args: Prisma.PageViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PageViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageViewPayload>
          }
          aggregate: {
            args: Prisma.PageViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePageView>
          }
          groupBy: {
            args: Prisma.PageViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageViewCountArgs<ExtArgs>
            result: $Utils.Optional<PageViewCountAggregateOutputType> | number
          }
        }
      }
      SearchQuery: {
        payload: Prisma.$SearchQueryPayload<ExtArgs>
        fields: Prisma.SearchQueryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchQueryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchQueryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          findFirst: {
            args: Prisma.SearchQueryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchQueryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          findMany: {
            args: Prisma.SearchQueryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>[]
          }
          create: {
            args: Prisma.SearchQueryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          createMany: {
            args: Prisma.SearchQueryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SearchQueryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>[]
          }
          delete: {
            args: Prisma.SearchQueryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          update: {
            args: Prisma.SearchQueryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          deleteMany: {
            args: Prisma.SearchQueryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchQueryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SearchQueryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          aggregate: {
            args: Prisma.SearchQueryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchQuery>
          }
          groupBy: {
            args: Prisma.SearchQueryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchQueryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchQueryCountArgs<ExtArgs>
            result: $Utils.Optional<SearchQueryCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      LifeOSProfile: {
        payload: Prisma.$LifeOSProfilePayload<ExtArgs>
        fields: Prisma.LifeOSProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LifeOSProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeOSProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LifeOSProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeOSProfilePayload>
          }
          findFirst: {
            args: Prisma.LifeOSProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeOSProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LifeOSProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeOSProfilePayload>
          }
          findMany: {
            args: Prisma.LifeOSProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeOSProfilePayload>[]
          }
          create: {
            args: Prisma.LifeOSProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeOSProfilePayload>
          }
          createMany: {
            args: Prisma.LifeOSProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LifeOSProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeOSProfilePayload>[]
          }
          delete: {
            args: Prisma.LifeOSProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeOSProfilePayload>
          }
          update: {
            args: Prisma.LifeOSProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeOSProfilePayload>
          }
          deleteMany: {
            args: Prisma.LifeOSProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LifeOSProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LifeOSProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeOSProfilePayload>
          }
          aggregate: {
            args: Prisma.LifeOSProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLifeOSProfile>
          }
          groupBy: {
            args: Prisma.LifeOSProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<LifeOSProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.LifeOSProfileCountArgs<ExtArgs>
            result: $Utils.Optional<LifeOSProfileCountAggregateOutputType> | number
          }
        }
      }
      Habit: {
        payload: Prisma.$HabitPayload<ExtArgs>
        fields: Prisma.HabitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HabitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HabitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>
          }
          findFirst: {
            args: Prisma.HabitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HabitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>
          }
          findMany: {
            args: Prisma.HabitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>[]
          }
          create: {
            args: Prisma.HabitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>
          }
          createMany: {
            args: Prisma.HabitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HabitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>[]
          }
          delete: {
            args: Prisma.HabitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>
          }
          update: {
            args: Prisma.HabitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>
          }
          deleteMany: {
            args: Prisma.HabitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HabitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HabitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>
          }
          aggregate: {
            args: Prisma.HabitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHabit>
          }
          groupBy: {
            args: Prisma.HabitGroupByArgs<ExtArgs>
            result: $Utils.Optional<HabitGroupByOutputType>[]
          }
          count: {
            args: Prisma.HabitCountArgs<ExtArgs>
            result: $Utils.Optional<HabitCountAggregateOutputType> | number
          }
        }
      }
      HabitCompletion: {
        payload: Prisma.$HabitCompletionPayload<ExtArgs>
        fields: Prisma.HabitCompletionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HabitCompletionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCompletionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HabitCompletionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCompletionPayload>
          }
          findFirst: {
            args: Prisma.HabitCompletionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCompletionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HabitCompletionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCompletionPayload>
          }
          findMany: {
            args: Prisma.HabitCompletionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCompletionPayload>[]
          }
          create: {
            args: Prisma.HabitCompletionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCompletionPayload>
          }
          createMany: {
            args: Prisma.HabitCompletionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HabitCompletionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCompletionPayload>[]
          }
          delete: {
            args: Prisma.HabitCompletionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCompletionPayload>
          }
          update: {
            args: Prisma.HabitCompletionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCompletionPayload>
          }
          deleteMany: {
            args: Prisma.HabitCompletionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HabitCompletionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HabitCompletionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCompletionPayload>
          }
          aggregate: {
            args: Prisma.HabitCompletionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHabitCompletion>
          }
          groupBy: {
            args: Prisma.HabitCompletionGroupByArgs<ExtArgs>
            result: $Utils.Optional<HabitCompletionGroupByOutputType>[]
          }
          count: {
            args: Prisma.HabitCompletionCountArgs<ExtArgs>
            result: $Utils.Optional<HabitCompletionCountAggregateOutputType> | number
          }
        }
      }
      Goal: {
        payload: Prisma.$GoalPayload<ExtArgs>
        fields: Prisma.GoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          findFirst: {
            args: Prisma.GoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          findMany: {
            args: Prisma.GoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          create: {
            args: Prisma.GoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          createMany: {
            args: Prisma.GoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[]
          }
          delete: {
            args: Prisma.GoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          update: {
            args: Prisma.GoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          deleteMany: {
            args: Prisma.GoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>
          }
          aggregate: {
            args: Prisma.GoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoal>
          }
          groupBy: {
            args: Prisma.GoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoalGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoalCountArgs<ExtArgs>
            result: $Utils.Optional<GoalCountAggregateOutputType> | number
          }
        }
      }
      GoalMilestone: {
        payload: Prisma.$GoalMilestonePayload<ExtArgs>
        fields: Prisma.GoalMilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoalMilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalMilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoalMilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalMilestonePayload>
          }
          findFirst: {
            args: Prisma.GoalMilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalMilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoalMilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalMilestonePayload>
          }
          findMany: {
            args: Prisma.GoalMilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalMilestonePayload>[]
          }
          create: {
            args: Prisma.GoalMilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalMilestonePayload>
          }
          createMany: {
            args: Prisma.GoalMilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoalMilestoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalMilestonePayload>[]
          }
          delete: {
            args: Prisma.GoalMilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalMilestonePayload>
          }
          update: {
            args: Prisma.GoalMilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalMilestonePayload>
          }
          deleteMany: {
            args: Prisma.GoalMilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoalMilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GoalMilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalMilestonePayload>
          }
          aggregate: {
            args: Prisma.GoalMilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoalMilestone>
          }
          groupBy: {
            args: Prisma.GoalMilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoalMilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoalMilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<GoalMilestoneCountAggregateOutputType> | number
          }
        }
      }
      GoalUpdate: {
        payload: Prisma.$GoalUpdatePayload<ExtArgs>
        fields: Prisma.GoalUpdateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoalUpdateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalUpdatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoalUpdateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalUpdatePayload>
          }
          findFirst: {
            args: Prisma.GoalUpdateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalUpdatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoalUpdateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalUpdatePayload>
          }
          findMany: {
            args: Prisma.GoalUpdateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalUpdatePayload>[]
          }
          create: {
            args: Prisma.GoalUpdateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalUpdatePayload>
          }
          createMany: {
            args: Prisma.GoalUpdateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoalUpdateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalUpdatePayload>[]
          }
          delete: {
            args: Prisma.GoalUpdateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalUpdatePayload>
          }
          update: {
            args: Prisma.GoalUpdateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalUpdatePayload>
          }
          deleteMany: {
            args: Prisma.GoalUpdateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoalUpdateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GoalUpdateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalUpdatePayload>
          }
          aggregate: {
            args: Prisma.GoalUpdateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoalUpdate>
          }
          groupBy: {
            args: Prisma.GoalUpdateGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoalUpdateGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoalUpdateCountArgs<ExtArgs>
            result: $Utils.Optional<GoalUpdateCountAggregateOutputType> | number
          }
        }
      }
      MeditationSession: {
        payload: Prisma.$MeditationSessionPayload<ExtArgs>
        fields: Prisma.MeditationSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeditationSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeditationSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationSessionPayload>
          }
          findFirst: {
            args: Prisma.MeditationSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeditationSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationSessionPayload>
          }
          findMany: {
            args: Prisma.MeditationSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationSessionPayload>[]
          }
          create: {
            args: Prisma.MeditationSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationSessionPayload>
          }
          createMany: {
            args: Prisma.MeditationSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeditationSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationSessionPayload>[]
          }
          delete: {
            args: Prisma.MeditationSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationSessionPayload>
          }
          update: {
            args: Prisma.MeditationSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationSessionPayload>
          }
          deleteMany: {
            args: Prisma.MeditationSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeditationSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MeditationSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationSessionPayload>
          }
          aggregate: {
            args: Prisma.MeditationSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeditationSession>
          }
          groupBy: {
            args: Prisma.MeditationSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeditationSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeditationSessionCountArgs<ExtArgs>
            result: $Utils.Optional<MeditationSessionCountAggregateOutputType> | number
          }
        }
      }
      MoodEntry: {
        payload: Prisma.$MoodEntryPayload<ExtArgs>
        fields: Prisma.MoodEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MoodEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MoodEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>
          }
          findFirst: {
            args: Prisma.MoodEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MoodEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>
          }
          findMany: {
            args: Prisma.MoodEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>[]
          }
          create: {
            args: Prisma.MoodEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>
          }
          createMany: {
            args: Prisma.MoodEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MoodEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>[]
          }
          delete: {
            args: Prisma.MoodEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>
          }
          update: {
            args: Prisma.MoodEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>
          }
          deleteMany: {
            args: Prisma.MoodEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MoodEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MoodEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodEntryPayload>
          }
          aggregate: {
            args: Prisma.MoodEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMoodEntry>
          }
          groupBy: {
            args: Prisma.MoodEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MoodEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MoodEntryCountArgs<ExtArgs>
            result: $Utils.Optional<MoodEntryCountAggregateOutputType> | number
          }
        }
      }
      Journal: {
        payload: Prisma.$JournalPayload<ExtArgs>
        fields: Prisma.JournalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          findFirst: {
            args: Prisma.JournalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          findMany: {
            args: Prisma.JournalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>[]
          }
          create: {
            args: Prisma.JournalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          createMany: {
            args: Prisma.JournalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>[]
          }
          delete: {
            args: Prisma.JournalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          update: {
            args: Prisma.JournalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          deleteMany: {
            args: Prisma.JournalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JournalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          aggregate: {
            args: Prisma.JournalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournal>
          }
          groupBy: {
            args: Prisma.JournalGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalCountArgs<ExtArgs>
            result: $Utils.Optional<JournalCountAggregateOutputType> | number
          }
        }
      }
      CalendarEvent: {
        payload: Prisma.$CalendarEventPayload<ExtArgs>
        fields: Prisma.CalendarEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          findFirst: {
            args: Prisma.CalendarEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          findMany: {
            args: Prisma.CalendarEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
          }
          create: {
            args: Prisma.CalendarEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          createMany: {
            args: Prisma.CalendarEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
          }
          delete: {
            args: Prisma.CalendarEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          update: {
            args: Prisma.CalendarEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          deleteMany: {
            args: Prisma.CalendarEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CalendarEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          aggregate: {
            args: Prisma.CalendarEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarEvent>
          }
          groupBy: {
            args: Prisma.CalendarEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarEventCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventCountAggregateOutputType> | number
          }
        }
      }
      EventAttendee: {
        payload: Prisma.$EventAttendeePayload<ExtArgs>
        fields: Prisma.EventAttendeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventAttendeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventAttendeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>
          }
          findFirst: {
            args: Prisma.EventAttendeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventAttendeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>
          }
          findMany: {
            args: Prisma.EventAttendeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>[]
          }
          create: {
            args: Prisma.EventAttendeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>
          }
          createMany: {
            args: Prisma.EventAttendeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventAttendeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>[]
          }
          delete: {
            args: Prisma.EventAttendeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>
          }
          update: {
            args: Prisma.EventAttendeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>
          }
          deleteMany: {
            args: Prisma.EventAttendeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventAttendeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventAttendeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventAttendeePayload>
          }
          aggregate: {
            args: Prisma.EventAttendeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventAttendee>
          }
          groupBy: {
            args: Prisma.EventAttendeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventAttendeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventAttendeeCountArgs<ExtArgs>
            result: $Utils.Optional<EventAttendeeCountAggregateOutputType> | number
          }
        }
      }
      FinancialTransaction: {
        payload: Prisma.$FinancialTransactionPayload<ExtArgs>
        fields: Prisma.FinancialTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
          }
          findFirst: {
            args: Prisma.FinancialTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
          }
          findMany: {
            args: Prisma.FinancialTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>[]
          }
          create: {
            args: Prisma.FinancialTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
          }
          createMany: {
            args: Prisma.FinancialTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinancialTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>[]
          }
          delete: {
            args: Prisma.FinancialTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
          }
          update: {
            args: Prisma.FinancialTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
          }
          deleteMany: {
            args: Prisma.FinancialTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FinancialTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialTransactionPayload>
          }
          aggregate: {
            args: Prisma.FinancialTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancialTransaction>
          }
          groupBy: {
            args: Prisma.FinancialTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancialTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancialTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<FinancialTransactionCountAggregateOutputType> | number
          }
        }
      }
      Budget: {
        payload: Prisma.$BudgetPayload<ExtArgs>
        fields: Prisma.BudgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findFirst: {
            args: Prisma.BudgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findMany: {
            args: Prisma.BudgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          create: {
            args: Prisma.BudgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          createMany: {
            args: Prisma.BudgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          delete: {
            args: Prisma.BudgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          update: {
            args: Prisma.BudgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          deleteMany: {
            args: Prisma.BudgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BudgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          aggregate: {
            args: Prisma.BudgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget>
          }
          groupBy: {
            args: Prisma.BudgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    stories: number
    projects: number
    comments: number
    opportunities: number
    calendarEvents: number
    eventAttendance: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stories?: boolean | UserCountOutputTypeCountStoriesArgs
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    opportunities?: boolean | UserCountOutputTypeCountOpportunitiesArgs
    calendarEvents?: boolean | UserCountOutputTypeCountCalendarEventsArgs
    eventAttendance?: boolean | UserCountOutputTypeCountEventAttendanceArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityApplicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCalendarEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventAttendeeWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    members: number
    stories: number
    opportunities: number
    calendarEvents: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ProjectCountOutputTypeCountMembersArgs
    stories?: boolean | ProjectCountOutputTypeCountStoriesArgs
    opportunities?: boolean | ProjectCountOutputTypeCountOpportunitiesArgs
    calendarEvents?: boolean | ProjectCountOutputTypeCountCalendarEventsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCalendarEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
  }


  /**
   * Count Type StoryCountOutputType
   */

  export type StoryCountOutputType = {
    comments: number
  }

  export type StoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | StoryCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryCountOutputType
     */
    select?: StoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type OpportunityCountOutputType
   */

  export type OpportunityCountOutputType = {
    applications: number
  }

  export type OpportunityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | OpportunityCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes
  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityCountOutputType
     */
    select?: OpportunityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityApplicationWhereInput
  }


  /**
   * Count Type LifeOSProfileCountOutputType
   */

  export type LifeOSProfileCountOutputType = {
    habits: number
    goals: number
    moodEntries: number
    meditations: number
    journals: number
    transactions: number
    budgets: number
  }

  export type LifeOSProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    habits?: boolean | LifeOSProfileCountOutputTypeCountHabitsArgs
    goals?: boolean | LifeOSProfileCountOutputTypeCountGoalsArgs
    moodEntries?: boolean | LifeOSProfileCountOutputTypeCountMoodEntriesArgs
    meditations?: boolean | LifeOSProfileCountOutputTypeCountMeditationsArgs
    journals?: boolean | LifeOSProfileCountOutputTypeCountJournalsArgs
    transactions?: boolean | LifeOSProfileCountOutputTypeCountTransactionsArgs
    budgets?: boolean | LifeOSProfileCountOutputTypeCountBudgetsArgs
  }

  // Custom InputTypes
  /**
   * LifeOSProfileCountOutputType without action
   */
  export type LifeOSProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeOSProfileCountOutputType
     */
    select?: LifeOSProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LifeOSProfileCountOutputType without action
   */
  export type LifeOSProfileCountOutputTypeCountHabitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitWhereInput
  }

  /**
   * LifeOSProfileCountOutputType without action
   */
  export type LifeOSProfileCountOutputTypeCountGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalWhereInput
  }

  /**
   * LifeOSProfileCountOutputType without action
   */
  export type LifeOSProfileCountOutputTypeCountMoodEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoodEntryWhereInput
  }

  /**
   * LifeOSProfileCountOutputType without action
   */
  export type LifeOSProfileCountOutputTypeCountMeditationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeditationSessionWhereInput
  }

  /**
   * LifeOSProfileCountOutputType without action
   */
  export type LifeOSProfileCountOutputTypeCountJournalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalWhereInput
  }

  /**
   * LifeOSProfileCountOutputType without action
   */
  export type LifeOSProfileCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialTransactionWhereInput
  }

  /**
   * LifeOSProfileCountOutputType without action
   */
  export type LifeOSProfileCountOutputTypeCountBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
  }


  /**
   * Count Type HabitCountOutputType
   */

  export type HabitCountOutputType = {
    completions: number
  }

  export type HabitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    completions?: boolean | HabitCountOutputTypeCountCompletionsArgs
  }

  // Custom InputTypes
  /**
   * HabitCountOutputType without action
   */
  export type HabitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCountOutputType
     */
    select?: HabitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HabitCountOutputType without action
   */
  export type HabitCountOutputTypeCountCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitCompletionWhereInput
  }


  /**
   * Count Type GoalCountOutputType
   */

  export type GoalCountOutputType = {
    milestones: number
    updates: number
  }

  export type GoalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    milestones?: boolean | GoalCountOutputTypeCountMilestonesArgs
    updates?: boolean | GoalCountOutputTypeCountUpdatesArgs
  }

  // Custom InputTypes
  /**
   * GoalCountOutputType without action
   */
  export type GoalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalCountOutputType
     */
    select?: GoalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GoalCountOutputType without action
   */
  export type GoalCountOutputTypeCountMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalMilestoneWhereInput
  }

  /**
   * GoalCountOutputType without action
   */
  export type GoalCountOutputTypeCountUpdatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalUpdateWhereInput
  }


  /**
   * Count Type CalendarEventCountOutputType
   */

  export type CalendarEventCountOutputType = {
    attendees: number
  }

  export type CalendarEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendees?: boolean | CalendarEventCountOutputTypeCountAttendeesArgs
  }

  // Custom InputTypes
  /**
   * CalendarEventCountOutputType without action
   */
  export type CalendarEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventCountOutputType
     */
    select?: CalendarEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CalendarEventCountOutputType without action
   */
  export type CalendarEventCountOutputTypeCountAttendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventAttendeeWhereInput
  }


  /**
   * Count Type BudgetCountOutputType
   */

  export type BudgetCountOutputType = {
    transactions: number
  }

  export type BudgetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | BudgetCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCountOutputType
     */
    select?: BudgetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialTransactionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    avatar: string | null
    bio: string | null
    location: string | null
    website: string | null
    emailVerified: Date | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    avatar: string | null
    bio: string | null
    location: string | null
    website: string | null
    emailVerified: Date | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    avatar: number
    bio: number
    location: number
    website: number
    emailVerified: number
    role: number
    createdAt: number
    updatedAt: number
    skills: number
    interests: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    bio?: true
    location?: true
    website?: true
    emailVerified?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    bio?: true
    location?: true
    website?: true
    emailVerified?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    bio?: true
    location?: true
    website?: true
    emailVerified?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    skills?: true
    interests?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    avatar: string | null
    bio: string | null
    location: string | null
    website: string | null
    emailVerified: Date | null
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    skills: string[]
    interests: string[]
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    bio?: boolean
    location?: boolean
    website?: boolean
    emailVerified?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    skills?: boolean
    interests?: boolean
    stories?: boolean | User$storiesArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    opportunities?: boolean | User$opportunitiesArgs<ExtArgs>
    lifeOSProfile?: boolean | User$lifeOSProfileArgs<ExtArgs>
    calendarEvents?: boolean | User$calendarEventsArgs<ExtArgs>
    eventAttendance?: boolean | User$eventAttendanceArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    bio?: boolean
    location?: boolean
    website?: boolean
    emailVerified?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    skills?: boolean
    interests?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    bio?: boolean
    location?: boolean
    website?: boolean
    emailVerified?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    skills?: boolean
    interests?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stories?: boolean | User$storiesArgs<ExtArgs>
    projects?: boolean | User$projectsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    opportunities?: boolean | User$opportunitiesArgs<ExtArgs>
    lifeOSProfile?: boolean | User$lifeOSProfileArgs<ExtArgs>
    calendarEvents?: boolean | User$calendarEventsArgs<ExtArgs>
    eventAttendance?: boolean | User$eventAttendanceArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      stories: Prisma.$StoryPayload<ExtArgs>[]
      projects: Prisma.$ProjectMemberPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      opportunities: Prisma.$OpportunityApplicationPayload<ExtArgs>[]
      lifeOSProfile: Prisma.$LifeOSProfilePayload<ExtArgs> | null
      calendarEvents: Prisma.$CalendarEventPayload<ExtArgs>[]
      eventAttendance: Prisma.$EventAttendeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      avatar: string | null
      bio: string | null
      location: string | null
      website: string | null
      emailVerified: Date | null
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
      skills: string[]
      interests: string[]
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stories<T extends User$storiesArgs<ExtArgs> = {}>(args?: Subset<T, User$storiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findMany"> | Null>
    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    opportunities<T extends User$opportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$opportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    lifeOSProfile<T extends User$lifeOSProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$lifeOSProfileArgs<ExtArgs>>): Prisma__LifeOSProfileClient<$Result.GetResult<Prisma.$LifeOSProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    calendarEvents<T extends User$calendarEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$calendarEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany"> | Null>
    eventAttendance<T extends User$eventAttendanceArgs<ExtArgs> = {}>(args?: Subset<T, User$eventAttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly location: FieldRef<"User", 'String'>
    readonly website: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly skills: FieldRef<"User", 'String[]'>
    readonly interests: FieldRef<"User", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.stories
   */
  export type User$storiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    where?: StoryWhereInput
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    cursor?: StoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.opportunities
   */
  export type User$opportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityApplication
     */
    select?: OpportunityApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityApplicationInclude<ExtArgs> | null
    where?: OpportunityApplicationWhereInput
    orderBy?: OpportunityApplicationOrderByWithRelationInput | OpportunityApplicationOrderByWithRelationInput[]
    cursor?: OpportunityApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityApplicationScalarFieldEnum | OpportunityApplicationScalarFieldEnum[]
  }

  /**
   * User.lifeOSProfile
   */
  export type User$lifeOSProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeOSProfile
     */
    select?: LifeOSProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeOSProfileInclude<ExtArgs> | null
    where?: LifeOSProfileWhereInput
  }

  /**
   * User.calendarEvents
   */
  export type User$calendarEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    cursor?: CalendarEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * User.eventAttendance
   */
  export type User$eventAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    where?: EventAttendeeWhereInput
    orderBy?: EventAttendeeOrderByWithRelationInput | EventAttendeeOrderByWithRelationInput[]
    cursor?: EventAttendeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventAttendeeScalarFieldEnum | EventAttendeeScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    status: $Enums.ProjectStatus | null
    visibility: $Enums.Visibility | null
    category: string | null
    location: string | null
    region: string | null
    coverImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    startDate: Date | null
    endDate: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    status: $Enums.ProjectStatus | null
    visibility: $Enums.Visibility | null
    category: string | null
    location: string | null
    region: string | null
    coverImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    startDate: Date | null
    endDate: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    title: number
    description: number
    content: number
    status: number
    visibility: number
    category: number
    tags: number
    location: number
    region: number
    coordinates: number
    coverImage: number
    images: number
    documents: number
    createdAt: number
    updatedAt: number
    startDate: number
    endDate: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    status?: true
    visibility?: true
    category?: true
    location?: true
    region?: true
    coverImage?: true
    createdAt?: true
    updatedAt?: true
    startDate?: true
    endDate?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    status?: true
    visibility?: true
    category?: true
    location?: true
    region?: true
    coverImage?: true
    createdAt?: true
    updatedAt?: true
    startDate?: true
    endDate?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    status?: true
    visibility?: true
    category?: true
    tags?: true
    location?: true
    region?: true
    coordinates?: true
    coverImage?: true
    images?: true
    documents?: true
    createdAt?: true
    updatedAt?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    title: string
    description: string
    content: string | null
    status: $Enums.ProjectStatus
    visibility: $Enums.Visibility
    category: string | null
    tags: string[]
    location: string | null
    region: string | null
    coordinates: JsonValue | null
    coverImage: string | null
    images: string[]
    documents: string[]
    createdAt: Date
    updatedAt: Date
    startDate: Date | null
    endDate: Date | null
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    status?: boolean
    visibility?: boolean
    category?: boolean
    tags?: boolean
    location?: boolean
    region?: boolean
    coordinates?: boolean
    coverImage?: boolean
    images?: boolean
    documents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startDate?: boolean
    endDate?: boolean
    members?: boolean | Project$membersArgs<ExtArgs>
    stories?: boolean | Project$storiesArgs<ExtArgs>
    opportunities?: boolean | Project$opportunitiesArgs<ExtArgs>
    calendarEvents?: boolean | Project$calendarEventsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    status?: boolean
    visibility?: boolean
    category?: boolean
    tags?: boolean
    location?: boolean
    region?: boolean
    coordinates?: boolean
    coverImage?: boolean
    images?: boolean
    documents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startDate?: boolean
    endDate?: boolean
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    status?: boolean
    visibility?: boolean
    category?: boolean
    tags?: boolean
    location?: boolean
    region?: boolean
    coordinates?: boolean
    coverImage?: boolean
    images?: boolean
    documents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startDate?: boolean
    endDate?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Project$membersArgs<ExtArgs>
    stories?: boolean | Project$storiesArgs<ExtArgs>
    opportunities?: boolean | Project$opportunitiesArgs<ExtArgs>
    calendarEvents?: boolean | Project$calendarEventsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      members: Prisma.$ProjectMemberPayload<ExtArgs>[]
      stories: Prisma.$StoryPayload<ExtArgs>[]
      opportunities: Prisma.$OpportunityPayload<ExtArgs>[]
      calendarEvents: Prisma.$CalendarEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      content: string | null
      status: $Enums.ProjectStatus
      visibility: $Enums.Visibility
      category: string | null
      tags: string[]
      location: string | null
      region: string | null
      coordinates: Prisma.JsonValue | null
      coverImage: string | null
      images: string[]
      documents: string[]
      createdAt: Date
      updatedAt: Date
      startDate: Date | null
      endDate: Date | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Project$membersArgs<ExtArgs> = {}>(args?: Subset<T, Project$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany"> | Null>
    stories<T extends Project$storiesArgs<ExtArgs> = {}>(args?: Subset<T, Project$storiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findMany"> | Null>
    opportunities<T extends Project$opportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, Project$opportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany"> | Null>
    calendarEvents<T extends Project$calendarEventsArgs<ExtArgs> = {}>(args?: Subset<T, Project$calendarEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly title: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly content: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'ProjectStatus'>
    readonly visibility: FieldRef<"Project", 'Visibility'>
    readonly category: FieldRef<"Project", 'String'>
    readonly tags: FieldRef<"Project", 'String[]'>
    readonly location: FieldRef<"Project", 'String'>
    readonly region: FieldRef<"Project", 'String'>
    readonly coordinates: FieldRef<"Project", 'Json'>
    readonly coverImage: FieldRef<"Project", 'String'>
    readonly images: FieldRef<"Project", 'String[]'>
    readonly documents: FieldRef<"Project", 'String[]'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.members
   */
  export type Project$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * Project.stories
   */
  export type Project$storiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    where?: StoryWhereInput
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    cursor?: StoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Project.opportunities
   */
  export type Project$opportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    cursor?: OpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Project.calendarEvents
   */
  export type Project$calendarEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    cursor?: CalendarEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMember
   */

  export type AggregateProjectMember = {
    _count: ProjectMemberCountAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  export type ProjectMemberMinAggregateOutputType = {
    id: string | null
    userId: string | null
    projectId: string | null
    role: $Enums.ProjectRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMemberMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    projectId: string | null
    role: $Enums.ProjectRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMemberCountAggregateOutputType = {
    id: number
    userId: number
    projectId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMemberMinAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMemberMaxAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMemberCountAggregateInputType = {
    id?: true
    userId?: true
    projectId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMember to aggregate.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMembers
    **/
    _count?: true | ProjectMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type GetProjectMemberAggregateType<T extends ProjectMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMember[P]>
      : GetScalarType<T[P], AggregateProjectMember[P]>
  }




  export type ProjectMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithAggregationInput | ProjectMemberOrderByWithAggregationInput[]
    by: ProjectMemberScalarFieldEnum[] | ProjectMemberScalarFieldEnum
    having?: ProjectMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMemberCountAggregateInputType | true
    _min?: ProjectMemberMinAggregateInputType
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type ProjectMemberGroupByOutputType = {
    id: string
    userId: string
    projectId: string
    role: $Enums.ProjectRole
    createdAt: Date
    updatedAt: Date
    _count: ProjectMemberCountAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  type GetProjectMemberGroupByPayload<T extends ProjectMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    projectId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectScalar = {
    id?: boolean
    userId?: boolean
    projectId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      projectId: string
      role: $Enums.ProjectRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectMember"]>
    composites: {}
  }

  type ProjectMemberGetPayload<S extends boolean | null | undefined | ProjectMemberDefaultArgs> = $Result.GetResult<Prisma.$ProjectMemberPayload, S>

  type ProjectMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectMemberCountAggregateInputType | true
    }

  export interface ProjectMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMember'], meta: { name: 'ProjectMember' } }
    /**
     * Find zero or one ProjectMember that matches the filter.
     * @param {ProjectMemberFindUniqueArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMemberFindUniqueArgs>(args: SelectSubset<T, ProjectMemberFindUniqueArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectMemberFindUniqueOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMemberFindFirstArgs>(args?: SelectSubset<T, ProjectMemberFindFirstArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany()
     * 
     * // Get first 10 ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectMemberFindManyArgs>(args?: SelectSubset<T, ProjectMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectMember.
     * @param {ProjectMemberCreateArgs} args - Arguments to create a ProjectMember.
     * @example
     * // Create one ProjectMember
     * const ProjectMember = await prisma.projectMember.create({
     *   data: {
     *     // ... data to create a ProjectMember
     *   }
     * })
     * 
     */
    create<T extends ProjectMemberCreateArgs>(args: SelectSubset<T, ProjectMemberCreateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectMembers.
     * @param {ProjectMemberCreateManyArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMemberCreateManyArgs>(args?: SelectSubset<T, ProjectMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectMembers and returns the data saved in the database.
     * @param {ProjectMemberCreateManyAndReturnArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectMember.
     * @param {ProjectMemberDeleteArgs} args - Arguments to delete one ProjectMember.
     * @example
     * // Delete one ProjectMember
     * const ProjectMember = await prisma.projectMember.delete({
     *   where: {
     *     // ... filter to delete one ProjectMember
     *   }
     * })
     * 
     */
    delete<T extends ProjectMemberDeleteArgs>(args: SelectSubset<T, ProjectMemberDeleteArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectMember.
     * @param {ProjectMemberUpdateArgs} args - Arguments to update one ProjectMember.
     * @example
     * // Update one ProjectMember
     * const projectMember = await prisma.projectMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMemberUpdateArgs>(args: SelectSubset<T, ProjectMemberUpdateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectMembers.
     * @param {ProjectMemberDeleteManyArgs} args - Arguments to filter ProjectMembers to delete.
     * @example
     * // Delete a few ProjectMembers
     * const { count } = await prisma.projectMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMemberDeleteManyArgs>(args?: SelectSubset<T, ProjectMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMemberUpdateManyArgs>(args: SelectSubset<T, ProjectMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectMember.
     * @param {ProjectMemberUpsertArgs} args - Arguments to update or create a ProjectMember.
     * @example
     * // Update or create a ProjectMember
     * const projectMember = await prisma.projectMember.upsert({
     *   create: {
     *     // ... data to create a ProjectMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMember we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMemberUpsertArgs>(args: SelectSubset<T, ProjectMemberUpsertArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberCountArgs} args - Arguments to filter ProjectMembers to count.
     * @example
     * // Count the number of ProjectMembers
     * const count = await prisma.projectMember.count({
     *   where: {
     *     // ... the filter for the ProjectMembers we want to count
     *   }
     * })
    **/
    count<T extends ProjectMemberCountArgs>(
      args?: Subset<T, ProjectMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMemberAggregateArgs>(args: Subset<T, ProjectMemberAggregateArgs>): Prisma.PrismaPromise<GetProjectMemberAggregateType<T>>

    /**
     * Group by ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMemberGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMember model
   */
  readonly fields: ProjectMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMember model
   */ 
  interface ProjectMemberFieldRefs {
    readonly id: FieldRef<"ProjectMember", 'String'>
    readonly userId: FieldRef<"ProjectMember", 'String'>
    readonly projectId: FieldRef<"ProjectMember", 'String'>
    readonly role: FieldRef<"ProjectMember", 'ProjectRole'>
    readonly createdAt: FieldRef<"ProjectMember", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMember findUnique
   */
  export type ProjectMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findUniqueOrThrow
   */
  export type ProjectMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findFirst
   */
  export type ProjectMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findFirstOrThrow
   */
  export type ProjectMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findMany
   */
  export type ProjectMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMembers to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember create
   */
  export type ProjectMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMember.
     */
    data: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
  }

  /**
   * ProjectMember createMany
   */
  export type ProjectMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectMember createManyAndReturn
   */
  export type ProjectMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember update
   */
  export type ProjectMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMember.
     */
    data: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
    /**
     * Choose, which ProjectMember to update.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember updateMany
   */
  export type ProjectMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
  }

  /**
   * ProjectMember upsert
   */
  export type ProjectMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMember to update in case it exists.
     */
    where: ProjectMemberWhereUniqueInput
    /**
     * In case the ProjectMember found by the `where` argument doesn't exist, create a new ProjectMember with this data.
     */
    create: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
    /**
     * In case the ProjectMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
  }

  /**
   * ProjectMember delete
   */
  export type ProjectMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter which ProjectMember to delete.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember deleteMany
   */
  export type ProjectMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMembers to delete
     */
    where?: ProjectMemberWhereInput
  }

  /**
   * ProjectMember without action
   */
  export type ProjectMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
  }


  /**
   * Model Story
   */

  export type AggregateStory = {
    _count: StoryCountAggregateOutputType | null
    _avg: StoryAvgAggregateOutputType | null
    _sum: StorySumAggregateOutputType | null
    _min: StoryMinAggregateOutputType | null
    _max: StoryMaxAggregateOutputType | null
  }

  export type StoryAvgAggregateOutputType = {
    viewCount: number | null
    shareCount: number | null
  }

  export type StorySumAggregateOutputType = {
    viewCount: number | null
    shareCount: number | null
  }

  export type StoryMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    excerpt: string | null
    status: $Enums.StoryStatus | null
    visibility: $Enums.Visibility | null
    category: string | null
    coverImage: string | null
    slug: string | null
    metaTitle: string | null
    metaDescription: string | null
    viewCount: number | null
    shareCount: number | null
    authorId: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
  }

  export type StoryMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    excerpt: string | null
    status: $Enums.StoryStatus | null
    visibility: $Enums.Visibility | null
    category: string | null
    coverImage: string | null
    slug: string | null
    metaTitle: string | null
    metaDescription: string | null
    viewCount: number | null
    shareCount: number | null
    authorId: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
  }

  export type StoryCountAggregateOutputType = {
    id: number
    title: number
    content: number
    excerpt: number
    status: number
    visibility: number
    category: number
    tags: number
    coverImage: number
    images: number
    slug: number
    metaTitle: number
    metaDescription: number
    viewCount: number
    shareCount: number
    authorId: number
    projectId: number
    createdAt: number
    updatedAt: number
    publishedAt: number
    _all: number
  }


  export type StoryAvgAggregateInputType = {
    viewCount?: true
    shareCount?: true
  }

  export type StorySumAggregateInputType = {
    viewCount?: true
    shareCount?: true
  }

  export type StoryMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    excerpt?: true
    status?: true
    visibility?: true
    category?: true
    coverImage?: true
    slug?: true
    metaTitle?: true
    metaDescription?: true
    viewCount?: true
    shareCount?: true
    authorId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
  }

  export type StoryMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    excerpt?: true
    status?: true
    visibility?: true
    category?: true
    coverImage?: true
    slug?: true
    metaTitle?: true
    metaDescription?: true
    viewCount?: true
    shareCount?: true
    authorId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
  }

  export type StoryCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    excerpt?: true
    status?: true
    visibility?: true
    category?: true
    tags?: true
    coverImage?: true
    images?: true
    slug?: true
    metaTitle?: true
    metaDescription?: true
    viewCount?: true
    shareCount?: true
    authorId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    _all?: true
  }

  export type StoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Story to aggregate.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stories
    **/
    _count?: true | StoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryMaxAggregateInputType
  }

  export type GetStoryAggregateType<T extends StoryAggregateArgs> = {
        [P in keyof T & keyof AggregateStory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStory[P]>
      : GetScalarType<T[P], AggregateStory[P]>
  }




  export type StoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryWhereInput
    orderBy?: StoryOrderByWithAggregationInput | StoryOrderByWithAggregationInput[]
    by: StoryScalarFieldEnum[] | StoryScalarFieldEnum
    having?: StoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryCountAggregateInputType | true
    _avg?: StoryAvgAggregateInputType
    _sum?: StorySumAggregateInputType
    _min?: StoryMinAggregateInputType
    _max?: StoryMaxAggregateInputType
  }

  export type StoryGroupByOutputType = {
    id: string
    title: string
    content: string
    excerpt: string | null
    status: $Enums.StoryStatus
    visibility: $Enums.Visibility
    category: string | null
    tags: string[]
    coverImage: string | null
    images: string[]
    slug: string
    metaTitle: string | null
    metaDescription: string | null
    viewCount: number
    shareCount: number
    authorId: string
    projectId: string | null
    createdAt: Date
    updatedAt: Date
    publishedAt: Date | null
    _count: StoryCountAggregateOutputType | null
    _avg: StoryAvgAggregateOutputType | null
    _sum: StorySumAggregateOutputType | null
    _min: StoryMinAggregateOutputType | null
    _max: StoryMaxAggregateOutputType | null
  }

  type GetStoryGroupByPayload<T extends StoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryGroupByOutputType[P]>
            : GetScalarType<T[P], StoryGroupByOutputType[P]>
        }
      >
    >


  export type StorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
    status?: boolean
    visibility?: boolean
    category?: boolean
    tags?: boolean
    coverImage?: boolean
    images?: boolean
    slug?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    viewCount?: boolean
    shareCount?: boolean
    authorId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Story$projectArgs<ExtArgs>
    comments?: boolean | Story$commentsArgs<ExtArgs>
    _count?: boolean | StoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["story"]>

  export type StorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
    status?: boolean
    visibility?: boolean
    category?: boolean
    tags?: boolean
    coverImage?: boolean
    images?: boolean
    slug?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    viewCount?: boolean
    shareCount?: boolean
    authorId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Story$projectArgs<ExtArgs>
  }, ExtArgs["result"]["story"]>

  export type StorySelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
    status?: boolean
    visibility?: boolean
    category?: boolean
    tags?: boolean
    coverImage?: boolean
    images?: boolean
    slug?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    viewCount?: boolean
    shareCount?: boolean
    authorId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
  }

  export type StoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Story$projectArgs<ExtArgs>
    comments?: boolean | Story$commentsArgs<ExtArgs>
    _count?: boolean | StoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Story$projectArgs<ExtArgs>
  }

  export type $StoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Story"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      excerpt: string | null
      status: $Enums.StoryStatus
      visibility: $Enums.Visibility
      category: string | null
      tags: string[]
      coverImage: string | null
      images: string[]
      slug: string
      metaTitle: string | null
      metaDescription: string | null
      viewCount: number
      shareCount: number
      authorId: string
      projectId: string | null
      createdAt: Date
      updatedAt: Date
      publishedAt: Date | null
    }, ExtArgs["result"]["story"]>
    composites: {}
  }

  type StoryGetPayload<S extends boolean | null | undefined | StoryDefaultArgs> = $Result.GetResult<Prisma.$StoryPayload, S>

  type StoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoryCountAggregateInputType | true
    }

  export interface StoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Story'], meta: { name: 'Story' } }
    /**
     * Find zero or one Story that matches the filter.
     * @param {StoryFindUniqueArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryFindUniqueArgs>(args: SelectSubset<T, StoryFindUniqueArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Story that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoryFindUniqueOrThrowArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Story that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryFindFirstArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryFindFirstArgs>(args?: SelectSubset<T, StoryFindFirstArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Story that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryFindFirstOrThrowArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Stories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stories
     * const stories = await prisma.story.findMany()
     * 
     * // Get first 10 Stories
     * const stories = await prisma.story.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyWithIdOnly = await prisma.story.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryFindManyArgs>(args?: SelectSubset<T, StoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Story.
     * @param {StoryCreateArgs} args - Arguments to create a Story.
     * @example
     * // Create one Story
     * const Story = await prisma.story.create({
     *   data: {
     *     // ... data to create a Story
     *   }
     * })
     * 
     */
    create<T extends StoryCreateArgs>(args: SelectSubset<T, StoryCreateArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Stories.
     * @param {StoryCreateManyArgs} args - Arguments to create many Stories.
     * @example
     * // Create many Stories
     * const story = await prisma.story.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryCreateManyArgs>(args?: SelectSubset<T, StoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stories and returns the data saved in the database.
     * @param {StoryCreateManyAndReturnArgs} args - Arguments to create many Stories.
     * @example
     * // Create many Stories
     * const story = await prisma.story.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stories and only return the `id`
     * const storyWithIdOnly = await prisma.story.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Story.
     * @param {StoryDeleteArgs} args - Arguments to delete one Story.
     * @example
     * // Delete one Story
     * const Story = await prisma.story.delete({
     *   where: {
     *     // ... filter to delete one Story
     *   }
     * })
     * 
     */
    delete<T extends StoryDeleteArgs>(args: SelectSubset<T, StoryDeleteArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Story.
     * @param {StoryUpdateArgs} args - Arguments to update one Story.
     * @example
     * // Update one Story
     * const story = await prisma.story.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryUpdateArgs>(args: SelectSubset<T, StoryUpdateArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Stories.
     * @param {StoryDeleteManyArgs} args - Arguments to filter Stories to delete.
     * @example
     * // Delete a few Stories
     * const { count } = await prisma.story.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryDeleteManyArgs>(args?: SelectSubset<T, StoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stories
     * const story = await prisma.story.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryUpdateManyArgs>(args: SelectSubset<T, StoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Story.
     * @param {StoryUpsertArgs} args - Arguments to update or create a Story.
     * @example
     * // Update or create a Story
     * const story = await prisma.story.upsert({
     *   create: {
     *     // ... data to create a Story
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Story we want to update
     *   }
     * })
     */
    upsert<T extends StoryUpsertArgs>(args: SelectSubset<T, StoryUpsertArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Stories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryCountArgs} args - Arguments to filter Stories to count.
     * @example
     * // Count the number of Stories
     * const count = await prisma.story.count({
     *   where: {
     *     // ... the filter for the Stories we want to count
     *   }
     * })
    **/
    count<T extends StoryCountArgs>(
      args?: Subset<T, StoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Story.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryAggregateArgs>(args: Subset<T, StoryAggregateArgs>): Prisma.PrismaPromise<GetStoryAggregateType<T>>

    /**
     * Group by Story.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryGroupByArgs['orderBy'] }
        : { orderBy?: StoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Story model
   */
  readonly fields: StoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Story.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends Story$projectArgs<ExtArgs> = {}>(args?: Subset<T, Story$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comments<T extends Story$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Story$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Story model
   */ 
  interface StoryFieldRefs {
    readonly id: FieldRef<"Story", 'String'>
    readonly title: FieldRef<"Story", 'String'>
    readonly content: FieldRef<"Story", 'String'>
    readonly excerpt: FieldRef<"Story", 'String'>
    readonly status: FieldRef<"Story", 'StoryStatus'>
    readonly visibility: FieldRef<"Story", 'Visibility'>
    readonly category: FieldRef<"Story", 'String'>
    readonly tags: FieldRef<"Story", 'String[]'>
    readonly coverImage: FieldRef<"Story", 'String'>
    readonly images: FieldRef<"Story", 'String[]'>
    readonly slug: FieldRef<"Story", 'String'>
    readonly metaTitle: FieldRef<"Story", 'String'>
    readonly metaDescription: FieldRef<"Story", 'String'>
    readonly viewCount: FieldRef<"Story", 'Int'>
    readonly shareCount: FieldRef<"Story", 'Int'>
    readonly authorId: FieldRef<"Story", 'String'>
    readonly projectId: FieldRef<"Story", 'String'>
    readonly createdAt: FieldRef<"Story", 'DateTime'>
    readonly updatedAt: FieldRef<"Story", 'DateTime'>
    readonly publishedAt: FieldRef<"Story", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Story findUnique
   */
  export type StoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story findUniqueOrThrow
   */
  export type StoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story findFirst
   */
  export type StoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stories.
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stories.
     */
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Story findFirstOrThrow
   */
  export type StoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stories.
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stories.
     */
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Story findMany
   */
  export type StoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Stories to fetch.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stories.
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Story create
   */
  export type StoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Story.
     */
    data: XOR<StoryCreateInput, StoryUncheckedCreateInput>
  }

  /**
   * Story createMany
   */
  export type StoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stories.
     */
    data: StoryCreateManyInput | StoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Story createManyAndReturn
   */
  export type StoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Stories.
     */
    data: StoryCreateManyInput | StoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Story update
   */
  export type StoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Story.
     */
    data: XOR<StoryUpdateInput, StoryUncheckedUpdateInput>
    /**
     * Choose, which Story to update.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story updateMany
   */
  export type StoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stories.
     */
    data: XOR<StoryUpdateManyMutationInput, StoryUncheckedUpdateManyInput>
    /**
     * Filter which Stories to update
     */
    where?: StoryWhereInput
  }

  /**
   * Story upsert
   */
  export type StoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Story to update in case it exists.
     */
    where: StoryWhereUniqueInput
    /**
     * In case the Story found by the `where` argument doesn't exist, create a new Story with this data.
     */
    create: XOR<StoryCreateInput, StoryUncheckedCreateInput>
    /**
     * In case the Story was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryUpdateInput, StoryUncheckedUpdateInput>
  }

  /**
   * Story delete
   */
  export type StoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter which Story to delete.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story deleteMany
   */
  export type StoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stories to delete
     */
    where?: StoryWhereInput
  }

  /**
   * Story.project
   */
  export type Story$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Story.comments
   */
  export type Story$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Story without action
   */
  export type StoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    status: $Enums.CommentStatus | null
    authorId: string | null
    storyId: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    status: $Enums.CommentStatus | null
    authorId: string | null
    storyId: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    status: number
    authorId: number
    storyId: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    status?: true
    authorId?: true
    storyId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    status?: true
    authorId?: true
    storyId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    status?: true
    authorId?: true
    storyId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    content: string
    status: $Enums.CommentStatus
    authorId: string
    storyId: string
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    status?: boolean
    authorId?: boolean
    storyId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    story?: boolean | StoryDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    status?: boolean
    authorId?: boolean
    storyId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    story?: boolean | StoryDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    status?: boolean
    authorId?: boolean
    storyId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    story?: boolean | StoryDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    story?: boolean | StoryDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      story: Prisma.$StoryPayload<ExtArgs>
      parent: Prisma.$CommentPayload<ExtArgs> | null
      replies: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      status: $Enums.CommentStatus
      authorId: string
      storyId: string
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    story<T extends StoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoryDefaultArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends Comment$parentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly status: FieldRef<"Comment", 'CommentStatus'>
    readonly authorId: FieldRef<"Comment", 'String'>
    readonly storyId: FieldRef<"Comment", 'String'>
    readonly parentId: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment.parent
   */
  export type Comment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Opportunity
   */

  export type AggregateOpportunity = {
    _count: OpportunityCountAggregateOutputType | null
    _min: OpportunityMinAggregateOutputType | null
    _max: OpportunityMaxAggregateOutputType | null
  }

  export type OpportunityMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    type: $Enums.OpportunityType | null
    status: $Enums.OpportunityStatus | null
    category: string | null
    timeCommitment: string | null
    location: string | null
    remote: boolean | null
    isPaid: boolean | null
    compensation: string | null
    deadline: Date | null
    startDate: Date | null
    duration: string | null
    coverImage: string | null
    projectId: string | null
    contactEmail: string | null
    contactPhone: string | null
    applicationUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OpportunityMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    type: $Enums.OpportunityType | null
    status: $Enums.OpportunityStatus | null
    category: string | null
    timeCommitment: string | null
    location: string | null
    remote: boolean | null
    isPaid: boolean | null
    compensation: string | null
    deadline: Date | null
    startDate: Date | null
    duration: string | null
    coverImage: string | null
    projectId: string | null
    contactEmail: string | null
    contactPhone: string | null
    applicationUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OpportunityCountAggregateOutputType = {
    id: number
    title: number
    description: number
    content: number
    type: number
    status: number
    category: number
    tags: number
    skills: number
    timeCommitment: number
    location: number
    remote: number
    isPaid: number
    compensation: number
    deadline: number
    startDate: number
    duration: number
    coverImage: number
    images: number
    projectId: number
    contactEmail: number
    contactPhone: number
    applicationUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OpportunityMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    type?: true
    status?: true
    category?: true
    timeCommitment?: true
    location?: true
    remote?: true
    isPaid?: true
    compensation?: true
    deadline?: true
    startDate?: true
    duration?: true
    coverImage?: true
    projectId?: true
    contactEmail?: true
    contactPhone?: true
    applicationUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OpportunityMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    type?: true
    status?: true
    category?: true
    timeCommitment?: true
    location?: true
    remote?: true
    isPaid?: true
    compensation?: true
    deadline?: true
    startDate?: true
    duration?: true
    coverImage?: true
    projectId?: true
    contactEmail?: true
    contactPhone?: true
    applicationUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OpportunityCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    type?: true
    status?: true
    category?: true
    tags?: true
    skills?: true
    timeCommitment?: true
    location?: true
    remote?: true
    isPaid?: true
    compensation?: true
    deadline?: true
    startDate?: true
    duration?: true
    coverImage?: true
    images?: true
    projectId?: true
    contactEmail?: true
    contactPhone?: true
    applicationUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OpportunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Opportunity to aggregate.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Opportunities
    **/
    _count?: true | OpportunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpportunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpportunityMaxAggregateInputType
  }

  export type GetOpportunityAggregateType<T extends OpportunityAggregateArgs> = {
        [P in keyof T & keyof AggregateOpportunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpportunity[P]>
      : GetScalarType<T[P], AggregateOpportunity[P]>
  }




  export type OpportunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithAggregationInput | OpportunityOrderByWithAggregationInput[]
    by: OpportunityScalarFieldEnum[] | OpportunityScalarFieldEnum
    having?: OpportunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpportunityCountAggregateInputType | true
    _min?: OpportunityMinAggregateInputType
    _max?: OpportunityMaxAggregateInputType
  }

  export type OpportunityGroupByOutputType = {
    id: string
    title: string
    description: string
    content: string | null
    type: $Enums.OpportunityType
    status: $Enums.OpportunityStatus
    category: string | null
    tags: string[]
    skills: string[]
    timeCommitment: string | null
    location: string | null
    remote: boolean
    isPaid: boolean
    compensation: string | null
    deadline: Date | null
    startDate: Date | null
    duration: string | null
    coverImage: string | null
    images: string[]
    projectId: string | null
    contactEmail: string | null
    contactPhone: string | null
    applicationUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: OpportunityCountAggregateOutputType | null
    _min: OpportunityMinAggregateOutputType | null
    _max: OpportunityMaxAggregateOutputType | null
  }

  type GetOpportunityGroupByPayload<T extends OpportunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpportunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpportunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpportunityGroupByOutputType[P]>
            : GetScalarType<T[P], OpportunityGroupByOutputType[P]>
        }
      >
    >


  export type OpportunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    type?: boolean
    status?: boolean
    category?: boolean
    tags?: boolean
    skills?: boolean
    timeCommitment?: boolean
    location?: boolean
    remote?: boolean
    isPaid?: boolean
    compensation?: boolean
    deadline?: boolean
    startDate?: boolean
    duration?: boolean
    coverImage?: boolean
    images?: boolean
    projectId?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    applicationUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | Opportunity$projectArgs<ExtArgs>
    applications?: boolean | Opportunity$applicationsArgs<ExtArgs>
    _count?: boolean | OpportunityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    type?: boolean
    status?: boolean
    category?: boolean
    tags?: boolean
    skills?: boolean
    timeCommitment?: boolean
    location?: boolean
    remote?: boolean
    isPaid?: boolean
    compensation?: boolean
    deadline?: boolean
    startDate?: boolean
    duration?: boolean
    coverImage?: boolean
    images?: boolean
    projectId?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    applicationUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | Opportunity$projectArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    type?: boolean
    status?: boolean
    category?: boolean
    tags?: boolean
    skills?: boolean
    timeCommitment?: boolean
    location?: boolean
    remote?: boolean
    isPaid?: boolean
    compensation?: boolean
    deadline?: boolean
    startDate?: boolean
    duration?: boolean
    coverImage?: boolean
    images?: boolean
    projectId?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    applicationUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OpportunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Opportunity$projectArgs<ExtArgs>
    applications?: boolean | Opportunity$applicationsArgs<ExtArgs>
    _count?: boolean | OpportunityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OpportunityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Opportunity$projectArgs<ExtArgs>
  }

  export type $OpportunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Opportunity"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
      applications: Prisma.$OpportunityApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      content: string | null
      type: $Enums.OpportunityType
      status: $Enums.OpportunityStatus
      category: string | null
      tags: string[]
      skills: string[]
      timeCommitment: string | null
      location: string | null
      remote: boolean
      isPaid: boolean
      compensation: string | null
      deadline: Date | null
      startDate: Date | null
      duration: string | null
      coverImage: string | null
      images: string[]
      projectId: string | null
      contactEmail: string | null
      contactPhone: string | null
      applicationUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["opportunity"]>
    composites: {}
  }

  type OpportunityGetPayload<S extends boolean | null | undefined | OpportunityDefaultArgs> = $Result.GetResult<Prisma.$OpportunityPayload, S>

  type OpportunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OpportunityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OpportunityCountAggregateInputType | true
    }

  export interface OpportunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Opportunity'], meta: { name: 'Opportunity' } }
    /**
     * Find zero or one Opportunity that matches the filter.
     * @param {OpportunityFindUniqueArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpportunityFindUniqueArgs>(args: SelectSubset<T, OpportunityFindUniqueArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Opportunity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OpportunityFindUniqueOrThrowArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpportunityFindUniqueOrThrowArgs>(args: SelectSubset<T, OpportunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Opportunity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindFirstArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpportunityFindFirstArgs>(args?: SelectSubset<T, OpportunityFindFirstArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Opportunity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindFirstOrThrowArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpportunityFindFirstOrThrowArgs>(args?: SelectSubset<T, OpportunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Opportunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Opportunities
     * const opportunities = await prisma.opportunity.findMany()
     * 
     * // Get first 10 Opportunities
     * const opportunities = await prisma.opportunity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpportunityFindManyArgs>(args?: SelectSubset<T, OpportunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Opportunity.
     * @param {OpportunityCreateArgs} args - Arguments to create a Opportunity.
     * @example
     * // Create one Opportunity
     * const Opportunity = await prisma.opportunity.create({
     *   data: {
     *     // ... data to create a Opportunity
     *   }
     * })
     * 
     */
    create<T extends OpportunityCreateArgs>(args: SelectSubset<T, OpportunityCreateArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Opportunities.
     * @param {OpportunityCreateManyArgs} args - Arguments to create many Opportunities.
     * @example
     * // Create many Opportunities
     * const opportunity = await prisma.opportunity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpportunityCreateManyArgs>(args?: SelectSubset<T, OpportunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Opportunities and returns the data saved in the database.
     * @param {OpportunityCreateManyAndReturnArgs} args - Arguments to create many Opportunities.
     * @example
     * // Create many Opportunities
     * const opportunity = await prisma.opportunity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Opportunities and only return the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpportunityCreateManyAndReturnArgs>(args?: SelectSubset<T, OpportunityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Opportunity.
     * @param {OpportunityDeleteArgs} args - Arguments to delete one Opportunity.
     * @example
     * // Delete one Opportunity
     * const Opportunity = await prisma.opportunity.delete({
     *   where: {
     *     // ... filter to delete one Opportunity
     *   }
     * })
     * 
     */
    delete<T extends OpportunityDeleteArgs>(args: SelectSubset<T, OpportunityDeleteArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Opportunity.
     * @param {OpportunityUpdateArgs} args - Arguments to update one Opportunity.
     * @example
     * // Update one Opportunity
     * const opportunity = await prisma.opportunity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpportunityUpdateArgs>(args: SelectSubset<T, OpportunityUpdateArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Opportunities.
     * @param {OpportunityDeleteManyArgs} args - Arguments to filter Opportunities to delete.
     * @example
     * // Delete a few Opportunities
     * const { count } = await prisma.opportunity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpportunityDeleteManyArgs>(args?: SelectSubset<T, OpportunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Opportunities
     * const opportunity = await prisma.opportunity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpportunityUpdateManyArgs>(args: SelectSubset<T, OpportunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Opportunity.
     * @param {OpportunityUpsertArgs} args - Arguments to update or create a Opportunity.
     * @example
     * // Update or create a Opportunity
     * const opportunity = await prisma.opportunity.upsert({
     *   create: {
     *     // ... data to create a Opportunity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Opportunity we want to update
     *   }
     * })
     */
    upsert<T extends OpportunityUpsertArgs>(args: SelectSubset<T, OpportunityUpsertArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityCountArgs} args - Arguments to filter Opportunities to count.
     * @example
     * // Count the number of Opportunities
     * const count = await prisma.opportunity.count({
     *   where: {
     *     // ... the filter for the Opportunities we want to count
     *   }
     * })
    **/
    count<T extends OpportunityCountArgs>(
      args?: Subset<T, OpportunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpportunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Opportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpportunityAggregateArgs>(args: Subset<T, OpportunityAggregateArgs>): Prisma.PrismaPromise<GetOpportunityAggregateType<T>>

    /**
     * Group by Opportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpportunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpportunityGroupByArgs['orderBy'] }
        : { orderBy?: OpportunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpportunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpportunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Opportunity model
   */
  readonly fields: OpportunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Opportunity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpportunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends Opportunity$projectArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    applications<T extends Opportunity$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Opportunity model
   */ 
  interface OpportunityFieldRefs {
    readonly id: FieldRef<"Opportunity", 'String'>
    readonly title: FieldRef<"Opportunity", 'String'>
    readonly description: FieldRef<"Opportunity", 'String'>
    readonly content: FieldRef<"Opportunity", 'String'>
    readonly type: FieldRef<"Opportunity", 'OpportunityType'>
    readonly status: FieldRef<"Opportunity", 'OpportunityStatus'>
    readonly category: FieldRef<"Opportunity", 'String'>
    readonly tags: FieldRef<"Opportunity", 'String[]'>
    readonly skills: FieldRef<"Opportunity", 'String[]'>
    readonly timeCommitment: FieldRef<"Opportunity", 'String'>
    readonly location: FieldRef<"Opportunity", 'String'>
    readonly remote: FieldRef<"Opportunity", 'Boolean'>
    readonly isPaid: FieldRef<"Opportunity", 'Boolean'>
    readonly compensation: FieldRef<"Opportunity", 'String'>
    readonly deadline: FieldRef<"Opportunity", 'DateTime'>
    readonly startDate: FieldRef<"Opportunity", 'DateTime'>
    readonly duration: FieldRef<"Opportunity", 'String'>
    readonly coverImage: FieldRef<"Opportunity", 'String'>
    readonly images: FieldRef<"Opportunity", 'String[]'>
    readonly projectId: FieldRef<"Opportunity", 'String'>
    readonly contactEmail: FieldRef<"Opportunity", 'String'>
    readonly contactPhone: FieldRef<"Opportunity", 'String'>
    readonly applicationUrl: FieldRef<"Opportunity", 'String'>
    readonly createdAt: FieldRef<"Opportunity", 'DateTime'>
    readonly updatedAt: FieldRef<"Opportunity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Opportunity findUnique
   */
  export type OpportunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity findUniqueOrThrow
   */
  export type OpportunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity findFirst
   */
  export type OpportunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Opportunities.
     */
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Opportunity findFirstOrThrow
   */
  export type OpportunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Opportunities.
     */
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Opportunity findMany
   */
  export type OpportunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunities to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Opportunity create
   */
  export type OpportunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The data needed to create a Opportunity.
     */
    data: XOR<OpportunityCreateInput, OpportunityUncheckedCreateInput>
  }

  /**
   * Opportunity createMany
   */
  export type OpportunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Opportunities.
     */
    data: OpportunityCreateManyInput | OpportunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Opportunity createManyAndReturn
   */
  export type OpportunityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Opportunities.
     */
    data: OpportunityCreateManyInput | OpportunityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Opportunity update
   */
  export type OpportunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The data needed to update a Opportunity.
     */
    data: XOR<OpportunityUpdateInput, OpportunityUncheckedUpdateInput>
    /**
     * Choose, which Opportunity to update.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity updateMany
   */
  export type OpportunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Opportunities.
     */
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyInput>
    /**
     * Filter which Opportunities to update
     */
    where?: OpportunityWhereInput
  }

  /**
   * Opportunity upsert
   */
  export type OpportunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The filter to search for the Opportunity to update in case it exists.
     */
    where: OpportunityWhereUniqueInput
    /**
     * In case the Opportunity found by the `where` argument doesn't exist, create a new Opportunity with this data.
     */
    create: XOR<OpportunityCreateInput, OpportunityUncheckedCreateInput>
    /**
     * In case the Opportunity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpportunityUpdateInput, OpportunityUncheckedUpdateInput>
  }

  /**
   * Opportunity delete
   */
  export type OpportunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter which Opportunity to delete.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity deleteMany
   */
  export type OpportunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Opportunities to delete
     */
    where?: OpportunityWhereInput
  }

  /**
   * Opportunity.project
   */
  export type Opportunity$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Opportunity.applications
   */
  export type Opportunity$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityApplication
     */
    select?: OpportunityApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityApplicationInclude<ExtArgs> | null
    where?: OpportunityApplicationWhereInput
    orderBy?: OpportunityApplicationOrderByWithRelationInput | OpportunityApplicationOrderByWithRelationInput[]
    cursor?: OpportunityApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityApplicationScalarFieldEnum | OpportunityApplicationScalarFieldEnum[]
  }

  /**
   * Opportunity without action
   */
  export type OpportunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
  }


  /**
   * Model OpportunityApplication
   */

  export type AggregateOpportunityApplication = {
    _count: OpportunityApplicationCountAggregateOutputType | null
    _min: OpportunityApplicationMinAggregateOutputType | null
    _max: OpportunityApplicationMaxAggregateOutputType | null
  }

  export type OpportunityApplicationMinAggregateOutputType = {
    id: string | null
    message: string | null
    resume: string | null
    portfolio: string | null
    status: $Enums.ApplicationStatus | null
    userId: string | null
    opportunityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OpportunityApplicationMaxAggregateOutputType = {
    id: string | null
    message: string | null
    resume: string | null
    portfolio: string | null
    status: $Enums.ApplicationStatus | null
    userId: string | null
    opportunityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OpportunityApplicationCountAggregateOutputType = {
    id: number
    message: number
    resume: number
    portfolio: number
    status: number
    userId: number
    opportunityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OpportunityApplicationMinAggregateInputType = {
    id?: true
    message?: true
    resume?: true
    portfolio?: true
    status?: true
    userId?: true
    opportunityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OpportunityApplicationMaxAggregateInputType = {
    id?: true
    message?: true
    resume?: true
    portfolio?: true
    status?: true
    userId?: true
    opportunityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OpportunityApplicationCountAggregateInputType = {
    id?: true
    message?: true
    resume?: true
    portfolio?: true
    status?: true
    userId?: true
    opportunityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OpportunityApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpportunityApplication to aggregate.
     */
    where?: OpportunityApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpportunityApplications to fetch.
     */
    orderBy?: OpportunityApplicationOrderByWithRelationInput | OpportunityApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpportunityApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpportunityApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpportunityApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OpportunityApplications
    **/
    _count?: true | OpportunityApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpportunityApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpportunityApplicationMaxAggregateInputType
  }

  export type GetOpportunityApplicationAggregateType<T extends OpportunityApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateOpportunityApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpportunityApplication[P]>
      : GetScalarType<T[P], AggregateOpportunityApplication[P]>
  }




  export type OpportunityApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityApplicationWhereInput
    orderBy?: OpportunityApplicationOrderByWithAggregationInput | OpportunityApplicationOrderByWithAggregationInput[]
    by: OpportunityApplicationScalarFieldEnum[] | OpportunityApplicationScalarFieldEnum
    having?: OpportunityApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpportunityApplicationCountAggregateInputType | true
    _min?: OpportunityApplicationMinAggregateInputType
    _max?: OpportunityApplicationMaxAggregateInputType
  }

  export type OpportunityApplicationGroupByOutputType = {
    id: string
    message: string
    resume: string | null
    portfolio: string | null
    status: $Enums.ApplicationStatus
    userId: string
    opportunityId: string
    createdAt: Date
    updatedAt: Date
    _count: OpportunityApplicationCountAggregateOutputType | null
    _min: OpportunityApplicationMinAggregateOutputType | null
    _max: OpportunityApplicationMaxAggregateOutputType | null
  }

  type GetOpportunityApplicationGroupByPayload<T extends OpportunityApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpportunityApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpportunityApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpportunityApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], OpportunityApplicationGroupByOutputType[P]>
        }
      >
    >


  export type OpportunityApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    resume?: boolean
    portfolio?: boolean
    status?: boolean
    userId?: boolean
    opportunityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunityApplication"]>

  export type OpportunityApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    resume?: boolean
    portfolio?: boolean
    status?: boolean
    userId?: boolean
    opportunityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunityApplication"]>

  export type OpportunityApplicationSelectScalar = {
    id?: boolean
    message?: boolean
    resume?: boolean
    portfolio?: boolean
    status?: boolean
    userId?: boolean
    opportunityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OpportunityApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }
  export type OpportunityApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }

  export type $OpportunityApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OpportunityApplication"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      opportunity: Prisma.$OpportunityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      message: string
      resume: string | null
      portfolio: string | null
      status: $Enums.ApplicationStatus
      userId: string
      opportunityId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["opportunityApplication"]>
    composites: {}
  }

  type OpportunityApplicationGetPayload<S extends boolean | null | undefined | OpportunityApplicationDefaultArgs> = $Result.GetResult<Prisma.$OpportunityApplicationPayload, S>

  type OpportunityApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OpportunityApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OpportunityApplicationCountAggregateInputType | true
    }

  export interface OpportunityApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OpportunityApplication'], meta: { name: 'OpportunityApplication' } }
    /**
     * Find zero or one OpportunityApplication that matches the filter.
     * @param {OpportunityApplicationFindUniqueArgs} args - Arguments to find a OpportunityApplication
     * @example
     * // Get one OpportunityApplication
     * const opportunityApplication = await prisma.opportunityApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpportunityApplicationFindUniqueArgs>(args: SelectSubset<T, OpportunityApplicationFindUniqueArgs<ExtArgs>>): Prisma__OpportunityApplicationClient<$Result.GetResult<Prisma.$OpportunityApplicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OpportunityApplication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OpportunityApplicationFindUniqueOrThrowArgs} args - Arguments to find a OpportunityApplication
     * @example
     * // Get one OpportunityApplication
     * const opportunityApplication = await prisma.opportunityApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpportunityApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, OpportunityApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpportunityApplicationClient<$Result.GetResult<Prisma.$OpportunityApplicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OpportunityApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityApplicationFindFirstArgs} args - Arguments to find a OpportunityApplication
     * @example
     * // Get one OpportunityApplication
     * const opportunityApplication = await prisma.opportunityApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpportunityApplicationFindFirstArgs>(args?: SelectSubset<T, OpportunityApplicationFindFirstArgs<ExtArgs>>): Prisma__OpportunityApplicationClient<$Result.GetResult<Prisma.$OpportunityApplicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OpportunityApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityApplicationFindFirstOrThrowArgs} args - Arguments to find a OpportunityApplication
     * @example
     * // Get one OpportunityApplication
     * const opportunityApplication = await prisma.opportunityApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpportunityApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, OpportunityApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpportunityApplicationClient<$Result.GetResult<Prisma.$OpportunityApplicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OpportunityApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OpportunityApplications
     * const opportunityApplications = await prisma.opportunityApplication.findMany()
     * 
     * // Get first 10 OpportunityApplications
     * const opportunityApplications = await prisma.opportunityApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const opportunityApplicationWithIdOnly = await prisma.opportunityApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpportunityApplicationFindManyArgs>(args?: SelectSubset<T, OpportunityApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityApplicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OpportunityApplication.
     * @param {OpportunityApplicationCreateArgs} args - Arguments to create a OpportunityApplication.
     * @example
     * // Create one OpportunityApplication
     * const OpportunityApplication = await prisma.opportunityApplication.create({
     *   data: {
     *     // ... data to create a OpportunityApplication
     *   }
     * })
     * 
     */
    create<T extends OpportunityApplicationCreateArgs>(args: SelectSubset<T, OpportunityApplicationCreateArgs<ExtArgs>>): Prisma__OpportunityApplicationClient<$Result.GetResult<Prisma.$OpportunityApplicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OpportunityApplications.
     * @param {OpportunityApplicationCreateManyArgs} args - Arguments to create many OpportunityApplications.
     * @example
     * // Create many OpportunityApplications
     * const opportunityApplication = await prisma.opportunityApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpportunityApplicationCreateManyArgs>(args?: SelectSubset<T, OpportunityApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OpportunityApplications and returns the data saved in the database.
     * @param {OpportunityApplicationCreateManyAndReturnArgs} args - Arguments to create many OpportunityApplications.
     * @example
     * // Create many OpportunityApplications
     * const opportunityApplication = await prisma.opportunityApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OpportunityApplications and only return the `id`
     * const opportunityApplicationWithIdOnly = await prisma.opportunityApplication.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpportunityApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, OpportunityApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityApplicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OpportunityApplication.
     * @param {OpportunityApplicationDeleteArgs} args - Arguments to delete one OpportunityApplication.
     * @example
     * // Delete one OpportunityApplication
     * const OpportunityApplication = await prisma.opportunityApplication.delete({
     *   where: {
     *     // ... filter to delete one OpportunityApplication
     *   }
     * })
     * 
     */
    delete<T extends OpportunityApplicationDeleteArgs>(args: SelectSubset<T, OpportunityApplicationDeleteArgs<ExtArgs>>): Prisma__OpportunityApplicationClient<$Result.GetResult<Prisma.$OpportunityApplicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OpportunityApplication.
     * @param {OpportunityApplicationUpdateArgs} args - Arguments to update one OpportunityApplication.
     * @example
     * // Update one OpportunityApplication
     * const opportunityApplication = await prisma.opportunityApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpportunityApplicationUpdateArgs>(args: SelectSubset<T, OpportunityApplicationUpdateArgs<ExtArgs>>): Prisma__OpportunityApplicationClient<$Result.GetResult<Prisma.$OpportunityApplicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OpportunityApplications.
     * @param {OpportunityApplicationDeleteManyArgs} args - Arguments to filter OpportunityApplications to delete.
     * @example
     * // Delete a few OpportunityApplications
     * const { count } = await prisma.opportunityApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpportunityApplicationDeleteManyArgs>(args?: SelectSubset<T, OpportunityApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpportunityApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OpportunityApplications
     * const opportunityApplication = await prisma.opportunityApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpportunityApplicationUpdateManyArgs>(args: SelectSubset<T, OpportunityApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OpportunityApplication.
     * @param {OpportunityApplicationUpsertArgs} args - Arguments to update or create a OpportunityApplication.
     * @example
     * // Update or create a OpportunityApplication
     * const opportunityApplication = await prisma.opportunityApplication.upsert({
     *   create: {
     *     // ... data to create a OpportunityApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OpportunityApplication we want to update
     *   }
     * })
     */
    upsert<T extends OpportunityApplicationUpsertArgs>(args: SelectSubset<T, OpportunityApplicationUpsertArgs<ExtArgs>>): Prisma__OpportunityApplicationClient<$Result.GetResult<Prisma.$OpportunityApplicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OpportunityApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityApplicationCountArgs} args - Arguments to filter OpportunityApplications to count.
     * @example
     * // Count the number of OpportunityApplications
     * const count = await prisma.opportunityApplication.count({
     *   where: {
     *     // ... the filter for the OpportunityApplications we want to count
     *   }
     * })
    **/
    count<T extends OpportunityApplicationCountArgs>(
      args?: Subset<T, OpportunityApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpportunityApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OpportunityApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpportunityApplicationAggregateArgs>(args: Subset<T, OpportunityApplicationAggregateArgs>): Prisma.PrismaPromise<GetOpportunityApplicationAggregateType<T>>

    /**
     * Group by OpportunityApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpportunityApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpportunityApplicationGroupByArgs['orderBy'] }
        : { orderBy?: OpportunityApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpportunityApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpportunityApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OpportunityApplication model
   */
  readonly fields: OpportunityApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OpportunityApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpportunityApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    opportunity<T extends OpportunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpportunityDefaultArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OpportunityApplication model
   */ 
  interface OpportunityApplicationFieldRefs {
    readonly id: FieldRef<"OpportunityApplication", 'String'>
    readonly message: FieldRef<"OpportunityApplication", 'String'>
    readonly resume: FieldRef<"OpportunityApplication", 'String'>
    readonly portfolio: FieldRef<"OpportunityApplication", 'String'>
    readonly status: FieldRef<"OpportunityApplication", 'ApplicationStatus'>
    readonly userId: FieldRef<"OpportunityApplication", 'String'>
    readonly opportunityId: FieldRef<"OpportunityApplication", 'String'>
    readonly createdAt: FieldRef<"OpportunityApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"OpportunityApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OpportunityApplication findUnique
   */
  export type OpportunityApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityApplication
     */
    select?: OpportunityApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityApplicationInclude<ExtArgs> | null
    /**
     * Filter, which OpportunityApplication to fetch.
     */
    where: OpportunityApplicationWhereUniqueInput
  }

  /**
   * OpportunityApplication findUniqueOrThrow
   */
  export type OpportunityApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityApplication
     */
    select?: OpportunityApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityApplicationInclude<ExtArgs> | null
    /**
     * Filter, which OpportunityApplication to fetch.
     */
    where: OpportunityApplicationWhereUniqueInput
  }

  /**
   * OpportunityApplication findFirst
   */
  export type OpportunityApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityApplication
     */
    select?: OpportunityApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityApplicationInclude<ExtArgs> | null
    /**
     * Filter, which OpportunityApplication to fetch.
     */
    where?: OpportunityApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpportunityApplications to fetch.
     */
    orderBy?: OpportunityApplicationOrderByWithRelationInput | OpportunityApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpportunityApplications.
     */
    cursor?: OpportunityApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpportunityApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpportunityApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpportunityApplications.
     */
    distinct?: OpportunityApplicationScalarFieldEnum | OpportunityApplicationScalarFieldEnum[]
  }

  /**
   * OpportunityApplication findFirstOrThrow
   */
  export type OpportunityApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityApplication
     */
    select?: OpportunityApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityApplicationInclude<ExtArgs> | null
    /**
     * Filter, which OpportunityApplication to fetch.
     */
    where?: OpportunityApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpportunityApplications to fetch.
     */
    orderBy?: OpportunityApplicationOrderByWithRelationInput | OpportunityApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpportunityApplications.
     */
    cursor?: OpportunityApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpportunityApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpportunityApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpportunityApplications.
     */
    distinct?: OpportunityApplicationScalarFieldEnum | OpportunityApplicationScalarFieldEnum[]
  }

  /**
   * OpportunityApplication findMany
   */
  export type OpportunityApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityApplication
     */
    select?: OpportunityApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityApplicationInclude<ExtArgs> | null
    /**
     * Filter, which OpportunityApplications to fetch.
     */
    where?: OpportunityApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpportunityApplications to fetch.
     */
    orderBy?: OpportunityApplicationOrderByWithRelationInput | OpportunityApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OpportunityApplications.
     */
    cursor?: OpportunityApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpportunityApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpportunityApplications.
     */
    skip?: number
    distinct?: OpportunityApplicationScalarFieldEnum | OpportunityApplicationScalarFieldEnum[]
  }

  /**
   * OpportunityApplication create
   */
  export type OpportunityApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityApplication
     */
    select?: OpportunityApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a OpportunityApplication.
     */
    data: XOR<OpportunityApplicationCreateInput, OpportunityApplicationUncheckedCreateInput>
  }

  /**
   * OpportunityApplication createMany
   */
  export type OpportunityApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OpportunityApplications.
     */
    data: OpportunityApplicationCreateManyInput | OpportunityApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpportunityApplication createManyAndReturn
   */
  export type OpportunityApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityApplication
     */
    select?: OpportunityApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OpportunityApplications.
     */
    data: OpportunityApplicationCreateManyInput | OpportunityApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OpportunityApplication update
   */
  export type OpportunityApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityApplication
     */
    select?: OpportunityApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a OpportunityApplication.
     */
    data: XOR<OpportunityApplicationUpdateInput, OpportunityApplicationUncheckedUpdateInput>
    /**
     * Choose, which OpportunityApplication to update.
     */
    where: OpportunityApplicationWhereUniqueInput
  }

  /**
   * OpportunityApplication updateMany
   */
  export type OpportunityApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OpportunityApplications.
     */
    data: XOR<OpportunityApplicationUpdateManyMutationInput, OpportunityApplicationUncheckedUpdateManyInput>
    /**
     * Filter which OpportunityApplications to update
     */
    where?: OpportunityApplicationWhereInput
  }

  /**
   * OpportunityApplication upsert
   */
  export type OpportunityApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityApplication
     */
    select?: OpportunityApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the OpportunityApplication to update in case it exists.
     */
    where: OpportunityApplicationWhereUniqueInput
    /**
     * In case the OpportunityApplication found by the `where` argument doesn't exist, create a new OpportunityApplication with this data.
     */
    create: XOR<OpportunityApplicationCreateInput, OpportunityApplicationUncheckedCreateInput>
    /**
     * In case the OpportunityApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpportunityApplicationUpdateInput, OpportunityApplicationUncheckedUpdateInput>
  }

  /**
   * OpportunityApplication delete
   */
  export type OpportunityApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityApplication
     */
    select?: OpportunityApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityApplicationInclude<ExtArgs> | null
    /**
     * Filter which OpportunityApplication to delete.
     */
    where: OpportunityApplicationWhereUniqueInput
  }

  /**
   * OpportunityApplication deleteMany
   */
  export type OpportunityApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpportunityApplications to delete
     */
    where?: OpportunityApplicationWhereInput
  }

  /**
   * OpportunityApplication without action
   */
  export type OpportunityApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityApplication
     */
    select?: OpportunityApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityApplicationInclude<ExtArgs> | null
  }


  /**
   * Model PageView
   */

  export type AggregatePageView = {
    _count: PageViewCountAggregateOutputType | null
    _min: PageViewMinAggregateOutputType | null
    _max: PageViewMaxAggregateOutputType | null
  }

  export type PageViewMinAggregateOutputType = {
    id: string | null
    path: string | null
    userAgent: string | null
    ipAddress: string | null
    referer: string | null
    sessionId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type PageViewMaxAggregateOutputType = {
    id: string | null
    path: string | null
    userAgent: string | null
    ipAddress: string | null
    referer: string | null
    sessionId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type PageViewCountAggregateOutputType = {
    id: number
    path: number
    userAgent: number
    ipAddress: number
    referer: number
    sessionId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type PageViewMinAggregateInputType = {
    id?: true
    path?: true
    userAgent?: true
    ipAddress?: true
    referer?: true
    sessionId?: true
    userId?: true
    createdAt?: true
  }

  export type PageViewMaxAggregateInputType = {
    id?: true
    path?: true
    userAgent?: true
    ipAddress?: true
    referer?: true
    sessionId?: true
    userId?: true
    createdAt?: true
  }

  export type PageViewCountAggregateInputType = {
    id?: true
    path?: true
    userAgent?: true
    ipAddress?: true
    referer?: true
    sessionId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type PageViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageView to aggregate.
     */
    where?: PageViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageViews to fetch.
     */
    orderBy?: PageViewOrderByWithRelationInput | PageViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PageViews
    **/
    _count?: true | PageViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageViewMaxAggregateInputType
  }

  export type GetPageViewAggregateType<T extends PageViewAggregateArgs> = {
        [P in keyof T & keyof AggregatePageView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePageView[P]>
      : GetScalarType<T[P], AggregatePageView[P]>
  }




  export type PageViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageViewWhereInput
    orderBy?: PageViewOrderByWithAggregationInput | PageViewOrderByWithAggregationInput[]
    by: PageViewScalarFieldEnum[] | PageViewScalarFieldEnum
    having?: PageViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageViewCountAggregateInputType | true
    _min?: PageViewMinAggregateInputType
    _max?: PageViewMaxAggregateInputType
  }

  export type PageViewGroupByOutputType = {
    id: string
    path: string
    userAgent: string | null
    ipAddress: string | null
    referer: string | null
    sessionId: string | null
    userId: string | null
    createdAt: Date
    _count: PageViewCountAggregateOutputType | null
    _min: PageViewMinAggregateOutputType | null
    _max: PageViewMaxAggregateOutputType | null
  }

  type GetPageViewGroupByPayload<T extends PageViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageViewGroupByOutputType[P]>
            : GetScalarType<T[P], PageViewGroupByOutputType[P]>
        }
      >
    >


  export type PageViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    path?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    referer?: boolean
    sessionId?: boolean
    userId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["pageView"]>

  export type PageViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    path?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    referer?: boolean
    sessionId?: boolean
    userId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["pageView"]>

  export type PageViewSelectScalar = {
    id?: boolean
    path?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    referer?: boolean
    sessionId?: boolean
    userId?: boolean
    createdAt?: boolean
  }


  export type $PageViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PageView"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      path: string
      userAgent: string | null
      ipAddress: string | null
      referer: string | null
      sessionId: string | null
      userId: string | null
      createdAt: Date
    }, ExtArgs["result"]["pageView"]>
    composites: {}
  }

  type PageViewGetPayload<S extends boolean | null | undefined | PageViewDefaultArgs> = $Result.GetResult<Prisma.$PageViewPayload, S>

  type PageViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PageViewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PageViewCountAggregateInputType | true
    }

  export interface PageViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PageView'], meta: { name: 'PageView' } }
    /**
     * Find zero or one PageView that matches the filter.
     * @param {PageViewFindUniqueArgs} args - Arguments to find a PageView
     * @example
     * // Get one PageView
     * const pageView = await prisma.pageView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageViewFindUniqueArgs>(args: SelectSubset<T, PageViewFindUniqueArgs<ExtArgs>>): Prisma__PageViewClient<$Result.GetResult<Prisma.$PageViewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PageView that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PageViewFindUniqueOrThrowArgs} args - Arguments to find a PageView
     * @example
     * // Get one PageView
     * const pageView = await prisma.pageView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageViewFindUniqueOrThrowArgs>(args: SelectSubset<T, PageViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageViewClient<$Result.GetResult<Prisma.$PageViewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PageView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageViewFindFirstArgs} args - Arguments to find a PageView
     * @example
     * // Get one PageView
     * const pageView = await prisma.pageView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageViewFindFirstArgs>(args?: SelectSubset<T, PageViewFindFirstArgs<ExtArgs>>): Prisma__PageViewClient<$Result.GetResult<Prisma.$PageViewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PageView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageViewFindFirstOrThrowArgs} args - Arguments to find a PageView
     * @example
     * // Get one PageView
     * const pageView = await prisma.pageView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageViewFindFirstOrThrowArgs>(args?: SelectSubset<T, PageViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageViewClient<$Result.GetResult<Prisma.$PageViewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PageViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PageViews
     * const pageViews = await prisma.pageView.findMany()
     * 
     * // Get first 10 PageViews
     * const pageViews = await prisma.pageView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageViewWithIdOnly = await prisma.pageView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageViewFindManyArgs>(args?: SelectSubset<T, PageViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageViewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PageView.
     * @param {PageViewCreateArgs} args - Arguments to create a PageView.
     * @example
     * // Create one PageView
     * const PageView = await prisma.pageView.create({
     *   data: {
     *     // ... data to create a PageView
     *   }
     * })
     * 
     */
    create<T extends PageViewCreateArgs>(args: SelectSubset<T, PageViewCreateArgs<ExtArgs>>): Prisma__PageViewClient<$Result.GetResult<Prisma.$PageViewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PageViews.
     * @param {PageViewCreateManyArgs} args - Arguments to create many PageViews.
     * @example
     * // Create many PageViews
     * const pageView = await prisma.pageView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageViewCreateManyArgs>(args?: SelectSubset<T, PageViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PageViews and returns the data saved in the database.
     * @param {PageViewCreateManyAndReturnArgs} args - Arguments to create many PageViews.
     * @example
     * // Create many PageViews
     * const pageView = await prisma.pageView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PageViews and only return the `id`
     * const pageViewWithIdOnly = await prisma.pageView.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PageViewCreateManyAndReturnArgs>(args?: SelectSubset<T, PageViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageViewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PageView.
     * @param {PageViewDeleteArgs} args - Arguments to delete one PageView.
     * @example
     * // Delete one PageView
     * const PageView = await prisma.pageView.delete({
     *   where: {
     *     // ... filter to delete one PageView
     *   }
     * })
     * 
     */
    delete<T extends PageViewDeleteArgs>(args: SelectSubset<T, PageViewDeleteArgs<ExtArgs>>): Prisma__PageViewClient<$Result.GetResult<Prisma.$PageViewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PageView.
     * @param {PageViewUpdateArgs} args - Arguments to update one PageView.
     * @example
     * // Update one PageView
     * const pageView = await prisma.pageView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageViewUpdateArgs>(args: SelectSubset<T, PageViewUpdateArgs<ExtArgs>>): Prisma__PageViewClient<$Result.GetResult<Prisma.$PageViewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PageViews.
     * @param {PageViewDeleteManyArgs} args - Arguments to filter PageViews to delete.
     * @example
     * // Delete a few PageViews
     * const { count } = await prisma.pageView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageViewDeleteManyArgs>(args?: SelectSubset<T, PageViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PageViews
     * const pageView = await prisma.pageView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageViewUpdateManyArgs>(args: SelectSubset<T, PageViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PageView.
     * @param {PageViewUpsertArgs} args - Arguments to update or create a PageView.
     * @example
     * // Update or create a PageView
     * const pageView = await prisma.pageView.upsert({
     *   create: {
     *     // ... data to create a PageView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PageView we want to update
     *   }
     * })
     */
    upsert<T extends PageViewUpsertArgs>(args: SelectSubset<T, PageViewUpsertArgs<ExtArgs>>): Prisma__PageViewClient<$Result.GetResult<Prisma.$PageViewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PageViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageViewCountArgs} args - Arguments to filter PageViews to count.
     * @example
     * // Count the number of PageViews
     * const count = await prisma.pageView.count({
     *   where: {
     *     // ... the filter for the PageViews we want to count
     *   }
     * })
    **/
    count<T extends PageViewCountArgs>(
      args?: Subset<T, PageViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PageView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageViewAggregateArgs>(args: Subset<T, PageViewAggregateArgs>): Prisma.PrismaPromise<GetPageViewAggregateType<T>>

    /**
     * Group by PageView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageViewGroupByArgs['orderBy'] }
        : { orderBy?: PageViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PageView model
   */
  readonly fields: PageViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PageView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PageView model
   */ 
  interface PageViewFieldRefs {
    readonly id: FieldRef<"PageView", 'String'>
    readonly path: FieldRef<"PageView", 'String'>
    readonly userAgent: FieldRef<"PageView", 'String'>
    readonly ipAddress: FieldRef<"PageView", 'String'>
    readonly referer: FieldRef<"PageView", 'String'>
    readonly sessionId: FieldRef<"PageView", 'String'>
    readonly userId: FieldRef<"PageView", 'String'>
    readonly createdAt: FieldRef<"PageView", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PageView findUnique
   */
  export type PageViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageView
     */
    select?: PageViewSelect<ExtArgs> | null
    /**
     * Filter, which PageView to fetch.
     */
    where: PageViewWhereUniqueInput
  }

  /**
   * PageView findUniqueOrThrow
   */
  export type PageViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageView
     */
    select?: PageViewSelect<ExtArgs> | null
    /**
     * Filter, which PageView to fetch.
     */
    where: PageViewWhereUniqueInput
  }

  /**
   * PageView findFirst
   */
  export type PageViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageView
     */
    select?: PageViewSelect<ExtArgs> | null
    /**
     * Filter, which PageView to fetch.
     */
    where?: PageViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageViews to fetch.
     */
    orderBy?: PageViewOrderByWithRelationInput | PageViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageViews.
     */
    cursor?: PageViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageViews.
     */
    distinct?: PageViewScalarFieldEnum | PageViewScalarFieldEnum[]
  }

  /**
   * PageView findFirstOrThrow
   */
  export type PageViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageView
     */
    select?: PageViewSelect<ExtArgs> | null
    /**
     * Filter, which PageView to fetch.
     */
    where?: PageViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageViews to fetch.
     */
    orderBy?: PageViewOrderByWithRelationInput | PageViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageViews.
     */
    cursor?: PageViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageViews.
     */
    distinct?: PageViewScalarFieldEnum | PageViewScalarFieldEnum[]
  }

  /**
   * PageView findMany
   */
  export type PageViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageView
     */
    select?: PageViewSelect<ExtArgs> | null
    /**
     * Filter, which PageViews to fetch.
     */
    where?: PageViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageViews to fetch.
     */
    orderBy?: PageViewOrderByWithRelationInput | PageViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PageViews.
     */
    cursor?: PageViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageViews.
     */
    skip?: number
    distinct?: PageViewScalarFieldEnum | PageViewScalarFieldEnum[]
  }

  /**
   * PageView create
   */
  export type PageViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageView
     */
    select?: PageViewSelect<ExtArgs> | null
    /**
     * The data needed to create a PageView.
     */
    data: XOR<PageViewCreateInput, PageViewUncheckedCreateInput>
  }

  /**
   * PageView createMany
   */
  export type PageViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PageViews.
     */
    data: PageViewCreateManyInput | PageViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PageView createManyAndReturn
   */
  export type PageViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageView
     */
    select?: PageViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PageViews.
     */
    data: PageViewCreateManyInput | PageViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PageView update
   */
  export type PageViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageView
     */
    select?: PageViewSelect<ExtArgs> | null
    /**
     * The data needed to update a PageView.
     */
    data: XOR<PageViewUpdateInput, PageViewUncheckedUpdateInput>
    /**
     * Choose, which PageView to update.
     */
    where: PageViewWhereUniqueInput
  }

  /**
   * PageView updateMany
   */
  export type PageViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PageViews.
     */
    data: XOR<PageViewUpdateManyMutationInput, PageViewUncheckedUpdateManyInput>
    /**
     * Filter which PageViews to update
     */
    where?: PageViewWhereInput
  }

  /**
   * PageView upsert
   */
  export type PageViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageView
     */
    select?: PageViewSelect<ExtArgs> | null
    /**
     * The filter to search for the PageView to update in case it exists.
     */
    where: PageViewWhereUniqueInput
    /**
     * In case the PageView found by the `where` argument doesn't exist, create a new PageView with this data.
     */
    create: XOR<PageViewCreateInput, PageViewUncheckedCreateInput>
    /**
     * In case the PageView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageViewUpdateInput, PageViewUncheckedUpdateInput>
  }

  /**
   * PageView delete
   */
  export type PageViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageView
     */
    select?: PageViewSelect<ExtArgs> | null
    /**
     * Filter which PageView to delete.
     */
    where: PageViewWhereUniqueInput
  }

  /**
   * PageView deleteMany
   */
  export type PageViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageViews to delete
     */
    where?: PageViewWhereInput
  }

  /**
   * PageView without action
   */
  export type PageViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageView
     */
    select?: PageViewSelect<ExtArgs> | null
  }


  /**
   * Model SearchQuery
   */

  export type AggregateSearchQuery = {
    _count: SearchQueryCountAggregateOutputType | null
    _avg: SearchQueryAvgAggregateOutputType | null
    _sum: SearchQuerySumAggregateOutputType | null
    _min: SearchQueryMinAggregateOutputType | null
    _max: SearchQueryMaxAggregateOutputType | null
  }

  export type SearchQueryAvgAggregateOutputType = {
    results: number | null
  }

  export type SearchQuerySumAggregateOutputType = {
    results: number | null
  }

  export type SearchQueryMinAggregateOutputType = {
    id: string | null
    query: string | null
    results: number | null
    userId: string | null
    createdAt: Date | null
  }

  export type SearchQueryMaxAggregateOutputType = {
    id: string | null
    query: string | null
    results: number | null
    userId: string | null
    createdAt: Date | null
  }

  export type SearchQueryCountAggregateOutputType = {
    id: number
    query: number
    results: number
    userId: number
    createdAt: number
    _all: number
  }


  export type SearchQueryAvgAggregateInputType = {
    results?: true
  }

  export type SearchQuerySumAggregateInputType = {
    results?: true
  }

  export type SearchQueryMinAggregateInputType = {
    id?: true
    query?: true
    results?: true
    userId?: true
    createdAt?: true
  }

  export type SearchQueryMaxAggregateInputType = {
    id?: true
    query?: true
    results?: true
    userId?: true
    createdAt?: true
  }

  export type SearchQueryCountAggregateInputType = {
    id?: true
    query?: true
    results?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type SearchQueryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchQuery to aggregate.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchQueries
    **/
    _count?: true | SearchQueryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SearchQueryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SearchQuerySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchQueryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchQueryMaxAggregateInputType
  }

  export type GetSearchQueryAggregateType<T extends SearchQueryAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchQuery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchQuery[P]>
      : GetScalarType<T[P], AggregateSearchQuery[P]>
  }




  export type SearchQueryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchQueryWhereInput
    orderBy?: SearchQueryOrderByWithAggregationInput | SearchQueryOrderByWithAggregationInput[]
    by: SearchQueryScalarFieldEnum[] | SearchQueryScalarFieldEnum
    having?: SearchQueryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchQueryCountAggregateInputType | true
    _avg?: SearchQueryAvgAggregateInputType
    _sum?: SearchQuerySumAggregateInputType
    _min?: SearchQueryMinAggregateInputType
    _max?: SearchQueryMaxAggregateInputType
  }

  export type SearchQueryGroupByOutputType = {
    id: string
    query: string
    results: number
    userId: string | null
    createdAt: Date
    _count: SearchQueryCountAggregateOutputType | null
    _avg: SearchQueryAvgAggregateOutputType | null
    _sum: SearchQuerySumAggregateOutputType | null
    _min: SearchQueryMinAggregateOutputType | null
    _max: SearchQueryMaxAggregateOutputType | null
  }

  type GetSearchQueryGroupByPayload<T extends SearchQueryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchQueryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchQueryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchQueryGroupByOutputType[P]>
            : GetScalarType<T[P], SearchQueryGroupByOutputType[P]>
        }
      >
    >


  export type SearchQuerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    results?: boolean
    userId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["searchQuery"]>

  export type SearchQuerySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    results?: boolean
    userId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["searchQuery"]>

  export type SearchQuerySelectScalar = {
    id?: boolean
    query?: boolean
    results?: boolean
    userId?: boolean
    createdAt?: boolean
  }


  export type $SearchQueryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchQuery"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      query: string
      results: number
      userId: string | null
      createdAt: Date
    }, ExtArgs["result"]["searchQuery"]>
    composites: {}
  }

  type SearchQueryGetPayload<S extends boolean | null | undefined | SearchQueryDefaultArgs> = $Result.GetResult<Prisma.$SearchQueryPayload, S>

  type SearchQueryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SearchQueryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SearchQueryCountAggregateInputType | true
    }

  export interface SearchQueryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchQuery'], meta: { name: 'SearchQuery' } }
    /**
     * Find zero or one SearchQuery that matches the filter.
     * @param {SearchQueryFindUniqueArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchQueryFindUniqueArgs>(args: SelectSubset<T, SearchQueryFindUniqueArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SearchQuery that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SearchQueryFindUniqueOrThrowArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchQueryFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchQueryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SearchQuery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryFindFirstArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchQueryFindFirstArgs>(args?: SelectSubset<T, SearchQueryFindFirstArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SearchQuery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryFindFirstOrThrowArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchQueryFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchQueryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SearchQueries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchQueries
     * const searchQueries = await prisma.searchQuery.findMany()
     * 
     * // Get first 10 SearchQueries
     * const searchQueries = await prisma.searchQuery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchQueryWithIdOnly = await prisma.searchQuery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchQueryFindManyArgs>(args?: SelectSubset<T, SearchQueryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SearchQuery.
     * @param {SearchQueryCreateArgs} args - Arguments to create a SearchQuery.
     * @example
     * // Create one SearchQuery
     * const SearchQuery = await prisma.searchQuery.create({
     *   data: {
     *     // ... data to create a SearchQuery
     *   }
     * })
     * 
     */
    create<T extends SearchQueryCreateArgs>(args: SelectSubset<T, SearchQueryCreateArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SearchQueries.
     * @param {SearchQueryCreateManyArgs} args - Arguments to create many SearchQueries.
     * @example
     * // Create many SearchQueries
     * const searchQuery = await prisma.searchQuery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchQueryCreateManyArgs>(args?: SelectSubset<T, SearchQueryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SearchQueries and returns the data saved in the database.
     * @param {SearchQueryCreateManyAndReturnArgs} args - Arguments to create many SearchQueries.
     * @example
     * // Create many SearchQueries
     * const searchQuery = await prisma.searchQuery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SearchQueries and only return the `id`
     * const searchQueryWithIdOnly = await prisma.searchQuery.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SearchQueryCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchQueryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SearchQuery.
     * @param {SearchQueryDeleteArgs} args - Arguments to delete one SearchQuery.
     * @example
     * // Delete one SearchQuery
     * const SearchQuery = await prisma.searchQuery.delete({
     *   where: {
     *     // ... filter to delete one SearchQuery
     *   }
     * })
     * 
     */
    delete<T extends SearchQueryDeleteArgs>(args: SelectSubset<T, SearchQueryDeleteArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SearchQuery.
     * @param {SearchQueryUpdateArgs} args - Arguments to update one SearchQuery.
     * @example
     * // Update one SearchQuery
     * const searchQuery = await prisma.searchQuery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchQueryUpdateArgs>(args: SelectSubset<T, SearchQueryUpdateArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SearchQueries.
     * @param {SearchQueryDeleteManyArgs} args - Arguments to filter SearchQueries to delete.
     * @example
     * // Delete a few SearchQueries
     * const { count } = await prisma.searchQuery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchQueryDeleteManyArgs>(args?: SelectSubset<T, SearchQueryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchQueries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchQueries
     * const searchQuery = await prisma.searchQuery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchQueryUpdateManyArgs>(args: SelectSubset<T, SearchQueryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SearchQuery.
     * @param {SearchQueryUpsertArgs} args - Arguments to update or create a SearchQuery.
     * @example
     * // Update or create a SearchQuery
     * const searchQuery = await prisma.searchQuery.upsert({
     *   create: {
     *     // ... data to create a SearchQuery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchQuery we want to update
     *   }
     * })
     */
    upsert<T extends SearchQueryUpsertArgs>(args: SelectSubset<T, SearchQueryUpsertArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SearchQueries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryCountArgs} args - Arguments to filter SearchQueries to count.
     * @example
     * // Count the number of SearchQueries
     * const count = await prisma.searchQuery.count({
     *   where: {
     *     // ... the filter for the SearchQueries we want to count
     *   }
     * })
    **/
    count<T extends SearchQueryCountArgs>(
      args?: Subset<T, SearchQueryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchQueryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchQuery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchQueryAggregateArgs>(args: Subset<T, SearchQueryAggregateArgs>): Prisma.PrismaPromise<GetSearchQueryAggregateType<T>>

    /**
     * Group by SearchQuery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchQueryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchQueryGroupByArgs['orderBy'] }
        : { orderBy?: SearchQueryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchQueryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchQueryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchQuery model
   */
  readonly fields: SearchQueryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchQuery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchQueryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchQuery model
   */ 
  interface SearchQueryFieldRefs {
    readonly id: FieldRef<"SearchQuery", 'String'>
    readonly query: FieldRef<"SearchQuery", 'String'>
    readonly results: FieldRef<"SearchQuery", 'Int'>
    readonly userId: FieldRef<"SearchQuery", 'String'>
    readonly createdAt: FieldRef<"SearchQuery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SearchQuery findUnique
   */
  export type SearchQueryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery findUniqueOrThrow
   */
  export type SearchQueryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery findFirst
   */
  export type SearchQueryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchQueries.
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchQueries.
     */
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
  }

  /**
   * SearchQuery findFirstOrThrow
   */
  export type SearchQueryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchQueries.
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchQueries.
     */
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
  }

  /**
   * SearchQuery findMany
   */
  export type SearchQueryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Filter, which SearchQueries to fetch.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchQueries.
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
  }

  /**
   * SearchQuery create
   */
  export type SearchQueryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * The data needed to create a SearchQuery.
     */
    data: XOR<SearchQueryCreateInput, SearchQueryUncheckedCreateInput>
  }

  /**
   * SearchQuery createMany
   */
  export type SearchQueryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchQueries.
     */
    data: SearchQueryCreateManyInput | SearchQueryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchQuery createManyAndReturn
   */
  export type SearchQueryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SearchQueries.
     */
    data: SearchQueryCreateManyInput | SearchQueryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchQuery update
   */
  export type SearchQueryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * The data needed to update a SearchQuery.
     */
    data: XOR<SearchQueryUpdateInput, SearchQueryUncheckedUpdateInput>
    /**
     * Choose, which SearchQuery to update.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery updateMany
   */
  export type SearchQueryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchQueries.
     */
    data: XOR<SearchQueryUpdateManyMutationInput, SearchQueryUncheckedUpdateManyInput>
    /**
     * Filter which SearchQueries to update
     */
    where?: SearchQueryWhereInput
  }

  /**
   * SearchQuery upsert
   */
  export type SearchQueryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * The filter to search for the SearchQuery to update in case it exists.
     */
    where: SearchQueryWhereUniqueInput
    /**
     * In case the SearchQuery found by the `where` argument doesn't exist, create a new SearchQuery with this data.
     */
    create: XOR<SearchQueryCreateInput, SearchQueryUncheckedCreateInput>
    /**
     * In case the SearchQuery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchQueryUpdateInput, SearchQueryUncheckedUpdateInput>
  }

  /**
   * SearchQuery delete
   */
  export type SearchQueryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Filter which SearchQuery to delete.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery deleteMany
   */
  export type SearchQueryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchQueries to delete
     */
    where?: SearchQueryWhereInput
  }

  /**
   * SearchQuery without action
   */
  export type SearchQueryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
  }


  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingMinAggregateOutputType = {
    id: string | null
    updatedAt: Date | null
  }

  export type SettingMaxAggregateOutputType = {
    id: string | null
    updatedAt: Date | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    value: number
    updatedAt: number
    _all: number
  }


  export type SettingMinAggregateInputType = {
    id?: true
    updatedAt?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    updatedAt?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    value?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: string
    value: JsonValue
    updatedAt: Date
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectScalar = {
    id?: boolean
    value?: boolean
    updatedAt?: boolean
  }


  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: Prisma.JsonValue
      updatedAt: Date
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingFindManyArgs>(args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends SettingCreateArgs>(args: SelectSubset<T, SettingCreateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingCreateManyArgs>(args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends SettingDeleteArgs>(args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingUpdateArgs>(args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingDeleteManyArgs>(args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingUpdateManyArgs>(args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Setting model
   */ 
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", 'String'>
    readonly value: FieldRef<"Setting", 'Json'>
    readonly updatedAt: FieldRef<"Setting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
  }

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting createManyAndReturn
   */
  export type SettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
  }

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
  }

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
  }

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    size: number | null
    width: number | null
    height: number | null
    duration: number | null
  }

  export type MediaSumAggregateOutputType = {
    size: number | null
    width: number | null
    height: number | null
    duration: number | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    alt: string | null
    caption: string | null
    width: number | null
    height: number | null
    duration: number | null
    uploadedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    alt: string | null
    caption: string | null
    width: number | null
    height: number | null
    duration: number | null
    uploadedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    filename: number
    originalName: number
    mimeType: number
    size: number
    url: number
    alt: number
    caption: number
    width: number
    height: number
    duration: number
    uploadedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    size?: true
    width?: true
    height?: true
    duration?: true
  }

  export type MediaSumAggregateInputType = {
    size?: true
    width?: true
    height?: true
    duration?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    alt?: true
    caption?: true
    width?: true
    height?: true
    duration?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    alt?: true
    caption?: true
    width?: true
    height?: true
    duration?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    alt?: true
    caption?: true
    width?: true
    height?: true
    duration?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _avg?: MediaAvgAggregateInputType
    _sum?: MediaSumAggregateInputType
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    alt: string | null
    caption: string | null
    width: number | null
    height: number | null
    duration: number | null
    uploadedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    alt?: boolean
    caption?: boolean
    width?: boolean
    height?: boolean
    duration?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    alt?: boolean
    caption?: boolean
    width?: boolean
    height?: boolean
    duration?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    alt?: boolean
    caption?: boolean
    width?: boolean
    height?: boolean
    duration?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filename: string
      originalName: string
      mimeType: string
      size: number
      url: string
      alt: string | null
      caption: string | null
      width: number | null
      height: number | null
      duration: number | null
      uploadedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */ 
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly filename: FieldRef<"Media", 'String'>
    readonly originalName: FieldRef<"Media", 'String'>
    readonly mimeType: FieldRef<"Media", 'String'>
    readonly size: FieldRef<"Media", 'Int'>
    readonly url: FieldRef<"Media", 'String'>
    readonly alt: FieldRef<"Media", 'String'>
    readonly caption: FieldRef<"Media", 'String'>
    readonly width: FieldRef<"Media", 'Int'>
    readonly height: FieldRef<"Media", 'Int'>
    readonly duration: FieldRef<"Media", 'Int'>
    readonly uploadedById: FieldRef<"Media", 'String'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
    readonly updatedAt: FieldRef<"Media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
  }


  /**
   * Model LifeOSProfile
   */

  export type AggregateLifeOSProfile = {
    _count: LifeOSProfileCountAggregateOutputType | null
    _min: LifeOSProfileMinAggregateOutputType | null
    _max: LifeOSProfileMaxAggregateOutputType | null
  }

  export type LifeOSProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    timezone: string | null
    locale: string | null
    currency: string | null
    themePreference: string | null
    extractiveSystemsTargeting: boolean | null
    communityControlEnabled: boolean | null
    dataResidencyPreference: string | null
    onboardingCompleted: boolean | null
    lastActiveAt: Date | null
    activationDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LifeOSProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    timezone: string | null
    locale: string | null
    currency: string | null
    themePreference: string | null
    extractiveSystemsTargeting: boolean | null
    communityControlEnabled: boolean | null
    dataResidencyPreference: string | null
    onboardingCompleted: boolean | null
    lastActiveAt: Date | null
    activationDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LifeOSProfileCountAggregateOutputType = {
    id: number
    userId: number
    timezone: number
    locale: number
    currency: number
    themePreference: number
    notificationSettings: number
    privacySettings: number
    extractiveSystemsTargeting: number
    communityControlEnabled: number
    dataResidencyPreference: number
    onboardingCompleted: number
    lastActiveAt: number
    activationDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LifeOSProfileMinAggregateInputType = {
    id?: true
    userId?: true
    timezone?: true
    locale?: true
    currency?: true
    themePreference?: true
    extractiveSystemsTargeting?: true
    communityControlEnabled?: true
    dataResidencyPreference?: true
    onboardingCompleted?: true
    lastActiveAt?: true
    activationDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LifeOSProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    timezone?: true
    locale?: true
    currency?: true
    themePreference?: true
    extractiveSystemsTargeting?: true
    communityControlEnabled?: true
    dataResidencyPreference?: true
    onboardingCompleted?: true
    lastActiveAt?: true
    activationDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LifeOSProfileCountAggregateInputType = {
    id?: true
    userId?: true
    timezone?: true
    locale?: true
    currency?: true
    themePreference?: true
    notificationSettings?: true
    privacySettings?: true
    extractiveSystemsTargeting?: true
    communityControlEnabled?: true
    dataResidencyPreference?: true
    onboardingCompleted?: true
    lastActiveAt?: true
    activationDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LifeOSProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LifeOSProfile to aggregate.
     */
    where?: LifeOSProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LifeOSProfiles to fetch.
     */
    orderBy?: LifeOSProfileOrderByWithRelationInput | LifeOSProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LifeOSProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LifeOSProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LifeOSProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LifeOSProfiles
    **/
    _count?: true | LifeOSProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LifeOSProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LifeOSProfileMaxAggregateInputType
  }

  export type GetLifeOSProfileAggregateType<T extends LifeOSProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateLifeOSProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLifeOSProfile[P]>
      : GetScalarType<T[P], AggregateLifeOSProfile[P]>
  }




  export type LifeOSProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LifeOSProfileWhereInput
    orderBy?: LifeOSProfileOrderByWithAggregationInput | LifeOSProfileOrderByWithAggregationInput[]
    by: LifeOSProfileScalarFieldEnum[] | LifeOSProfileScalarFieldEnum
    having?: LifeOSProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LifeOSProfileCountAggregateInputType | true
    _min?: LifeOSProfileMinAggregateInputType
    _max?: LifeOSProfileMaxAggregateInputType
  }

  export type LifeOSProfileGroupByOutputType = {
    id: string
    userId: string
    timezone: string
    locale: string
    currency: string
    themePreference: string
    notificationSettings: JsonValue
    privacySettings: JsonValue
    extractiveSystemsTargeting: boolean
    communityControlEnabled: boolean
    dataResidencyPreference: string
    onboardingCompleted: boolean
    lastActiveAt: Date
    activationDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: LifeOSProfileCountAggregateOutputType | null
    _min: LifeOSProfileMinAggregateOutputType | null
    _max: LifeOSProfileMaxAggregateOutputType | null
  }

  type GetLifeOSProfileGroupByPayload<T extends LifeOSProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LifeOSProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LifeOSProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LifeOSProfileGroupByOutputType[P]>
            : GetScalarType<T[P], LifeOSProfileGroupByOutputType[P]>
        }
      >
    >


  export type LifeOSProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    timezone?: boolean
    locale?: boolean
    currency?: boolean
    themePreference?: boolean
    notificationSettings?: boolean
    privacySettings?: boolean
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: boolean
    onboardingCompleted?: boolean
    lastActiveAt?: boolean
    activationDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    habits?: boolean | LifeOSProfile$habitsArgs<ExtArgs>
    goals?: boolean | LifeOSProfile$goalsArgs<ExtArgs>
    moodEntries?: boolean | LifeOSProfile$moodEntriesArgs<ExtArgs>
    meditations?: boolean | LifeOSProfile$meditationsArgs<ExtArgs>
    journals?: boolean | LifeOSProfile$journalsArgs<ExtArgs>
    transactions?: boolean | LifeOSProfile$transactionsArgs<ExtArgs>
    budgets?: boolean | LifeOSProfile$budgetsArgs<ExtArgs>
    _count?: boolean | LifeOSProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lifeOSProfile"]>

  export type LifeOSProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    timezone?: boolean
    locale?: boolean
    currency?: boolean
    themePreference?: boolean
    notificationSettings?: boolean
    privacySettings?: boolean
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: boolean
    onboardingCompleted?: boolean
    lastActiveAt?: boolean
    activationDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lifeOSProfile"]>

  export type LifeOSProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    timezone?: boolean
    locale?: boolean
    currency?: boolean
    themePreference?: boolean
    notificationSettings?: boolean
    privacySettings?: boolean
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: boolean
    onboardingCompleted?: boolean
    lastActiveAt?: boolean
    activationDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LifeOSProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    habits?: boolean | LifeOSProfile$habitsArgs<ExtArgs>
    goals?: boolean | LifeOSProfile$goalsArgs<ExtArgs>
    moodEntries?: boolean | LifeOSProfile$moodEntriesArgs<ExtArgs>
    meditations?: boolean | LifeOSProfile$meditationsArgs<ExtArgs>
    journals?: boolean | LifeOSProfile$journalsArgs<ExtArgs>
    transactions?: boolean | LifeOSProfile$transactionsArgs<ExtArgs>
    budgets?: boolean | LifeOSProfile$budgetsArgs<ExtArgs>
    _count?: boolean | LifeOSProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LifeOSProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LifeOSProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LifeOSProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      habits: Prisma.$HabitPayload<ExtArgs>[]
      goals: Prisma.$GoalPayload<ExtArgs>[]
      moodEntries: Prisma.$MoodEntryPayload<ExtArgs>[]
      meditations: Prisma.$MeditationSessionPayload<ExtArgs>[]
      journals: Prisma.$JournalPayload<ExtArgs>[]
      transactions: Prisma.$FinancialTransactionPayload<ExtArgs>[]
      budgets: Prisma.$BudgetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      timezone: string
      locale: string
      currency: string
      themePreference: string
      notificationSettings: Prisma.JsonValue
      privacySettings: Prisma.JsonValue
      extractiveSystemsTargeting: boolean
      communityControlEnabled: boolean
      dataResidencyPreference: string
      onboardingCompleted: boolean
      lastActiveAt: Date
      activationDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lifeOSProfile"]>
    composites: {}
  }

  type LifeOSProfileGetPayload<S extends boolean | null | undefined | LifeOSProfileDefaultArgs> = $Result.GetResult<Prisma.$LifeOSProfilePayload, S>

  type LifeOSProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LifeOSProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LifeOSProfileCountAggregateInputType | true
    }

  export interface LifeOSProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LifeOSProfile'], meta: { name: 'LifeOSProfile' } }
    /**
     * Find zero or one LifeOSProfile that matches the filter.
     * @param {LifeOSProfileFindUniqueArgs} args - Arguments to find a LifeOSProfile
     * @example
     * // Get one LifeOSProfile
     * const lifeOSProfile = await prisma.lifeOSProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LifeOSProfileFindUniqueArgs>(args: SelectSubset<T, LifeOSProfileFindUniqueArgs<ExtArgs>>): Prisma__LifeOSProfileClient<$Result.GetResult<Prisma.$LifeOSProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LifeOSProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LifeOSProfileFindUniqueOrThrowArgs} args - Arguments to find a LifeOSProfile
     * @example
     * // Get one LifeOSProfile
     * const lifeOSProfile = await prisma.lifeOSProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LifeOSProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, LifeOSProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LifeOSProfileClient<$Result.GetResult<Prisma.$LifeOSProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LifeOSProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LifeOSProfileFindFirstArgs} args - Arguments to find a LifeOSProfile
     * @example
     * // Get one LifeOSProfile
     * const lifeOSProfile = await prisma.lifeOSProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LifeOSProfileFindFirstArgs>(args?: SelectSubset<T, LifeOSProfileFindFirstArgs<ExtArgs>>): Prisma__LifeOSProfileClient<$Result.GetResult<Prisma.$LifeOSProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LifeOSProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LifeOSProfileFindFirstOrThrowArgs} args - Arguments to find a LifeOSProfile
     * @example
     * // Get one LifeOSProfile
     * const lifeOSProfile = await prisma.lifeOSProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LifeOSProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, LifeOSProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__LifeOSProfileClient<$Result.GetResult<Prisma.$LifeOSProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LifeOSProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LifeOSProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LifeOSProfiles
     * const lifeOSProfiles = await prisma.lifeOSProfile.findMany()
     * 
     * // Get first 10 LifeOSProfiles
     * const lifeOSProfiles = await prisma.lifeOSProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lifeOSProfileWithIdOnly = await prisma.lifeOSProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LifeOSProfileFindManyArgs>(args?: SelectSubset<T, LifeOSProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LifeOSProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LifeOSProfile.
     * @param {LifeOSProfileCreateArgs} args - Arguments to create a LifeOSProfile.
     * @example
     * // Create one LifeOSProfile
     * const LifeOSProfile = await prisma.lifeOSProfile.create({
     *   data: {
     *     // ... data to create a LifeOSProfile
     *   }
     * })
     * 
     */
    create<T extends LifeOSProfileCreateArgs>(args: SelectSubset<T, LifeOSProfileCreateArgs<ExtArgs>>): Prisma__LifeOSProfileClient<$Result.GetResult<Prisma.$LifeOSProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LifeOSProfiles.
     * @param {LifeOSProfileCreateManyArgs} args - Arguments to create many LifeOSProfiles.
     * @example
     * // Create many LifeOSProfiles
     * const lifeOSProfile = await prisma.lifeOSProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LifeOSProfileCreateManyArgs>(args?: SelectSubset<T, LifeOSProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LifeOSProfiles and returns the data saved in the database.
     * @param {LifeOSProfileCreateManyAndReturnArgs} args - Arguments to create many LifeOSProfiles.
     * @example
     * // Create many LifeOSProfiles
     * const lifeOSProfile = await prisma.lifeOSProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LifeOSProfiles and only return the `id`
     * const lifeOSProfileWithIdOnly = await prisma.lifeOSProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LifeOSProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, LifeOSProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LifeOSProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LifeOSProfile.
     * @param {LifeOSProfileDeleteArgs} args - Arguments to delete one LifeOSProfile.
     * @example
     * // Delete one LifeOSProfile
     * const LifeOSProfile = await prisma.lifeOSProfile.delete({
     *   where: {
     *     // ... filter to delete one LifeOSProfile
     *   }
     * })
     * 
     */
    delete<T extends LifeOSProfileDeleteArgs>(args: SelectSubset<T, LifeOSProfileDeleteArgs<ExtArgs>>): Prisma__LifeOSProfileClient<$Result.GetResult<Prisma.$LifeOSProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LifeOSProfile.
     * @param {LifeOSProfileUpdateArgs} args - Arguments to update one LifeOSProfile.
     * @example
     * // Update one LifeOSProfile
     * const lifeOSProfile = await prisma.lifeOSProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LifeOSProfileUpdateArgs>(args: SelectSubset<T, LifeOSProfileUpdateArgs<ExtArgs>>): Prisma__LifeOSProfileClient<$Result.GetResult<Prisma.$LifeOSProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LifeOSProfiles.
     * @param {LifeOSProfileDeleteManyArgs} args - Arguments to filter LifeOSProfiles to delete.
     * @example
     * // Delete a few LifeOSProfiles
     * const { count } = await prisma.lifeOSProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LifeOSProfileDeleteManyArgs>(args?: SelectSubset<T, LifeOSProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LifeOSProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LifeOSProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LifeOSProfiles
     * const lifeOSProfile = await prisma.lifeOSProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LifeOSProfileUpdateManyArgs>(args: SelectSubset<T, LifeOSProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LifeOSProfile.
     * @param {LifeOSProfileUpsertArgs} args - Arguments to update or create a LifeOSProfile.
     * @example
     * // Update or create a LifeOSProfile
     * const lifeOSProfile = await prisma.lifeOSProfile.upsert({
     *   create: {
     *     // ... data to create a LifeOSProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LifeOSProfile we want to update
     *   }
     * })
     */
    upsert<T extends LifeOSProfileUpsertArgs>(args: SelectSubset<T, LifeOSProfileUpsertArgs<ExtArgs>>): Prisma__LifeOSProfileClient<$Result.GetResult<Prisma.$LifeOSProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LifeOSProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LifeOSProfileCountArgs} args - Arguments to filter LifeOSProfiles to count.
     * @example
     * // Count the number of LifeOSProfiles
     * const count = await prisma.lifeOSProfile.count({
     *   where: {
     *     // ... the filter for the LifeOSProfiles we want to count
     *   }
     * })
    **/
    count<T extends LifeOSProfileCountArgs>(
      args?: Subset<T, LifeOSProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LifeOSProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LifeOSProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LifeOSProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LifeOSProfileAggregateArgs>(args: Subset<T, LifeOSProfileAggregateArgs>): Prisma.PrismaPromise<GetLifeOSProfileAggregateType<T>>

    /**
     * Group by LifeOSProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LifeOSProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LifeOSProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LifeOSProfileGroupByArgs['orderBy'] }
        : { orderBy?: LifeOSProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LifeOSProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLifeOSProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LifeOSProfile model
   */
  readonly fields: LifeOSProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LifeOSProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LifeOSProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    habits<T extends LifeOSProfile$habitsArgs<ExtArgs> = {}>(args?: Subset<T, LifeOSProfile$habitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findMany"> | Null>
    goals<T extends LifeOSProfile$goalsArgs<ExtArgs> = {}>(args?: Subset<T, LifeOSProfile$goalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany"> | Null>
    moodEntries<T extends LifeOSProfile$moodEntriesArgs<ExtArgs> = {}>(args?: Subset<T, LifeOSProfile$moodEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "findMany"> | Null>
    meditations<T extends LifeOSProfile$meditationsArgs<ExtArgs> = {}>(args?: Subset<T, LifeOSProfile$meditationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeditationSessionPayload<ExtArgs>, T, "findMany"> | Null>
    journals<T extends LifeOSProfile$journalsArgs<ExtArgs> = {}>(args?: Subset<T, LifeOSProfile$journalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends LifeOSProfile$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, LifeOSProfile$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    budgets<T extends LifeOSProfile$budgetsArgs<ExtArgs> = {}>(args?: Subset<T, LifeOSProfile$budgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LifeOSProfile model
   */ 
  interface LifeOSProfileFieldRefs {
    readonly id: FieldRef<"LifeOSProfile", 'String'>
    readonly userId: FieldRef<"LifeOSProfile", 'String'>
    readonly timezone: FieldRef<"LifeOSProfile", 'String'>
    readonly locale: FieldRef<"LifeOSProfile", 'String'>
    readonly currency: FieldRef<"LifeOSProfile", 'String'>
    readonly themePreference: FieldRef<"LifeOSProfile", 'String'>
    readonly notificationSettings: FieldRef<"LifeOSProfile", 'Json'>
    readonly privacySettings: FieldRef<"LifeOSProfile", 'Json'>
    readonly extractiveSystemsTargeting: FieldRef<"LifeOSProfile", 'Boolean'>
    readonly communityControlEnabled: FieldRef<"LifeOSProfile", 'Boolean'>
    readonly dataResidencyPreference: FieldRef<"LifeOSProfile", 'String'>
    readonly onboardingCompleted: FieldRef<"LifeOSProfile", 'Boolean'>
    readonly lastActiveAt: FieldRef<"LifeOSProfile", 'DateTime'>
    readonly activationDate: FieldRef<"LifeOSProfile", 'DateTime'>
    readonly createdAt: FieldRef<"LifeOSProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"LifeOSProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LifeOSProfile findUnique
   */
  export type LifeOSProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeOSProfile
     */
    select?: LifeOSProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeOSProfileInclude<ExtArgs> | null
    /**
     * Filter, which LifeOSProfile to fetch.
     */
    where: LifeOSProfileWhereUniqueInput
  }

  /**
   * LifeOSProfile findUniqueOrThrow
   */
  export type LifeOSProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeOSProfile
     */
    select?: LifeOSProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeOSProfileInclude<ExtArgs> | null
    /**
     * Filter, which LifeOSProfile to fetch.
     */
    where: LifeOSProfileWhereUniqueInput
  }

  /**
   * LifeOSProfile findFirst
   */
  export type LifeOSProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeOSProfile
     */
    select?: LifeOSProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeOSProfileInclude<ExtArgs> | null
    /**
     * Filter, which LifeOSProfile to fetch.
     */
    where?: LifeOSProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LifeOSProfiles to fetch.
     */
    orderBy?: LifeOSProfileOrderByWithRelationInput | LifeOSProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LifeOSProfiles.
     */
    cursor?: LifeOSProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LifeOSProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LifeOSProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LifeOSProfiles.
     */
    distinct?: LifeOSProfileScalarFieldEnum | LifeOSProfileScalarFieldEnum[]
  }

  /**
   * LifeOSProfile findFirstOrThrow
   */
  export type LifeOSProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeOSProfile
     */
    select?: LifeOSProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeOSProfileInclude<ExtArgs> | null
    /**
     * Filter, which LifeOSProfile to fetch.
     */
    where?: LifeOSProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LifeOSProfiles to fetch.
     */
    orderBy?: LifeOSProfileOrderByWithRelationInput | LifeOSProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LifeOSProfiles.
     */
    cursor?: LifeOSProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LifeOSProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LifeOSProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LifeOSProfiles.
     */
    distinct?: LifeOSProfileScalarFieldEnum | LifeOSProfileScalarFieldEnum[]
  }

  /**
   * LifeOSProfile findMany
   */
  export type LifeOSProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeOSProfile
     */
    select?: LifeOSProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeOSProfileInclude<ExtArgs> | null
    /**
     * Filter, which LifeOSProfiles to fetch.
     */
    where?: LifeOSProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LifeOSProfiles to fetch.
     */
    orderBy?: LifeOSProfileOrderByWithRelationInput | LifeOSProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LifeOSProfiles.
     */
    cursor?: LifeOSProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LifeOSProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LifeOSProfiles.
     */
    skip?: number
    distinct?: LifeOSProfileScalarFieldEnum | LifeOSProfileScalarFieldEnum[]
  }

  /**
   * LifeOSProfile create
   */
  export type LifeOSProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeOSProfile
     */
    select?: LifeOSProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeOSProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a LifeOSProfile.
     */
    data: XOR<LifeOSProfileCreateInput, LifeOSProfileUncheckedCreateInput>
  }

  /**
   * LifeOSProfile createMany
   */
  export type LifeOSProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LifeOSProfiles.
     */
    data: LifeOSProfileCreateManyInput | LifeOSProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LifeOSProfile createManyAndReturn
   */
  export type LifeOSProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeOSProfile
     */
    select?: LifeOSProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LifeOSProfiles.
     */
    data: LifeOSProfileCreateManyInput | LifeOSProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeOSProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LifeOSProfile update
   */
  export type LifeOSProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeOSProfile
     */
    select?: LifeOSProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeOSProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a LifeOSProfile.
     */
    data: XOR<LifeOSProfileUpdateInput, LifeOSProfileUncheckedUpdateInput>
    /**
     * Choose, which LifeOSProfile to update.
     */
    where: LifeOSProfileWhereUniqueInput
  }

  /**
   * LifeOSProfile updateMany
   */
  export type LifeOSProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LifeOSProfiles.
     */
    data: XOR<LifeOSProfileUpdateManyMutationInput, LifeOSProfileUncheckedUpdateManyInput>
    /**
     * Filter which LifeOSProfiles to update
     */
    where?: LifeOSProfileWhereInput
  }

  /**
   * LifeOSProfile upsert
   */
  export type LifeOSProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeOSProfile
     */
    select?: LifeOSProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeOSProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the LifeOSProfile to update in case it exists.
     */
    where: LifeOSProfileWhereUniqueInput
    /**
     * In case the LifeOSProfile found by the `where` argument doesn't exist, create a new LifeOSProfile with this data.
     */
    create: XOR<LifeOSProfileCreateInput, LifeOSProfileUncheckedCreateInput>
    /**
     * In case the LifeOSProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LifeOSProfileUpdateInput, LifeOSProfileUncheckedUpdateInput>
  }

  /**
   * LifeOSProfile delete
   */
  export type LifeOSProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeOSProfile
     */
    select?: LifeOSProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeOSProfileInclude<ExtArgs> | null
    /**
     * Filter which LifeOSProfile to delete.
     */
    where: LifeOSProfileWhereUniqueInput
  }

  /**
   * LifeOSProfile deleteMany
   */
  export type LifeOSProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LifeOSProfiles to delete
     */
    where?: LifeOSProfileWhereInput
  }

  /**
   * LifeOSProfile.habits
   */
  export type LifeOSProfile$habitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    where?: HabitWhereInput
    orderBy?: HabitOrderByWithRelationInput | HabitOrderByWithRelationInput[]
    cursor?: HabitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HabitScalarFieldEnum | HabitScalarFieldEnum[]
  }

  /**
   * LifeOSProfile.goals
   */
  export type LifeOSProfile$goalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    where?: GoalWhereInput
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    cursor?: GoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * LifeOSProfile.moodEntries
   */
  export type LifeOSProfile$moodEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    where?: MoodEntryWhereInput
    orderBy?: MoodEntryOrderByWithRelationInput | MoodEntryOrderByWithRelationInput[]
    cursor?: MoodEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MoodEntryScalarFieldEnum | MoodEntryScalarFieldEnum[]
  }

  /**
   * LifeOSProfile.meditations
   */
  export type LifeOSProfile$meditationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationSession
     */
    select?: MeditationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationSessionInclude<ExtArgs> | null
    where?: MeditationSessionWhereInput
    orderBy?: MeditationSessionOrderByWithRelationInput | MeditationSessionOrderByWithRelationInput[]
    cursor?: MeditationSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeditationSessionScalarFieldEnum | MeditationSessionScalarFieldEnum[]
  }

  /**
   * LifeOSProfile.journals
   */
  export type LifeOSProfile$journalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    where?: JournalWhereInput
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    cursor?: JournalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * LifeOSProfile.transactions
   */
  export type LifeOSProfile$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    where?: FinancialTransactionWhereInput
    orderBy?: FinancialTransactionOrderByWithRelationInput | FinancialTransactionOrderByWithRelationInput[]
    cursor?: FinancialTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialTransactionScalarFieldEnum | FinancialTransactionScalarFieldEnum[]
  }

  /**
   * LifeOSProfile.budgets
   */
  export type LifeOSProfile$budgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    cursor?: BudgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * LifeOSProfile without action
   */
  export type LifeOSProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeOSProfile
     */
    select?: LifeOSProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeOSProfileInclude<ExtArgs> | null
  }


  /**
   * Model Habit
   */

  export type AggregateHabit = {
    _count: HabitCountAggregateOutputType | null
    _avg: HabitAvgAggregateOutputType | null
    _sum: HabitSumAggregateOutputType | null
    _min: HabitMinAggregateOutputType | null
    _max: HabitMaxAggregateOutputType | null
  }

  export type HabitAvgAggregateOutputType = {
    targetValue: number | null
    currentStreak: number | null
    longestStreak: number | null
  }

  export type HabitSumAggregateOutputType = {
    targetValue: number | null
    currentStreak: number | null
    longestStreak: number | null
  }

  export type HabitMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    name: string | null
    description: string | null
    category: string | null
    frequency: $Enums.HabitFrequency | null
    targetValue: number | null
    unit: string | null
    color: string | null
    icon: string | null
    isActive: boolean | null
    currentStreak: number | null
    longestStreak: number | null
    lastCompletedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HabitMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    name: string | null
    description: string | null
    category: string | null
    frequency: $Enums.HabitFrequency | null
    targetValue: number | null
    unit: string | null
    color: string | null
    icon: string | null
    isActive: boolean | null
    currentStreak: number | null
    longestStreak: number | null
    lastCompletedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HabitCountAggregateOutputType = {
    id: number
    profileId: number
    name: number
    description: number
    category: number
    frequency: number
    targetValue: number
    unit: number
    color: number
    icon: number
    reminder: number
    isActive: number
    currentStreak: number
    longestStreak: number
    lastCompletedDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HabitAvgAggregateInputType = {
    targetValue?: true
    currentStreak?: true
    longestStreak?: true
  }

  export type HabitSumAggregateInputType = {
    targetValue?: true
    currentStreak?: true
    longestStreak?: true
  }

  export type HabitMinAggregateInputType = {
    id?: true
    profileId?: true
    name?: true
    description?: true
    category?: true
    frequency?: true
    targetValue?: true
    unit?: true
    color?: true
    icon?: true
    isActive?: true
    currentStreak?: true
    longestStreak?: true
    lastCompletedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HabitMaxAggregateInputType = {
    id?: true
    profileId?: true
    name?: true
    description?: true
    category?: true
    frequency?: true
    targetValue?: true
    unit?: true
    color?: true
    icon?: true
    isActive?: true
    currentStreak?: true
    longestStreak?: true
    lastCompletedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HabitCountAggregateInputType = {
    id?: true
    profileId?: true
    name?: true
    description?: true
    category?: true
    frequency?: true
    targetValue?: true
    unit?: true
    color?: true
    icon?: true
    reminder?: true
    isActive?: true
    currentStreak?: true
    longestStreak?: true
    lastCompletedDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HabitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Habit to aggregate.
     */
    where?: HabitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Habits to fetch.
     */
    orderBy?: HabitOrderByWithRelationInput | HabitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HabitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Habits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Habits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Habits
    **/
    _count?: true | HabitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HabitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HabitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HabitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HabitMaxAggregateInputType
  }

  export type GetHabitAggregateType<T extends HabitAggregateArgs> = {
        [P in keyof T & keyof AggregateHabit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHabit[P]>
      : GetScalarType<T[P], AggregateHabit[P]>
  }




  export type HabitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitWhereInput
    orderBy?: HabitOrderByWithAggregationInput | HabitOrderByWithAggregationInput[]
    by: HabitScalarFieldEnum[] | HabitScalarFieldEnum
    having?: HabitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HabitCountAggregateInputType | true
    _avg?: HabitAvgAggregateInputType
    _sum?: HabitSumAggregateInputType
    _min?: HabitMinAggregateInputType
    _max?: HabitMaxAggregateInputType
  }

  export type HabitGroupByOutputType = {
    id: string
    profileId: string
    name: string
    description: string | null
    category: string | null
    frequency: $Enums.HabitFrequency
    targetValue: number
    unit: string | null
    color: string | null
    icon: string | null
    reminder: JsonValue | null
    isActive: boolean
    currentStreak: number
    longestStreak: number
    lastCompletedDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: HabitCountAggregateOutputType | null
    _avg: HabitAvgAggregateOutputType | null
    _sum: HabitSumAggregateOutputType | null
    _min: HabitMinAggregateOutputType | null
    _max: HabitMaxAggregateOutputType | null
  }

  type GetHabitGroupByPayload<T extends HabitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HabitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HabitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HabitGroupByOutputType[P]>
            : GetScalarType<T[P], HabitGroupByOutputType[P]>
        }
      >
    >


  export type HabitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    frequency?: boolean
    targetValue?: boolean
    unit?: boolean
    color?: boolean
    icon?: boolean
    reminder?: boolean
    isActive?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastCompletedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
    completions?: boolean | Habit$completionsArgs<ExtArgs>
    _count?: boolean | HabitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habit"]>

  export type HabitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    frequency?: boolean
    targetValue?: boolean
    unit?: boolean
    color?: boolean
    icon?: boolean
    reminder?: boolean
    isActive?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastCompletedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habit"]>

  export type HabitSelectScalar = {
    id?: boolean
    profileId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    frequency?: boolean
    targetValue?: boolean
    unit?: boolean
    color?: boolean
    icon?: boolean
    reminder?: boolean
    isActive?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastCompletedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HabitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
    completions?: boolean | Habit$completionsArgs<ExtArgs>
    _count?: boolean | HabitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HabitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
  }

  export type $HabitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Habit"
    objects: {
      profile: Prisma.$LifeOSProfilePayload<ExtArgs>
      completions: Prisma.$HabitCompletionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      name: string
      description: string | null
      category: string | null
      frequency: $Enums.HabitFrequency
      targetValue: number
      unit: string | null
      color: string | null
      icon: string | null
      reminder: Prisma.JsonValue | null
      isActive: boolean
      currentStreak: number
      longestStreak: number
      lastCompletedDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["habit"]>
    composites: {}
  }

  type HabitGetPayload<S extends boolean | null | undefined | HabitDefaultArgs> = $Result.GetResult<Prisma.$HabitPayload, S>

  type HabitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HabitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HabitCountAggregateInputType | true
    }

  export interface HabitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Habit'], meta: { name: 'Habit' } }
    /**
     * Find zero or one Habit that matches the filter.
     * @param {HabitFindUniqueArgs} args - Arguments to find a Habit
     * @example
     * // Get one Habit
     * const habit = await prisma.habit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HabitFindUniqueArgs>(args: SelectSubset<T, HabitFindUniqueArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Habit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HabitFindUniqueOrThrowArgs} args - Arguments to find a Habit
     * @example
     * // Get one Habit
     * const habit = await prisma.habit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HabitFindUniqueOrThrowArgs>(args: SelectSubset<T, HabitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Habit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitFindFirstArgs} args - Arguments to find a Habit
     * @example
     * // Get one Habit
     * const habit = await prisma.habit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HabitFindFirstArgs>(args?: SelectSubset<T, HabitFindFirstArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Habit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitFindFirstOrThrowArgs} args - Arguments to find a Habit
     * @example
     * // Get one Habit
     * const habit = await prisma.habit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HabitFindFirstOrThrowArgs>(args?: SelectSubset<T, HabitFindFirstOrThrowArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Habits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Habits
     * const habits = await prisma.habit.findMany()
     * 
     * // Get first 10 Habits
     * const habits = await prisma.habit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const habitWithIdOnly = await prisma.habit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HabitFindManyArgs>(args?: SelectSubset<T, HabitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Habit.
     * @param {HabitCreateArgs} args - Arguments to create a Habit.
     * @example
     * // Create one Habit
     * const Habit = await prisma.habit.create({
     *   data: {
     *     // ... data to create a Habit
     *   }
     * })
     * 
     */
    create<T extends HabitCreateArgs>(args: SelectSubset<T, HabitCreateArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Habits.
     * @param {HabitCreateManyArgs} args - Arguments to create many Habits.
     * @example
     * // Create many Habits
     * const habit = await prisma.habit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HabitCreateManyArgs>(args?: SelectSubset<T, HabitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Habits and returns the data saved in the database.
     * @param {HabitCreateManyAndReturnArgs} args - Arguments to create many Habits.
     * @example
     * // Create many Habits
     * const habit = await prisma.habit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Habits and only return the `id`
     * const habitWithIdOnly = await prisma.habit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HabitCreateManyAndReturnArgs>(args?: SelectSubset<T, HabitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Habit.
     * @param {HabitDeleteArgs} args - Arguments to delete one Habit.
     * @example
     * // Delete one Habit
     * const Habit = await prisma.habit.delete({
     *   where: {
     *     // ... filter to delete one Habit
     *   }
     * })
     * 
     */
    delete<T extends HabitDeleteArgs>(args: SelectSubset<T, HabitDeleteArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Habit.
     * @param {HabitUpdateArgs} args - Arguments to update one Habit.
     * @example
     * // Update one Habit
     * const habit = await prisma.habit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HabitUpdateArgs>(args: SelectSubset<T, HabitUpdateArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Habits.
     * @param {HabitDeleteManyArgs} args - Arguments to filter Habits to delete.
     * @example
     * // Delete a few Habits
     * const { count } = await prisma.habit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HabitDeleteManyArgs>(args?: SelectSubset<T, HabitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Habits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Habits
     * const habit = await prisma.habit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HabitUpdateManyArgs>(args: SelectSubset<T, HabitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Habit.
     * @param {HabitUpsertArgs} args - Arguments to update or create a Habit.
     * @example
     * // Update or create a Habit
     * const habit = await prisma.habit.upsert({
     *   create: {
     *     // ... data to create a Habit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Habit we want to update
     *   }
     * })
     */
    upsert<T extends HabitUpsertArgs>(args: SelectSubset<T, HabitUpsertArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Habits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitCountArgs} args - Arguments to filter Habits to count.
     * @example
     * // Count the number of Habits
     * const count = await prisma.habit.count({
     *   where: {
     *     // ... the filter for the Habits we want to count
     *   }
     * })
    **/
    count<T extends HabitCountArgs>(
      args?: Subset<T, HabitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HabitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Habit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HabitAggregateArgs>(args: Subset<T, HabitAggregateArgs>): Prisma.PrismaPromise<GetHabitAggregateType<T>>

    /**
     * Group by Habit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HabitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HabitGroupByArgs['orderBy'] }
        : { orderBy?: HabitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HabitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHabitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Habit model
   */
  readonly fields: HabitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Habit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HabitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends LifeOSProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LifeOSProfileDefaultArgs<ExtArgs>>): Prisma__LifeOSProfileClient<$Result.GetResult<Prisma.$LifeOSProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    completions<T extends Habit$completionsArgs<ExtArgs> = {}>(args?: Subset<T, Habit$completionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Habit model
   */ 
  interface HabitFieldRefs {
    readonly id: FieldRef<"Habit", 'String'>
    readonly profileId: FieldRef<"Habit", 'String'>
    readonly name: FieldRef<"Habit", 'String'>
    readonly description: FieldRef<"Habit", 'String'>
    readonly category: FieldRef<"Habit", 'String'>
    readonly frequency: FieldRef<"Habit", 'HabitFrequency'>
    readonly targetValue: FieldRef<"Habit", 'Int'>
    readonly unit: FieldRef<"Habit", 'String'>
    readonly color: FieldRef<"Habit", 'String'>
    readonly icon: FieldRef<"Habit", 'String'>
    readonly reminder: FieldRef<"Habit", 'Json'>
    readonly isActive: FieldRef<"Habit", 'Boolean'>
    readonly currentStreak: FieldRef<"Habit", 'Int'>
    readonly longestStreak: FieldRef<"Habit", 'Int'>
    readonly lastCompletedDate: FieldRef<"Habit", 'DateTime'>
    readonly createdAt: FieldRef<"Habit", 'DateTime'>
    readonly updatedAt: FieldRef<"Habit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Habit findUnique
   */
  export type HabitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * Filter, which Habit to fetch.
     */
    where: HabitWhereUniqueInput
  }

  /**
   * Habit findUniqueOrThrow
   */
  export type HabitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * Filter, which Habit to fetch.
     */
    where: HabitWhereUniqueInput
  }

  /**
   * Habit findFirst
   */
  export type HabitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * Filter, which Habit to fetch.
     */
    where?: HabitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Habits to fetch.
     */
    orderBy?: HabitOrderByWithRelationInput | HabitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Habits.
     */
    cursor?: HabitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Habits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Habits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Habits.
     */
    distinct?: HabitScalarFieldEnum | HabitScalarFieldEnum[]
  }

  /**
   * Habit findFirstOrThrow
   */
  export type HabitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * Filter, which Habit to fetch.
     */
    where?: HabitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Habits to fetch.
     */
    orderBy?: HabitOrderByWithRelationInput | HabitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Habits.
     */
    cursor?: HabitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Habits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Habits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Habits.
     */
    distinct?: HabitScalarFieldEnum | HabitScalarFieldEnum[]
  }

  /**
   * Habit findMany
   */
  export type HabitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * Filter, which Habits to fetch.
     */
    where?: HabitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Habits to fetch.
     */
    orderBy?: HabitOrderByWithRelationInput | HabitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Habits.
     */
    cursor?: HabitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Habits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Habits.
     */
    skip?: number
    distinct?: HabitScalarFieldEnum | HabitScalarFieldEnum[]
  }

  /**
   * Habit create
   */
  export type HabitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * The data needed to create a Habit.
     */
    data: XOR<HabitCreateInput, HabitUncheckedCreateInput>
  }

  /**
   * Habit createMany
   */
  export type HabitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Habits.
     */
    data: HabitCreateManyInput | HabitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Habit createManyAndReturn
   */
  export type HabitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Habits.
     */
    data: HabitCreateManyInput | HabitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Habit update
   */
  export type HabitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * The data needed to update a Habit.
     */
    data: XOR<HabitUpdateInput, HabitUncheckedUpdateInput>
    /**
     * Choose, which Habit to update.
     */
    where: HabitWhereUniqueInput
  }

  /**
   * Habit updateMany
   */
  export type HabitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Habits.
     */
    data: XOR<HabitUpdateManyMutationInput, HabitUncheckedUpdateManyInput>
    /**
     * Filter which Habits to update
     */
    where?: HabitWhereInput
  }

  /**
   * Habit upsert
   */
  export type HabitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * The filter to search for the Habit to update in case it exists.
     */
    where: HabitWhereUniqueInput
    /**
     * In case the Habit found by the `where` argument doesn't exist, create a new Habit with this data.
     */
    create: XOR<HabitCreateInput, HabitUncheckedCreateInput>
    /**
     * In case the Habit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HabitUpdateInput, HabitUncheckedUpdateInput>
  }

  /**
   * Habit delete
   */
  export type HabitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * Filter which Habit to delete.
     */
    where: HabitWhereUniqueInput
  }

  /**
   * Habit deleteMany
   */
  export type HabitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Habits to delete
     */
    where?: HabitWhereInput
  }

  /**
   * Habit.completions
   */
  export type Habit$completionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCompletion
     */
    select?: HabitCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCompletionInclude<ExtArgs> | null
    where?: HabitCompletionWhereInput
    orderBy?: HabitCompletionOrderByWithRelationInput | HabitCompletionOrderByWithRelationInput[]
    cursor?: HabitCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HabitCompletionScalarFieldEnum | HabitCompletionScalarFieldEnum[]
  }

  /**
   * Habit without action
   */
  export type HabitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
  }


  /**
   * Model HabitCompletion
   */

  export type AggregateHabitCompletion = {
    _count: HabitCompletionCountAggregateOutputType | null
    _avg: HabitCompletionAvgAggregateOutputType | null
    _sum: HabitCompletionSumAggregateOutputType | null
    _min: HabitCompletionMinAggregateOutputType | null
    _max: HabitCompletionMaxAggregateOutputType | null
  }

  export type HabitCompletionAvgAggregateOutputType = {
    value: number | null
    satisfaction: number | null
    difficulty: number | null
  }

  export type HabitCompletionSumAggregateOutputType = {
    value: number | null
    satisfaction: number | null
    difficulty: number | null
  }

  export type HabitCompletionMinAggregateOutputType = {
    id: string | null
    habitId: string | null
    completedAt: Date | null
    value: number | null
    notes: string | null
    satisfaction: number | null
    difficulty: number | null
  }

  export type HabitCompletionMaxAggregateOutputType = {
    id: string | null
    habitId: string | null
    completedAt: Date | null
    value: number | null
    notes: string | null
    satisfaction: number | null
    difficulty: number | null
  }

  export type HabitCompletionCountAggregateOutputType = {
    id: number
    habitId: number
    completedAt: number
    value: number
    notes: number
    satisfaction: number
    difficulty: number
    _all: number
  }


  export type HabitCompletionAvgAggregateInputType = {
    value?: true
    satisfaction?: true
    difficulty?: true
  }

  export type HabitCompletionSumAggregateInputType = {
    value?: true
    satisfaction?: true
    difficulty?: true
  }

  export type HabitCompletionMinAggregateInputType = {
    id?: true
    habitId?: true
    completedAt?: true
    value?: true
    notes?: true
    satisfaction?: true
    difficulty?: true
  }

  export type HabitCompletionMaxAggregateInputType = {
    id?: true
    habitId?: true
    completedAt?: true
    value?: true
    notes?: true
    satisfaction?: true
    difficulty?: true
  }

  export type HabitCompletionCountAggregateInputType = {
    id?: true
    habitId?: true
    completedAt?: true
    value?: true
    notes?: true
    satisfaction?: true
    difficulty?: true
    _all?: true
  }

  export type HabitCompletionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HabitCompletion to aggregate.
     */
    where?: HabitCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitCompletions to fetch.
     */
    orderBy?: HabitCompletionOrderByWithRelationInput | HabitCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HabitCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HabitCompletions
    **/
    _count?: true | HabitCompletionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HabitCompletionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HabitCompletionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HabitCompletionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HabitCompletionMaxAggregateInputType
  }

  export type GetHabitCompletionAggregateType<T extends HabitCompletionAggregateArgs> = {
        [P in keyof T & keyof AggregateHabitCompletion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHabitCompletion[P]>
      : GetScalarType<T[P], AggregateHabitCompletion[P]>
  }




  export type HabitCompletionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitCompletionWhereInput
    orderBy?: HabitCompletionOrderByWithAggregationInput | HabitCompletionOrderByWithAggregationInput[]
    by: HabitCompletionScalarFieldEnum[] | HabitCompletionScalarFieldEnum
    having?: HabitCompletionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HabitCompletionCountAggregateInputType | true
    _avg?: HabitCompletionAvgAggregateInputType
    _sum?: HabitCompletionSumAggregateInputType
    _min?: HabitCompletionMinAggregateInputType
    _max?: HabitCompletionMaxAggregateInputType
  }

  export type HabitCompletionGroupByOutputType = {
    id: string
    habitId: string
    completedAt: Date
    value: number
    notes: string | null
    satisfaction: number | null
    difficulty: number | null
    _count: HabitCompletionCountAggregateOutputType | null
    _avg: HabitCompletionAvgAggregateOutputType | null
    _sum: HabitCompletionSumAggregateOutputType | null
    _min: HabitCompletionMinAggregateOutputType | null
    _max: HabitCompletionMaxAggregateOutputType | null
  }

  type GetHabitCompletionGroupByPayload<T extends HabitCompletionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HabitCompletionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HabitCompletionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HabitCompletionGroupByOutputType[P]>
            : GetScalarType<T[P], HabitCompletionGroupByOutputType[P]>
        }
      >
    >


  export type HabitCompletionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    habitId?: boolean
    completedAt?: boolean
    value?: boolean
    notes?: boolean
    satisfaction?: boolean
    difficulty?: boolean
    habit?: boolean | HabitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habitCompletion"]>

  export type HabitCompletionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    habitId?: boolean
    completedAt?: boolean
    value?: boolean
    notes?: boolean
    satisfaction?: boolean
    difficulty?: boolean
    habit?: boolean | HabitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habitCompletion"]>

  export type HabitCompletionSelectScalar = {
    id?: boolean
    habitId?: boolean
    completedAt?: boolean
    value?: boolean
    notes?: boolean
    satisfaction?: boolean
    difficulty?: boolean
  }

  export type HabitCompletionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    habit?: boolean | HabitDefaultArgs<ExtArgs>
  }
  export type HabitCompletionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    habit?: boolean | HabitDefaultArgs<ExtArgs>
  }

  export type $HabitCompletionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HabitCompletion"
    objects: {
      habit: Prisma.$HabitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      habitId: string
      completedAt: Date
      value: number
      notes: string | null
      satisfaction: number | null
      difficulty: number | null
    }, ExtArgs["result"]["habitCompletion"]>
    composites: {}
  }

  type HabitCompletionGetPayload<S extends boolean | null | undefined | HabitCompletionDefaultArgs> = $Result.GetResult<Prisma.$HabitCompletionPayload, S>

  type HabitCompletionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HabitCompletionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HabitCompletionCountAggregateInputType | true
    }

  export interface HabitCompletionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HabitCompletion'], meta: { name: 'HabitCompletion' } }
    /**
     * Find zero or one HabitCompletion that matches the filter.
     * @param {HabitCompletionFindUniqueArgs} args - Arguments to find a HabitCompletion
     * @example
     * // Get one HabitCompletion
     * const habitCompletion = await prisma.habitCompletion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HabitCompletionFindUniqueArgs>(args: SelectSubset<T, HabitCompletionFindUniqueArgs<ExtArgs>>): Prisma__HabitCompletionClient<$Result.GetResult<Prisma.$HabitCompletionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HabitCompletion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HabitCompletionFindUniqueOrThrowArgs} args - Arguments to find a HabitCompletion
     * @example
     * // Get one HabitCompletion
     * const habitCompletion = await prisma.habitCompletion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HabitCompletionFindUniqueOrThrowArgs>(args: SelectSubset<T, HabitCompletionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HabitCompletionClient<$Result.GetResult<Prisma.$HabitCompletionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HabitCompletion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitCompletionFindFirstArgs} args - Arguments to find a HabitCompletion
     * @example
     * // Get one HabitCompletion
     * const habitCompletion = await prisma.habitCompletion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HabitCompletionFindFirstArgs>(args?: SelectSubset<T, HabitCompletionFindFirstArgs<ExtArgs>>): Prisma__HabitCompletionClient<$Result.GetResult<Prisma.$HabitCompletionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HabitCompletion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitCompletionFindFirstOrThrowArgs} args - Arguments to find a HabitCompletion
     * @example
     * // Get one HabitCompletion
     * const habitCompletion = await prisma.habitCompletion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HabitCompletionFindFirstOrThrowArgs>(args?: SelectSubset<T, HabitCompletionFindFirstOrThrowArgs<ExtArgs>>): Prisma__HabitCompletionClient<$Result.GetResult<Prisma.$HabitCompletionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HabitCompletions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitCompletionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HabitCompletions
     * const habitCompletions = await prisma.habitCompletion.findMany()
     * 
     * // Get first 10 HabitCompletions
     * const habitCompletions = await prisma.habitCompletion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const habitCompletionWithIdOnly = await prisma.habitCompletion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HabitCompletionFindManyArgs>(args?: SelectSubset<T, HabitCompletionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitCompletionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HabitCompletion.
     * @param {HabitCompletionCreateArgs} args - Arguments to create a HabitCompletion.
     * @example
     * // Create one HabitCompletion
     * const HabitCompletion = await prisma.habitCompletion.create({
     *   data: {
     *     // ... data to create a HabitCompletion
     *   }
     * })
     * 
     */
    create<T extends HabitCompletionCreateArgs>(args: SelectSubset<T, HabitCompletionCreateArgs<ExtArgs>>): Prisma__HabitCompletionClient<$Result.GetResult<Prisma.$HabitCompletionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HabitCompletions.
     * @param {HabitCompletionCreateManyArgs} args - Arguments to create many HabitCompletions.
     * @example
     * // Create many HabitCompletions
     * const habitCompletion = await prisma.habitCompletion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HabitCompletionCreateManyArgs>(args?: SelectSubset<T, HabitCompletionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HabitCompletions and returns the data saved in the database.
     * @param {HabitCompletionCreateManyAndReturnArgs} args - Arguments to create many HabitCompletions.
     * @example
     * // Create many HabitCompletions
     * const habitCompletion = await prisma.habitCompletion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HabitCompletions and only return the `id`
     * const habitCompletionWithIdOnly = await prisma.habitCompletion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HabitCompletionCreateManyAndReturnArgs>(args?: SelectSubset<T, HabitCompletionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitCompletionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HabitCompletion.
     * @param {HabitCompletionDeleteArgs} args - Arguments to delete one HabitCompletion.
     * @example
     * // Delete one HabitCompletion
     * const HabitCompletion = await prisma.habitCompletion.delete({
     *   where: {
     *     // ... filter to delete one HabitCompletion
     *   }
     * })
     * 
     */
    delete<T extends HabitCompletionDeleteArgs>(args: SelectSubset<T, HabitCompletionDeleteArgs<ExtArgs>>): Prisma__HabitCompletionClient<$Result.GetResult<Prisma.$HabitCompletionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HabitCompletion.
     * @param {HabitCompletionUpdateArgs} args - Arguments to update one HabitCompletion.
     * @example
     * // Update one HabitCompletion
     * const habitCompletion = await prisma.habitCompletion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HabitCompletionUpdateArgs>(args: SelectSubset<T, HabitCompletionUpdateArgs<ExtArgs>>): Prisma__HabitCompletionClient<$Result.GetResult<Prisma.$HabitCompletionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HabitCompletions.
     * @param {HabitCompletionDeleteManyArgs} args - Arguments to filter HabitCompletions to delete.
     * @example
     * // Delete a few HabitCompletions
     * const { count } = await prisma.habitCompletion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HabitCompletionDeleteManyArgs>(args?: SelectSubset<T, HabitCompletionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HabitCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitCompletionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HabitCompletions
     * const habitCompletion = await prisma.habitCompletion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HabitCompletionUpdateManyArgs>(args: SelectSubset<T, HabitCompletionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HabitCompletion.
     * @param {HabitCompletionUpsertArgs} args - Arguments to update or create a HabitCompletion.
     * @example
     * // Update or create a HabitCompletion
     * const habitCompletion = await prisma.habitCompletion.upsert({
     *   create: {
     *     // ... data to create a HabitCompletion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HabitCompletion we want to update
     *   }
     * })
     */
    upsert<T extends HabitCompletionUpsertArgs>(args: SelectSubset<T, HabitCompletionUpsertArgs<ExtArgs>>): Prisma__HabitCompletionClient<$Result.GetResult<Prisma.$HabitCompletionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HabitCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitCompletionCountArgs} args - Arguments to filter HabitCompletions to count.
     * @example
     * // Count the number of HabitCompletions
     * const count = await prisma.habitCompletion.count({
     *   where: {
     *     // ... the filter for the HabitCompletions we want to count
     *   }
     * })
    **/
    count<T extends HabitCompletionCountArgs>(
      args?: Subset<T, HabitCompletionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HabitCompletionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HabitCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitCompletionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HabitCompletionAggregateArgs>(args: Subset<T, HabitCompletionAggregateArgs>): Prisma.PrismaPromise<GetHabitCompletionAggregateType<T>>

    /**
     * Group by HabitCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitCompletionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HabitCompletionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HabitCompletionGroupByArgs['orderBy'] }
        : { orderBy?: HabitCompletionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HabitCompletionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHabitCompletionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HabitCompletion model
   */
  readonly fields: HabitCompletionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HabitCompletion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HabitCompletionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    habit<T extends HabitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HabitDefaultArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HabitCompletion model
   */ 
  interface HabitCompletionFieldRefs {
    readonly id: FieldRef<"HabitCompletion", 'String'>
    readonly habitId: FieldRef<"HabitCompletion", 'String'>
    readonly completedAt: FieldRef<"HabitCompletion", 'DateTime'>
    readonly value: FieldRef<"HabitCompletion", 'Int'>
    readonly notes: FieldRef<"HabitCompletion", 'String'>
    readonly satisfaction: FieldRef<"HabitCompletion", 'Int'>
    readonly difficulty: FieldRef<"HabitCompletion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * HabitCompletion findUnique
   */
  export type HabitCompletionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCompletion
     */
    select?: HabitCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCompletionInclude<ExtArgs> | null
    /**
     * Filter, which HabitCompletion to fetch.
     */
    where: HabitCompletionWhereUniqueInput
  }

  /**
   * HabitCompletion findUniqueOrThrow
   */
  export type HabitCompletionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCompletion
     */
    select?: HabitCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCompletionInclude<ExtArgs> | null
    /**
     * Filter, which HabitCompletion to fetch.
     */
    where: HabitCompletionWhereUniqueInput
  }

  /**
   * HabitCompletion findFirst
   */
  export type HabitCompletionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCompletion
     */
    select?: HabitCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCompletionInclude<ExtArgs> | null
    /**
     * Filter, which HabitCompletion to fetch.
     */
    where?: HabitCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitCompletions to fetch.
     */
    orderBy?: HabitCompletionOrderByWithRelationInput | HabitCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HabitCompletions.
     */
    cursor?: HabitCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HabitCompletions.
     */
    distinct?: HabitCompletionScalarFieldEnum | HabitCompletionScalarFieldEnum[]
  }

  /**
   * HabitCompletion findFirstOrThrow
   */
  export type HabitCompletionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCompletion
     */
    select?: HabitCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCompletionInclude<ExtArgs> | null
    /**
     * Filter, which HabitCompletion to fetch.
     */
    where?: HabitCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitCompletions to fetch.
     */
    orderBy?: HabitCompletionOrderByWithRelationInput | HabitCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HabitCompletions.
     */
    cursor?: HabitCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HabitCompletions.
     */
    distinct?: HabitCompletionScalarFieldEnum | HabitCompletionScalarFieldEnum[]
  }

  /**
   * HabitCompletion findMany
   */
  export type HabitCompletionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCompletion
     */
    select?: HabitCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCompletionInclude<ExtArgs> | null
    /**
     * Filter, which HabitCompletions to fetch.
     */
    where?: HabitCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitCompletions to fetch.
     */
    orderBy?: HabitCompletionOrderByWithRelationInput | HabitCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HabitCompletions.
     */
    cursor?: HabitCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitCompletions.
     */
    skip?: number
    distinct?: HabitCompletionScalarFieldEnum | HabitCompletionScalarFieldEnum[]
  }

  /**
   * HabitCompletion create
   */
  export type HabitCompletionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCompletion
     */
    select?: HabitCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCompletionInclude<ExtArgs> | null
    /**
     * The data needed to create a HabitCompletion.
     */
    data: XOR<HabitCompletionCreateInput, HabitCompletionUncheckedCreateInput>
  }

  /**
   * HabitCompletion createMany
   */
  export type HabitCompletionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HabitCompletions.
     */
    data: HabitCompletionCreateManyInput | HabitCompletionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HabitCompletion createManyAndReturn
   */
  export type HabitCompletionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCompletion
     */
    select?: HabitCompletionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HabitCompletions.
     */
    data: HabitCompletionCreateManyInput | HabitCompletionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCompletionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HabitCompletion update
   */
  export type HabitCompletionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCompletion
     */
    select?: HabitCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCompletionInclude<ExtArgs> | null
    /**
     * The data needed to update a HabitCompletion.
     */
    data: XOR<HabitCompletionUpdateInput, HabitCompletionUncheckedUpdateInput>
    /**
     * Choose, which HabitCompletion to update.
     */
    where: HabitCompletionWhereUniqueInput
  }

  /**
   * HabitCompletion updateMany
   */
  export type HabitCompletionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HabitCompletions.
     */
    data: XOR<HabitCompletionUpdateManyMutationInput, HabitCompletionUncheckedUpdateManyInput>
    /**
     * Filter which HabitCompletions to update
     */
    where?: HabitCompletionWhereInput
  }

  /**
   * HabitCompletion upsert
   */
  export type HabitCompletionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCompletion
     */
    select?: HabitCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCompletionInclude<ExtArgs> | null
    /**
     * The filter to search for the HabitCompletion to update in case it exists.
     */
    where: HabitCompletionWhereUniqueInput
    /**
     * In case the HabitCompletion found by the `where` argument doesn't exist, create a new HabitCompletion with this data.
     */
    create: XOR<HabitCompletionCreateInput, HabitCompletionUncheckedCreateInput>
    /**
     * In case the HabitCompletion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HabitCompletionUpdateInput, HabitCompletionUncheckedUpdateInput>
  }

  /**
   * HabitCompletion delete
   */
  export type HabitCompletionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCompletion
     */
    select?: HabitCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCompletionInclude<ExtArgs> | null
    /**
     * Filter which HabitCompletion to delete.
     */
    where: HabitCompletionWhereUniqueInput
  }

  /**
   * HabitCompletion deleteMany
   */
  export type HabitCompletionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HabitCompletions to delete
     */
    where?: HabitCompletionWhereInput
  }

  /**
   * HabitCompletion without action
   */
  export type HabitCompletionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCompletion
     */
    select?: HabitCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCompletionInclude<ExtArgs> | null
  }


  /**
   * Model Goal
   */

  export type AggregateGoal = {
    _count: GoalCountAggregateOutputType | null
    _avg: GoalAvgAggregateOutputType | null
    _sum: GoalSumAggregateOutputType | null
    _min: GoalMinAggregateOutputType | null
    _max: GoalMaxAggregateOutputType | null
  }

  export type GoalAvgAggregateOutputType = {
    targetValue: number | null
    currentValue: number | null
    progress: number | null
  }

  export type GoalSumAggregateOutputType = {
    targetValue: number | null
    currentValue: number | null
    progress: number | null
  }

  export type GoalMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    title: string | null
    description: string | null
    category: string | null
    targetValue: number | null
    currentValue: number | null
    unit: string | null
    startDate: Date | null
    targetDate: Date | null
    completedAt: Date | null
    status: $Enums.GoalStatus | null
    priority: $Enums.Priority | null
    progress: number | null
    motivation: string | null
    visualisation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoalMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    title: string | null
    description: string | null
    category: string | null
    targetValue: number | null
    currentValue: number | null
    unit: string | null
    startDate: Date | null
    targetDate: Date | null
    completedAt: Date | null
    status: $Enums.GoalStatus | null
    priority: $Enums.Priority | null
    progress: number | null
    motivation: string | null
    visualisation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoalCountAggregateOutputType = {
    id: number
    profileId: number
    title: number
    description: number
    category: number
    targetValue: number
    currentValue: number
    unit: number
    startDate: number
    targetDate: number
    completedAt: number
    status: number
    priority: number
    progress: number
    motivation: number
    visualisation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GoalAvgAggregateInputType = {
    targetValue?: true
    currentValue?: true
    progress?: true
  }

  export type GoalSumAggregateInputType = {
    targetValue?: true
    currentValue?: true
    progress?: true
  }

  export type GoalMinAggregateInputType = {
    id?: true
    profileId?: true
    title?: true
    description?: true
    category?: true
    targetValue?: true
    currentValue?: true
    unit?: true
    startDate?: true
    targetDate?: true
    completedAt?: true
    status?: true
    priority?: true
    progress?: true
    motivation?: true
    visualisation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoalMaxAggregateInputType = {
    id?: true
    profileId?: true
    title?: true
    description?: true
    category?: true
    targetValue?: true
    currentValue?: true
    unit?: true
    startDate?: true
    targetDate?: true
    completedAt?: true
    status?: true
    priority?: true
    progress?: true
    motivation?: true
    visualisation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoalCountAggregateInputType = {
    id?: true
    profileId?: true
    title?: true
    description?: true
    category?: true
    targetValue?: true
    currentValue?: true
    unit?: true
    startDate?: true
    targetDate?: true
    completedAt?: true
    status?: true
    priority?: true
    progress?: true
    motivation?: true
    visualisation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goal to aggregate.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Goals
    **/
    _count?: true | GoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoalMaxAggregateInputType
  }

  export type GetGoalAggregateType<T extends GoalAggregateArgs> = {
        [P in keyof T & keyof AggregateGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoal[P]>
      : GetScalarType<T[P], AggregateGoal[P]>
  }




  export type GoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalWhereInput
    orderBy?: GoalOrderByWithAggregationInput | GoalOrderByWithAggregationInput[]
    by: GoalScalarFieldEnum[] | GoalScalarFieldEnum
    having?: GoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoalCountAggregateInputType | true
    _avg?: GoalAvgAggregateInputType
    _sum?: GoalSumAggregateInputType
    _min?: GoalMinAggregateInputType
    _max?: GoalMaxAggregateInputType
  }

  export type GoalGroupByOutputType = {
    id: string
    profileId: string
    title: string
    description: string | null
    category: string | null
    targetValue: number | null
    currentValue: number
    unit: string | null
    startDate: Date
    targetDate: Date | null
    completedAt: Date | null
    status: $Enums.GoalStatus
    priority: $Enums.Priority
    progress: number
    motivation: string | null
    visualisation: string | null
    createdAt: Date
    updatedAt: Date
    _count: GoalCountAggregateOutputType | null
    _avg: GoalAvgAggregateOutputType | null
    _sum: GoalSumAggregateOutputType | null
    _min: GoalMinAggregateOutputType | null
    _max: GoalMaxAggregateOutputType | null
  }

  type GetGoalGroupByPayload<T extends GoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoalGroupByOutputType[P]>
            : GetScalarType<T[P], GoalGroupByOutputType[P]>
        }
      >
    >


  export type GoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    targetValue?: boolean
    currentValue?: boolean
    unit?: boolean
    startDate?: boolean
    targetDate?: boolean
    completedAt?: boolean
    status?: boolean
    priority?: boolean
    progress?: boolean
    motivation?: boolean
    visualisation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
    milestones?: boolean | Goal$milestonesArgs<ExtArgs>
    updates?: boolean | Goal$updatesArgs<ExtArgs>
    _count?: boolean | GoalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    targetValue?: boolean
    currentValue?: boolean
    unit?: boolean
    startDate?: boolean
    targetDate?: boolean
    completedAt?: boolean
    status?: boolean
    priority?: boolean
    progress?: boolean
    motivation?: boolean
    visualisation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goal"]>

  export type GoalSelectScalar = {
    id?: boolean
    profileId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    targetValue?: boolean
    currentValue?: boolean
    unit?: boolean
    startDate?: boolean
    targetDate?: boolean
    completedAt?: boolean
    status?: boolean
    priority?: boolean
    progress?: boolean
    motivation?: boolean
    visualisation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
    milestones?: boolean | Goal$milestonesArgs<ExtArgs>
    updates?: boolean | Goal$updatesArgs<ExtArgs>
    _count?: boolean | GoalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GoalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
  }

  export type $GoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Goal"
    objects: {
      profile: Prisma.$LifeOSProfilePayload<ExtArgs>
      milestones: Prisma.$GoalMilestonePayload<ExtArgs>[]
      updates: Prisma.$GoalUpdatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      title: string
      description: string | null
      category: string | null
      targetValue: number | null
      currentValue: number
      unit: string | null
      startDate: Date
      targetDate: Date | null
      completedAt: Date | null
      status: $Enums.GoalStatus
      priority: $Enums.Priority
      progress: number
      motivation: string | null
      visualisation: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["goal"]>
    composites: {}
  }

  type GoalGetPayload<S extends boolean | null | undefined | GoalDefaultArgs> = $Result.GetResult<Prisma.$GoalPayload, S>

  type GoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GoalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GoalCountAggregateInputType | true
    }

  export interface GoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Goal'], meta: { name: 'Goal' } }
    /**
     * Find zero or one Goal that matches the filter.
     * @param {GoalFindUniqueArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoalFindUniqueArgs>(args: SelectSubset<T, GoalFindUniqueArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Goal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GoalFindUniqueOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoalFindUniqueOrThrowArgs>(args: SelectSubset<T, GoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Goal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindFirstArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoalFindFirstArgs>(args?: SelectSubset<T, GoalFindFirstArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Goal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindFirstOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoalFindFirstOrThrowArgs>(args?: SelectSubset<T, GoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Goals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Goals
     * const goals = await prisma.goal.findMany()
     * 
     * // Get first 10 Goals
     * const goals = await prisma.goal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goalWithIdOnly = await prisma.goal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoalFindManyArgs>(args?: SelectSubset<T, GoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Goal.
     * @param {GoalCreateArgs} args - Arguments to create a Goal.
     * @example
     * // Create one Goal
     * const Goal = await prisma.goal.create({
     *   data: {
     *     // ... data to create a Goal
     *   }
     * })
     * 
     */
    create<T extends GoalCreateArgs>(args: SelectSubset<T, GoalCreateArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Goals.
     * @param {GoalCreateManyArgs} args - Arguments to create many Goals.
     * @example
     * // Create many Goals
     * const goal = await prisma.goal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoalCreateManyArgs>(args?: SelectSubset<T, GoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Goals and returns the data saved in the database.
     * @param {GoalCreateManyAndReturnArgs} args - Arguments to create many Goals.
     * @example
     * // Create many Goals
     * const goal = await prisma.goal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Goals and only return the `id`
     * const goalWithIdOnly = await prisma.goal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoalCreateManyAndReturnArgs>(args?: SelectSubset<T, GoalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Goal.
     * @param {GoalDeleteArgs} args - Arguments to delete one Goal.
     * @example
     * // Delete one Goal
     * const Goal = await prisma.goal.delete({
     *   where: {
     *     // ... filter to delete one Goal
     *   }
     * })
     * 
     */
    delete<T extends GoalDeleteArgs>(args: SelectSubset<T, GoalDeleteArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Goal.
     * @param {GoalUpdateArgs} args - Arguments to update one Goal.
     * @example
     * // Update one Goal
     * const goal = await prisma.goal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoalUpdateArgs>(args: SelectSubset<T, GoalUpdateArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Goals.
     * @param {GoalDeleteManyArgs} args - Arguments to filter Goals to delete.
     * @example
     * // Delete a few Goals
     * const { count } = await prisma.goal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoalDeleteManyArgs>(args?: SelectSubset<T, GoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Goals
     * const goal = await prisma.goal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoalUpdateManyArgs>(args: SelectSubset<T, GoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Goal.
     * @param {GoalUpsertArgs} args - Arguments to update or create a Goal.
     * @example
     * // Update or create a Goal
     * const goal = await prisma.goal.upsert({
     *   create: {
     *     // ... data to create a Goal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Goal we want to update
     *   }
     * })
     */
    upsert<T extends GoalUpsertArgs>(args: SelectSubset<T, GoalUpsertArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalCountArgs} args - Arguments to filter Goals to count.
     * @example
     * // Count the number of Goals
     * const count = await prisma.goal.count({
     *   where: {
     *     // ... the filter for the Goals we want to count
     *   }
     * })
    **/
    count<T extends GoalCountArgs>(
      args?: Subset<T, GoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoalAggregateArgs>(args: Subset<T, GoalAggregateArgs>): Prisma.PrismaPromise<GetGoalAggregateType<T>>

    /**
     * Group by Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoalGroupByArgs['orderBy'] }
        : { orderBy?: GoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Goal model
   */
  readonly fields: GoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Goal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends LifeOSProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LifeOSProfileDefaultArgs<ExtArgs>>): Prisma__LifeOSProfileClient<$Result.GetResult<Prisma.$LifeOSProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    milestones<T extends Goal$milestonesArgs<ExtArgs> = {}>(args?: Subset<T, Goal$milestonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalMilestonePayload<ExtArgs>, T, "findMany"> | Null>
    updates<T extends Goal$updatesArgs<ExtArgs> = {}>(args?: Subset<T, Goal$updatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalUpdatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Goal model
   */ 
  interface GoalFieldRefs {
    readonly id: FieldRef<"Goal", 'String'>
    readonly profileId: FieldRef<"Goal", 'String'>
    readonly title: FieldRef<"Goal", 'String'>
    readonly description: FieldRef<"Goal", 'String'>
    readonly category: FieldRef<"Goal", 'String'>
    readonly targetValue: FieldRef<"Goal", 'Float'>
    readonly currentValue: FieldRef<"Goal", 'Float'>
    readonly unit: FieldRef<"Goal", 'String'>
    readonly startDate: FieldRef<"Goal", 'DateTime'>
    readonly targetDate: FieldRef<"Goal", 'DateTime'>
    readonly completedAt: FieldRef<"Goal", 'DateTime'>
    readonly status: FieldRef<"Goal", 'GoalStatus'>
    readonly priority: FieldRef<"Goal", 'Priority'>
    readonly progress: FieldRef<"Goal", 'Float'>
    readonly motivation: FieldRef<"Goal", 'String'>
    readonly visualisation: FieldRef<"Goal", 'String'>
    readonly createdAt: FieldRef<"Goal", 'DateTime'>
    readonly updatedAt: FieldRef<"Goal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Goal findUnique
   */
  export type GoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal findUniqueOrThrow
   */
  export type GoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal findFirst
   */
  export type GoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goals.
     */
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal findFirstOrThrow
   */
  export type GoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goal to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goals.
     */
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal findMany
   */
  export type GoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter, which Goals to fetch.
     */
    where?: GoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Goals.
     */
    cursor?: GoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goals.
     */
    skip?: number
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[]
  }

  /**
   * Goal create
   */
  export type GoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The data needed to create a Goal.
     */
    data: XOR<GoalCreateInput, GoalUncheckedCreateInput>
  }

  /**
   * Goal createMany
   */
  export type GoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Goals.
     */
    data: GoalCreateManyInput | GoalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Goal createManyAndReturn
   */
  export type GoalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Goals.
     */
    data: GoalCreateManyInput | GoalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Goal update
   */
  export type GoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The data needed to update a Goal.
     */
    data: XOR<GoalUpdateInput, GoalUncheckedUpdateInput>
    /**
     * Choose, which Goal to update.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal updateMany
   */
  export type GoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Goals.
     */
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyInput>
    /**
     * Filter which Goals to update
     */
    where?: GoalWhereInput
  }

  /**
   * Goal upsert
   */
  export type GoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * The filter to search for the Goal to update in case it exists.
     */
    where: GoalWhereUniqueInput
    /**
     * In case the Goal found by the `where` argument doesn't exist, create a new Goal with this data.
     */
    create: XOR<GoalCreateInput, GoalUncheckedCreateInput>
    /**
     * In case the Goal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoalUpdateInput, GoalUncheckedUpdateInput>
  }

  /**
   * Goal delete
   */
  export type GoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
    /**
     * Filter which Goal to delete.
     */
    where: GoalWhereUniqueInput
  }

  /**
   * Goal deleteMany
   */
  export type GoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goals to delete
     */
    where?: GoalWhereInput
  }

  /**
   * Goal.milestones
   */
  export type Goal$milestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalMilestone
     */
    select?: GoalMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalMilestoneInclude<ExtArgs> | null
    where?: GoalMilestoneWhereInput
    orderBy?: GoalMilestoneOrderByWithRelationInput | GoalMilestoneOrderByWithRelationInput[]
    cursor?: GoalMilestoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GoalMilestoneScalarFieldEnum | GoalMilestoneScalarFieldEnum[]
  }

  /**
   * Goal.updates
   */
  export type Goal$updatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalUpdate
     */
    select?: GoalUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalUpdateInclude<ExtArgs> | null
    where?: GoalUpdateWhereInput
    orderBy?: GoalUpdateOrderByWithRelationInput | GoalUpdateOrderByWithRelationInput[]
    cursor?: GoalUpdateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GoalUpdateScalarFieldEnum | GoalUpdateScalarFieldEnum[]
  }

  /**
   * Goal without action
   */
  export type GoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null
  }


  /**
   * Model GoalMilestone
   */

  export type AggregateGoalMilestone = {
    _count: GoalMilestoneCountAggregateOutputType | null
    _avg: GoalMilestoneAvgAggregateOutputType | null
    _sum: GoalMilestoneSumAggregateOutputType | null
    _min: GoalMilestoneMinAggregateOutputType | null
    _max: GoalMilestoneMaxAggregateOutputType | null
  }

  export type GoalMilestoneAvgAggregateOutputType = {
    targetValue: number | null
    currentValue: number | null
  }

  export type GoalMilestoneSumAggregateOutputType = {
    targetValue: number | null
    currentValue: number | null
  }

  export type GoalMilestoneMinAggregateOutputType = {
    id: string | null
    goalId: string | null
    title: string | null
    description: string | null
    targetDate: Date | null
    completedAt: Date | null
    targetValue: number | null
    currentValue: number | null
    status: $Enums.MilestoneStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoalMilestoneMaxAggregateOutputType = {
    id: string | null
    goalId: string | null
    title: string | null
    description: string | null
    targetDate: Date | null
    completedAt: Date | null
    targetValue: number | null
    currentValue: number | null
    status: $Enums.MilestoneStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoalMilestoneCountAggregateOutputType = {
    id: number
    goalId: number
    title: number
    description: number
    targetDate: number
    completedAt: number
    targetValue: number
    currentValue: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GoalMilestoneAvgAggregateInputType = {
    targetValue?: true
    currentValue?: true
  }

  export type GoalMilestoneSumAggregateInputType = {
    targetValue?: true
    currentValue?: true
  }

  export type GoalMilestoneMinAggregateInputType = {
    id?: true
    goalId?: true
    title?: true
    description?: true
    targetDate?: true
    completedAt?: true
    targetValue?: true
    currentValue?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoalMilestoneMaxAggregateInputType = {
    id?: true
    goalId?: true
    title?: true
    description?: true
    targetDate?: true
    completedAt?: true
    targetValue?: true
    currentValue?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoalMilestoneCountAggregateInputType = {
    id?: true
    goalId?: true
    title?: true
    description?: true
    targetDate?: true
    completedAt?: true
    targetValue?: true
    currentValue?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GoalMilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoalMilestone to aggregate.
     */
    where?: GoalMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalMilestones to fetch.
     */
    orderBy?: GoalMilestoneOrderByWithRelationInput | GoalMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoalMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GoalMilestones
    **/
    _count?: true | GoalMilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoalMilestoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoalMilestoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoalMilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoalMilestoneMaxAggregateInputType
  }

  export type GetGoalMilestoneAggregateType<T extends GoalMilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateGoalMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoalMilestone[P]>
      : GetScalarType<T[P], AggregateGoalMilestone[P]>
  }




  export type GoalMilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalMilestoneWhereInput
    orderBy?: GoalMilestoneOrderByWithAggregationInput | GoalMilestoneOrderByWithAggregationInput[]
    by: GoalMilestoneScalarFieldEnum[] | GoalMilestoneScalarFieldEnum
    having?: GoalMilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoalMilestoneCountAggregateInputType | true
    _avg?: GoalMilestoneAvgAggregateInputType
    _sum?: GoalMilestoneSumAggregateInputType
    _min?: GoalMilestoneMinAggregateInputType
    _max?: GoalMilestoneMaxAggregateInputType
  }

  export type GoalMilestoneGroupByOutputType = {
    id: string
    goalId: string
    title: string
    description: string | null
    targetDate: Date | null
    completedAt: Date | null
    targetValue: number | null
    currentValue: number
    status: $Enums.MilestoneStatus
    createdAt: Date
    updatedAt: Date
    _count: GoalMilestoneCountAggregateOutputType | null
    _avg: GoalMilestoneAvgAggregateOutputType | null
    _sum: GoalMilestoneSumAggregateOutputType | null
    _min: GoalMilestoneMinAggregateOutputType | null
    _max: GoalMilestoneMaxAggregateOutputType | null
  }

  type GetGoalMilestoneGroupByPayload<T extends GoalMilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoalMilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoalMilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoalMilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], GoalMilestoneGroupByOutputType[P]>
        }
      >
    >


  export type GoalMilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    title?: boolean
    description?: boolean
    targetDate?: boolean
    completedAt?: boolean
    targetValue?: boolean
    currentValue?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goalMilestone"]>

  export type GoalMilestoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    title?: boolean
    description?: boolean
    targetDate?: boolean
    completedAt?: boolean
    targetValue?: boolean
    currentValue?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goalMilestone"]>

  export type GoalMilestoneSelectScalar = {
    id?: boolean
    goalId?: boolean
    title?: boolean
    description?: boolean
    targetDate?: boolean
    completedAt?: boolean
    targetValue?: boolean
    currentValue?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GoalMilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }
  export type GoalMilestoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }

  export type $GoalMilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GoalMilestone"
    objects: {
      goal: Prisma.$GoalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      goalId: string
      title: string
      description: string | null
      targetDate: Date | null
      completedAt: Date | null
      targetValue: number | null
      currentValue: number
      status: $Enums.MilestoneStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["goalMilestone"]>
    composites: {}
  }

  type GoalMilestoneGetPayload<S extends boolean | null | undefined | GoalMilestoneDefaultArgs> = $Result.GetResult<Prisma.$GoalMilestonePayload, S>

  type GoalMilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GoalMilestoneFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GoalMilestoneCountAggregateInputType | true
    }

  export interface GoalMilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GoalMilestone'], meta: { name: 'GoalMilestone' } }
    /**
     * Find zero or one GoalMilestone that matches the filter.
     * @param {GoalMilestoneFindUniqueArgs} args - Arguments to find a GoalMilestone
     * @example
     * // Get one GoalMilestone
     * const goalMilestone = await prisma.goalMilestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoalMilestoneFindUniqueArgs>(args: SelectSubset<T, GoalMilestoneFindUniqueArgs<ExtArgs>>): Prisma__GoalMilestoneClient<$Result.GetResult<Prisma.$GoalMilestonePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GoalMilestone that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GoalMilestoneFindUniqueOrThrowArgs} args - Arguments to find a GoalMilestone
     * @example
     * // Get one GoalMilestone
     * const goalMilestone = await prisma.goalMilestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoalMilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, GoalMilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoalMilestoneClient<$Result.GetResult<Prisma.$GoalMilestonePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GoalMilestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalMilestoneFindFirstArgs} args - Arguments to find a GoalMilestone
     * @example
     * // Get one GoalMilestone
     * const goalMilestone = await prisma.goalMilestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoalMilestoneFindFirstArgs>(args?: SelectSubset<T, GoalMilestoneFindFirstArgs<ExtArgs>>): Prisma__GoalMilestoneClient<$Result.GetResult<Prisma.$GoalMilestonePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GoalMilestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalMilestoneFindFirstOrThrowArgs} args - Arguments to find a GoalMilestone
     * @example
     * // Get one GoalMilestone
     * const goalMilestone = await prisma.goalMilestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoalMilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, GoalMilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoalMilestoneClient<$Result.GetResult<Prisma.$GoalMilestonePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GoalMilestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalMilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GoalMilestones
     * const goalMilestones = await prisma.goalMilestone.findMany()
     * 
     * // Get first 10 GoalMilestones
     * const goalMilestones = await prisma.goalMilestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goalMilestoneWithIdOnly = await prisma.goalMilestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoalMilestoneFindManyArgs>(args?: SelectSubset<T, GoalMilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalMilestonePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GoalMilestone.
     * @param {GoalMilestoneCreateArgs} args - Arguments to create a GoalMilestone.
     * @example
     * // Create one GoalMilestone
     * const GoalMilestone = await prisma.goalMilestone.create({
     *   data: {
     *     // ... data to create a GoalMilestone
     *   }
     * })
     * 
     */
    create<T extends GoalMilestoneCreateArgs>(args: SelectSubset<T, GoalMilestoneCreateArgs<ExtArgs>>): Prisma__GoalMilestoneClient<$Result.GetResult<Prisma.$GoalMilestonePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GoalMilestones.
     * @param {GoalMilestoneCreateManyArgs} args - Arguments to create many GoalMilestones.
     * @example
     * // Create many GoalMilestones
     * const goalMilestone = await prisma.goalMilestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoalMilestoneCreateManyArgs>(args?: SelectSubset<T, GoalMilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GoalMilestones and returns the data saved in the database.
     * @param {GoalMilestoneCreateManyAndReturnArgs} args - Arguments to create many GoalMilestones.
     * @example
     * // Create many GoalMilestones
     * const goalMilestone = await prisma.goalMilestone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GoalMilestones and only return the `id`
     * const goalMilestoneWithIdOnly = await prisma.goalMilestone.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoalMilestoneCreateManyAndReturnArgs>(args?: SelectSubset<T, GoalMilestoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalMilestonePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GoalMilestone.
     * @param {GoalMilestoneDeleteArgs} args - Arguments to delete one GoalMilestone.
     * @example
     * // Delete one GoalMilestone
     * const GoalMilestone = await prisma.goalMilestone.delete({
     *   where: {
     *     // ... filter to delete one GoalMilestone
     *   }
     * })
     * 
     */
    delete<T extends GoalMilestoneDeleteArgs>(args: SelectSubset<T, GoalMilestoneDeleteArgs<ExtArgs>>): Prisma__GoalMilestoneClient<$Result.GetResult<Prisma.$GoalMilestonePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GoalMilestone.
     * @param {GoalMilestoneUpdateArgs} args - Arguments to update one GoalMilestone.
     * @example
     * // Update one GoalMilestone
     * const goalMilestone = await prisma.goalMilestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoalMilestoneUpdateArgs>(args: SelectSubset<T, GoalMilestoneUpdateArgs<ExtArgs>>): Prisma__GoalMilestoneClient<$Result.GetResult<Prisma.$GoalMilestonePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GoalMilestones.
     * @param {GoalMilestoneDeleteManyArgs} args - Arguments to filter GoalMilestones to delete.
     * @example
     * // Delete a few GoalMilestones
     * const { count } = await prisma.goalMilestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoalMilestoneDeleteManyArgs>(args?: SelectSubset<T, GoalMilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoalMilestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalMilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GoalMilestones
     * const goalMilestone = await prisma.goalMilestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoalMilestoneUpdateManyArgs>(args: SelectSubset<T, GoalMilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GoalMilestone.
     * @param {GoalMilestoneUpsertArgs} args - Arguments to update or create a GoalMilestone.
     * @example
     * // Update or create a GoalMilestone
     * const goalMilestone = await prisma.goalMilestone.upsert({
     *   create: {
     *     // ... data to create a GoalMilestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GoalMilestone we want to update
     *   }
     * })
     */
    upsert<T extends GoalMilestoneUpsertArgs>(args: SelectSubset<T, GoalMilestoneUpsertArgs<ExtArgs>>): Prisma__GoalMilestoneClient<$Result.GetResult<Prisma.$GoalMilestonePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GoalMilestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalMilestoneCountArgs} args - Arguments to filter GoalMilestones to count.
     * @example
     * // Count the number of GoalMilestones
     * const count = await prisma.goalMilestone.count({
     *   where: {
     *     // ... the filter for the GoalMilestones we want to count
     *   }
     * })
    **/
    count<T extends GoalMilestoneCountArgs>(
      args?: Subset<T, GoalMilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoalMilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GoalMilestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalMilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoalMilestoneAggregateArgs>(args: Subset<T, GoalMilestoneAggregateArgs>): Prisma.PrismaPromise<GetGoalMilestoneAggregateType<T>>

    /**
     * Group by GoalMilestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalMilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoalMilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoalMilestoneGroupByArgs['orderBy'] }
        : { orderBy?: GoalMilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoalMilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoalMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GoalMilestone model
   */
  readonly fields: GoalMilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GoalMilestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoalMilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goal<T extends GoalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoalDefaultArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GoalMilestone model
   */ 
  interface GoalMilestoneFieldRefs {
    readonly id: FieldRef<"GoalMilestone", 'String'>
    readonly goalId: FieldRef<"GoalMilestone", 'String'>
    readonly title: FieldRef<"GoalMilestone", 'String'>
    readonly description: FieldRef<"GoalMilestone", 'String'>
    readonly targetDate: FieldRef<"GoalMilestone", 'DateTime'>
    readonly completedAt: FieldRef<"GoalMilestone", 'DateTime'>
    readonly targetValue: FieldRef<"GoalMilestone", 'Float'>
    readonly currentValue: FieldRef<"GoalMilestone", 'Float'>
    readonly status: FieldRef<"GoalMilestone", 'MilestoneStatus'>
    readonly createdAt: FieldRef<"GoalMilestone", 'DateTime'>
    readonly updatedAt: FieldRef<"GoalMilestone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GoalMilestone findUnique
   */
  export type GoalMilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalMilestone
     */
    select?: GoalMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which GoalMilestone to fetch.
     */
    where: GoalMilestoneWhereUniqueInput
  }

  /**
   * GoalMilestone findUniqueOrThrow
   */
  export type GoalMilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalMilestone
     */
    select?: GoalMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which GoalMilestone to fetch.
     */
    where: GoalMilestoneWhereUniqueInput
  }

  /**
   * GoalMilestone findFirst
   */
  export type GoalMilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalMilestone
     */
    select?: GoalMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which GoalMilestone to fetch.
     */
    where?: GoalMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalMilestones to fetch.
     */
    orderBy?: GoalMilestoneOrderByWithRelationInput | GoalMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoalMilestones.
     */
    cursor?: GoalMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoalMilestones.
     */
    distinct?: GoalMilestoneScalarFieldEnum | GoalMilestoneScalarFieldEnum[]
  }

  /**
   * GoalMilestone findFirstOrThrow
   */
  export type GoalMilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalMilestone
     */
    select?: GoalMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which GoalMilestone to fetch.
     */
    where?: GoalMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalMilestones to fetch.
     */
    orderBy?: GoalMilestoneOrderByWithRelationInput | GoalMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoalMilestones.
     */
    cursor?: GoalMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoalMilestones.
     */
    distinct?: GoalMilestoneScalarFieldEnum | GoalMilestoneScalarFieldEnum[]
  }

  /**
   * GoalMilestone findMany
   */
  export type GoalMilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalMilestone
     */
    select?: GoalMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which GoalMilestones to fetch.
     */
    where?: GoalMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalMilestones to fetch.
     */
    orderBy?: GoalMilestoneOrderByWithRelationInput | GoalMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GoalMilestones.
     */
    cursor?: GoalMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalMilestones.
     */
    skip?: number
    distinct?: GoalMilestoneScalarFieldEnum | GoalMilestoneScalarFieldEnum[]
  }

  /**
   * GoalMilestone create
   */
  export type GoalMilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalMilestone
     */
    select?: GoalMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalMilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a GoalMilestone.
     */
    data: XOR<GoalMilestoneCreateInput, GoalMilestoneUncheckedCreateInput>
  }

  /**
   * GoalMilestone createMany
   */
  export type GoalMilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GoalMilestones.
     */
    data: GoalMilestoneCreateManyInput | GoalMilestoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GoalMilestone createManyAndReturn
   */
  export type GoalMilestoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalMilestone
     */
    select?: GoalMilestoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GoalMilestones.
     */
    data: GoalMilestoneCreateManyInput | GoalMilestoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalMilestoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GoalMilestone update
   */
  export type GoalMilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalMilestone
     */
    select?: GoalMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalMilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a GoalMilestone.
     */
    data: XOR<GoalMilestoneUpdateInput, GoalMilestoneUncheckedUpdateInput>
    /**
     * Choose, which GoalMilestone to update.
     */
    where: GoalMilestoneWhereUniqueInput
  }

  /**
   * GoalMilestone updateMany
   */
  export type GoalMilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GoalMilestones.
     */
    data: XOR<GoalMilestoneUpdateManyMutationInput, GoalMilestoneUncheckedUpdateManyInput>
    /**
     * Filter which GoalMilestones to update
     */
    where?: GoalMilestoneWhereInput
  }

  /**
   * GoalMilestone upsert
   */
  export type GoalMilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalMilestone
     */
    select?: GoalMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalMilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the GoalMilestone to update in case it exists.
     */
    where: GoalMilestoneWhereUniqueInput
    /**
     * In case the GoalMilestone found by the `where` argument doesn't exist, create a new GoalMilestone with this data.
     */
    create: XOR<GoalMilestoneCreateInput, GoalMilestoneUncheckedCreateInput>
    /**
     * In case the GoalMilestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoalMilestoneUpdateInput, GoalMilestoneUncheckedUpdateInput>
  }

  /**
   * GoalMilestone delete
   */
  export type GoalMilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalMilestone
     */
    select?: GoalMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalMilestoneInclude<ExtArgs> | null
    /**
     * Filter which GoalMilestone to delete.
     */
    where: GoalMilestoneWhereUniqueInput
  }

  /**
   * GoalMilestone deleteMany
   */
  export type GoalMilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoalMilestones to delete
     */
    where?: GoalMilestoneWhereInput
  }

  /**
   * GoalMilestone without action
   */
  export type GoalMilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalMilestone
     */
    select?: GoalMilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalMilestoneInclude<ExtArgs> | null
  }


  /**
   * Model GoalUpdate
   */

  export type AggregateGoalUpdate = {
    _count: GoalUpdateCountAggregateOutputType | null
    _avg: GoalUpdateAvgAggregateOutputType | null
    _sum: GoalUpdateSumAggregateOutputType | null
    _min: GoalUpdateMinAggregateOutputType | null
    _max: GoalUpdateMaxAggregateOutputType | null
  }

  export type GoalUpdateAvgAggregateOutputType = {
    value: number | null
  }

  export type GoalUpdateSumAggregateOutputType = {
    value: number | null
  }

  export type GoalUpdateMinAggregateOutputType = {
    id: string | null
    goalId: string | null
    content: string | null
    value: number | null
    createdAt: Date | null
  }

  export type GoalUpdateMaxAggregateOutputType = {
    id: string | null
    goalId: string | null
    content: string | null
    value: number | null
    createdAt: Date | null
  }

  export type GoalUpdateCountAggregateOutputType = {
    id: number
    goalId: number
    content: number
    value: number
    createdAt: number
    _all: number
  }


  export type GoalUpdateAvgAggregateInputType = {
    value?: true
  }

  export type GoalUpdateSumAggregateInputType = {
    value?: true
  }

  export type GoalUpdateMinAggregateInputType = {
    id?: true
    goalId?: true
    content?: true
    value?: true
    createdAt?: true
  }

  export type GoalUpdateMaxAggregateInputType = {
    id?: true
    goalId?: true
    content?: true
    value?: true
    createdAt?: true
  }

  export type GoalUpdateCountAggregateInputType = {
    id?: true
    goalId?: true
    content?: true
    value?: true
    createdAt?: true
    _all?: true
  }

  export type GoalUpdateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoalUpdate to aggregate.
     */
    where?: GoalUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalUpdates to fetch.
     */
    orderBy?: GoalUpdateOrderByWithRelationInput | GoalUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoalUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GoalUpdates
    **/
    _count?: true | GoalUpdateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoalUpdateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoalUpdateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoalUpdateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoalUpdateMaxAggregateInputType
  }

  export type GetGoalUpdateAggregateType<T extends GoalUpdateAggregateArgs> = {
        [P in keyof T & keyof AggregateGoalUpdate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoalUpdate[P]>
      : GetScalarType<T[P], AggregateGoalUpdate[P]>
  }




  export type GoalUpdateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalUpdateWhereInput
    orderBy?: GoalUpdateOrderByWithAggregationInput | GoalUpdateOrderByWithAggregationInput[]
    by: GoalUpdateScalarFieldEnum[] | GoalUpdateScalarFieldEnum
    having?: GoalUpdateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoalUpdateCountAggregateInputType | true
    _avg?: GoalUpdateAvgAggregateInputType
    _sum?: GoalUpdateSumAggregateInputType
    _min?: GoalUpdateMinAggregateInputType
    _max?: GoalUpdateMaxAggregateInputType
  }

  export type GoalUpdateGroupByOutputType = {
    id: string
    goalId: string
    content: string
    value: number | null
    createdAt: Date
    _count: GoalUpdateCountAggregateOutputType | null
    _avg: GoalUpdateAvgAggregateOutputType | null
    _sum: GoalUpdateSumAggregateOutputType | null
    _min: GoalUpdateMinAggregateOutputType | null
    _max: GoalUpdateMaxAggregateOutputType | null
  }

  type GetGoalUpdateGroupByPayload<T extends GoalUpdateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoalUpdateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoalUpdateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoalUpdateGroupByOutputType[P]>
            : GetScalarType<T[P], GoalUpdateGroupByOutputType[P]>
        }
      >
    >


  export type GoalUpdateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    content?: boolean
    value?: boolean
    createdAt?: boolean
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goalUpdate"]>

  export type GoalUpdateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goalId?: boolean
    content?: boolean
    value?: boolean
    createdAt?: boolean
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goalUpdate"]>

  export type GoalUpdateSelectScalar = {
    id?: boolean
    goalId?: boolean
    content?: boolean
    value?: boolean
    createdAt?: boolean
  }

  export type GoalUpdateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }
  export type GoalUpdateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goal?: boolean | GoalDefaultArgs<ExtArgs>
  }

  export type $GoalUpdatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GoalUpdate"
    objects: {
      goal: Prisma.$GoalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      goalId: string
      content: string
      value: number | null
      createdAt: Date
    }, ExtArgs["result"]["goalUpdate"]>
    composites: {}
  }

  type GoalUpdateGetPayload<S extends boolean | null | undefined | GoalUpdateDefaultArgs> = $Result.GetResult<Prisma.$GoalUpdatePayload, S>

  type GoalUpdateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GoalUpdateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GoalUpdateCountAggregateInputType | true
    }

  export interface GoalUpdateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GoalUpdate'], meta: { name: 'GoalUpdate' } }
    /**
     * Find zero or one GoalUpdate that matches the filter.
     * @param {GoalUpdateFindUniqueArgs} args - Arguments to find a GoalUpdate
     * @example
     * // Get one GoalUpdate
     * const goalUpdate = await prisma.goalUpdate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoalUpdateFindUniqueArgs>(args: SelectSubset<T, GoalUpdateFindUniqueArgs<ExtArgs>>): Prisma__GoalUpdateClient<$Result.GetResult<Prisma.$GoalUpdatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GoalUpdate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GoalUpdateFindUniqueOrThrowArgs} args - Arguments to find a GoalUpdate
     * @example
     * // Get one GoalUpdate
     * const goalUpdate = await prisma.goalUpdate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoalUpdateFindUniqueOrThrowArgs>(args: SelectSubset<T, GoalUpdateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoalUpdateClient<$Result.GetResult<Prisma.$GoalUpdatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GoalUpdate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalUpdateFindFirstArgs} args - Arguments to find a GoalUpdate
     * @example
     * // Get one GoalUpdate
     * const goalUpdate = await prisma.goalUpdate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoalUpdateFindFirstArgs>(args?: SelectSubset<T, GoalUpdateFindFirstArgs<ExtArgs>>): Prisma__GoalUpdateClient<$Result.GetResult<Prisma.$GoalUpdatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GoalUpdate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalUpdateFindFirstOrThrowArgs} args - Arguments to find a GoalUpdate
     * @example
     * // Get one GoalUpdate
     * const goalUpdate = await prisma.goalUpdate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoalUpdateFindFirstOrThrowArgs>(args?: SelectSubset<T, GoalUpdateFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoalUpdateClient<$Result.GetResult<Prisma.$GoalUpdatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GoalUpdates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalUpdateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GoalUpdates
     * const goalUpdates = await prisma.goalUpdate.findMany()
     * 
     * // Get first 10 GoalUpdates
     * const goalUpdates = await prisma.goalUpdate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goalUpdateWithIdOnly = await prisma.goalUpdate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoalUpdateFindManyArgs>(args?: SelectSubset<T, GoalUpdateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalUpdatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GoalUpdate.
     * @param {GoalUpdateCreateArgs} args - Arguments to create a GoalUpdate.
     * @example
     * // Create one GoalUpdate
     * const GoalUpdate = await prisma.goalUpdate.create({
     *   data: {
     *     // ... data to create a GoalUpdate
     *   }
     * })
     * 
     */
    create<T extends GoalUpdateCreateArgs>(args: SelectSubset<T, GoalUpdateCreateArgs<ExtArgs>>): Prisma__GoalUpdateClient<$Result.GetResult<Prisma.$GoalUpdatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GoalUpdates.
     * @param {GoalUpdateCreateManyArgs} args - Arguments to create many GoalUpdates.
     * @example
     * // Create many GoalUpdates
     * const goalUpdate = await prisma.goalUpdate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoalUpdateCreateManyArgs>(args?: SelectSubset<T, GoalUpdateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GoalUpdates and returns the data saved in the database.
     * @param {GoalUpdateCreateManyAndReturnArgs} args - Arguments to create many GoalUpdates.
     * @example
     * // Create many GoalUpdates
     * const goalUpdate = await prisma.goalUpdate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GoalUpdates and only return the `id`
     * const goalUpdateWithIdOnly = await prisma.goalUpdate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoalUpdateCreateManyAndReturnArgs>(args?: SelectSubset<T, GoalUpdateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalUpdatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GoalUpdate.
     * @param {GoalUpdateDeleteArgs} args - Arguments to delete one GoalUpdate.
     * @example
     * // Delete one GoalUpdate
     * const GoalUpdate = await prisma.goalUpdate.delete({
     *   where: {
     *     // ... filter to delete one GoalUpdate
     *   }
     * })
     * 
     */
    delete<T extends GoalUpdateDeleteArgs>(args: SelectSubset<T, GoalUpdateDeleteArgs<ExtArgs>>): Prisma__GoalUpdateClient<$Result.GetResult<Prisma.$GoalUpdatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GoalUpdate.
     * @param {GoalUpdateUpdateArgs} args - Arguments to update one GoalUpdate.
     * @example
     * // Update one GoalUpdate
     * const goalUpdate = await prisma.goalUpdate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoalUpdateUpdateArgs>(args: SelectSubset<T, GoalUpdateUpdateArgs<ExtArgs>>): Prisma__GoalUpdateClient<$Result.GetResult<Prisma.$GoalUpdatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GoalUpdates.
     * @param {GoalUpdateDeleteManyArgs} args - Arguments to filter GoalUpdates to delete.
     * @example
     * // Delete a few GoalUpdates
     * const { count } = await prisma.goalUpdate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoalUpdateDeleteManyArgs>(args?: SelectSubset<T, GoalUpdateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoalUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalUpdateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GoalUpdates
     * const goalUpdate = await prisma.goalUpdate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoalUpdateUpdateManyArgs>(args: SelectSubset<T, GoalUpdateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GoalUpdate.
     * @param {GoalUpdateUpsertArgs} args - Arguments to update or create a GoalUpdate.
     * @example
     * // Update or create a GoalUpdate
     * const goalUpdate = await prisma.goalUpdate.upsert({
     *   create: {
     *     // ... data to create a GoalUpdate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GoalUpdate we want to update
     *   }
     * })
     */
    upsert<T extends GoalUpdateUpsertArgs>(args: SelectSubset<T, GoalUpdateUpsertArgs<ExtArgs>>): Prisma__GoalUpdateClient<$Result.GetResult<Prisma.$GoalUpdatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GoalUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalUpdateCountArgs} args - Arguments to filter GoalUpdates to count.
     * @example
     * // Count the number of GoalUpdates
     * const count = await prisma.goalUpdate.count({
     *   where: {
     *     // ... the filter for the GoalUpdates we want to count
     *   }
     * })
    **/
    count<T extends GoalUpdateCountArgs>(
      args?: Subset<T, GoalUpdateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoalUpdateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GoalUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalUpdateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoalUpdateAggregateArgs>(args: Subset<T, GoalUpdateAggregateArgs>): Prisma.PrismaPromise<GetGoalUpdateAggregateType<T>>

    /**
     * Group by GoalUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalUpdateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoalUpdateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoalUpdateGroupByArgs['orderBy'] }
        : { orderBy?: GoalUpdateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoalUpdateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoalUpdateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GoalUpdate model
   */
  readonly fields: GoalUpdateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GoalUpdate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoalUpdateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goal<T extends GoalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoalDefaultArgs<ExtArgs>>): Prisma__GoalClient<$Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GoalUpdate model
   */ 
  interface GoalUpdateFieldRefs {
    readonly id: FieldRef<"GoalUpdate", 'String'>
    readonly goalId: FieldRef<"GoalUpdate", 'String'>
    readonly content: FieldRef<"GoalUpdate", 'String'>
    readonly value: FieldRef<"GoalUpdate", 'Float'>
    readonly createdAt: FieldRef<"GoalUpdate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GoalUpdate findUnique
   */
  export type GoalUpdateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalUpdate
     */
    select?: GoalUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalUpdateInclude<ExtArgs> | null
    /**
     * Filter, which GoalUpdate to fetch.
     */
    where: GoalUpdateWhereUniqueInput
  }

  /**
   * GoalUpdate findUniqueOrThrow
   */
  export type GoalUpdateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalUpdate
     */
    select?: GoalUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalUpdateInclude<ExtArgs> | null
    /**
     * Filter, which GoalUpdate to fetch.
     */
    where: GoalUpdateWhereUniqueInput
  }

  /**
   * GoalUpdate findFirst
   */
  export type GoalUpdateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalUpdate
     */
    select?: GoalUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalUpdateInclude<ExtArgs> | null
    /**
     * Filter, which GoalUpdate to fetch.
     */
    where?: GoalUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalUpdates to fetch.
     */
    orderBy?: GoalUpdateOrderByWithRelationInput | GoalUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoalUpdates.
     */
    cursor?: GoalUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoalUpdates.
     */
    distinct?: GoalUpdateScalarFieldEnum | GoalUpdateScalarFieldEnum[]
  }

  /**
   * GoalUpdate findFirstOrThrow
   */
  export type GoalUpdateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalUpdate
     */
    select?: GoalUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalUpdateInclude<ExtArgs> | null
    /**
     * Filter, which GoalUpdate to fetch.
     */
    where?: GoalUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalUpdates to fetch.
     */
    orderBy?: GoalUpdateOrderByWithRelationInput | GoalUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoalUpdates.
     */
    cursor?: GoalUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoalUpdates.
     */
    distinct?: GoalUpdateScalarFieldEnum | GoalUpdateScalarFieldEnum[]
  }

  /**
   * GoalUpdate findMany
   */
  export type GoalUpdateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalUpdate
     */
    select?: GoalUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalUpdateInclude<ExtArgs> | null
    /**
     * Filter, which GoalUpdates to fetch.
     */
    where?: GoalUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalUpdates to fetch.
     */
    orderBy?: GoalUpdateOrderByWithRelationInput | GoalUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GoalUpdates.
     */
    cursor?: GoalUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalUpdates.
     */
    skip?: number
    distinct?: GoalUpdateScalarFieldEnum | GoalUpdateScalarFieldEnum[]
  }

  /**
   * GoalUpdate create
   */
  export type GoalUpdateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalUpdate
     */
    select?: GoalUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalUpdateInclude<ExtArgs> | null
    /**
     * The data needed to create a GoalUpdate.
     */
    data: XOR<GoalUpdateCreateInput, GoalUpdateUncheckedCreateInput>
  }

  /**
   * GoalUpdate createMany
   */
  export type GoalUpdateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GoalUpdates.
     */
    data: GoalUpdateCreateManyInput | GoalUpdateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GoalUpdate createManyAndReturn
   */
  export type GoalUpdateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalUpdate
     */
    select?: GoalUpdateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GoalUpdates.
     */
    data: GoalUpdateCreateManyInput | GoalUpdateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalUpdateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GoalUpdate update
   */
  export type GoalUpdateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalUpdate
     */
    select?: GoalUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalUpdateInclude<ExtArgs> | null
    /**
     * The data needed to update a GoalUpdate.
     */
    data: XOR<GoalUpdateUpdateInput, GoalUpdateUncheckedUpdateInput>
    /**
     * Choose, which GoalUpdate to update.
     */
    where: GoalUpdateWhereUniqueInput
  }

  /**
   * GoalUpdate updateMany
   */
  export type GoalUpdateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GoalUpdates.
     */
    data: XOR<GoalUpdateUpdateManyMutationInput, GoalUpdateUncheckedUpdateManyInput>
    /**
     * Filter which GoalUpdates to update
     */
    where?: GoalUpdateWhereInput
  }

  /**
   * GoalUpdate upsert
   */
  export type GoalUpdateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalUpdate
     */
    select?: GoalUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalUpdateInclude<ExtArgs> | null
    /**
     * The filter to search for the GoalUpdate to update in case it exists.
     */
    where: GoalUpdateWhereUniqueInput
    /**
     * In case the GoalUpdate found by the `where` argument doesn't exist, create a new GoalUpdate with this data.
     */
    create: XOR<GoalUpdateCreateInput, GoalUpdateUncheckedCreateInput>
    /**
     * In case the GoalUpdate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoalUpdateUpdateInput, GoalUpdateUncheckedUpdateInput>
  }

  /**
   * GoalUpdate delete
   */
  export type GoalUpdateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalUpdate
     */
    select?: GoalUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalUpdateInclude<ExtArgs> | null
    /**
     * Filter which GoalUpdate to delete.
     */
    where: GoalUpdateWhereUniqueInput
  }

  /**
   * GoalUpdate deleteMany
   */
  export type GoalUpdateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoalUpdates to delete
     */
    where?: GoalUpdateWhereInput
  }

  /**
   * GoalUpdate without action
   */
  export type GoalUpdateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalUpdate
     */
    select?: GoalUpdateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalUpdateInclude<ExtArgs> | null
  }


  /**
   * Model MeditationSession
   */

  export type AggregateMeditationSession = {
    _count: MeditationSessionCountAggregateOutputType | null
    _avg: MeditationSessionAvgAggregateOutputType | null
    _sum: MeditationSessionSumAggregateOutputType | null
    _min: MeditationSessionMinAggregateOutputType | null
    _max: MeditationSessionMaxAggregateOutputType | null
  }

  export type MeditationSessionAvgAggregateOutputType = {
    duration: number | null
    rating: number | null
  }

  export type MeditationSessionSumAggregateOutputType = {
    duration: number | null
    rating: number | null
  }

  export type MeditationSessionMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    duration: number | null
    technique: string | null
    guidedSession: boolean | null
    guideUrl: string | null
    rating: number | null
    notes: string | null
    mood: string | null
    location: string | null
    distractions: string | null
    createdAt: Date | null
  }

  export type MeditationSessionMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    duration: number | null
    technique: string | null
    guidedSession: boolean | null
    guideUrl: string | null
    rating: number | null
    notes: string | null
    mood: string | null
    location: string | null
    distractions: string | null
    createdAt: Date | null
  }

  export type MeditationSessionCountAggregateOutputType = {
    id: number
    profileId: number
    duration: number
    technique: number
    guidedSession: number
    guideUrl: number
    rating: number
    notes: number
    mood: number
    location: number
    distractions: number
    createdAt: number
    _all: number
  }


  export type MeditationSessionAvgAggregateInputType = {
    duration?: true
    rating?: true
  }

  export type MeditationSessionSumAggregateInputType = {
    duration?: true
    rating?: true
  }

  export type MeditationSessionMinAggregateInputType = {
    id?: true
    profileId?: true
    duration?: true
    technique?: true
    guidedSession?: true
    guideUrl?: true
    rating?: true
    notes?: true
    mood?: true
    location?: true
    distractions?: true
    createdAt?: true
  }

  export type MeditationSessionMaxAggregateInputType = {
    id?: true
    profileId?: true
    duration?: true
    technique?: true
    guidedSession?: true
    guideUrl?: true
    rating?: true
    notes?: true
    mood?: true
    location?: true
    distractions?: true
    createdAt?: true
  }

  export type MeditationSessionCountAggregateInputType = {
    id?: true
    profileId?: true
    duration?: true
    technique?: true
    guidedSession?: true
    guideUrl?: true
    rating?: true
    notes?: true
    mood?: true
    location?: true
    distractions?: true
    createdAt?: true
    _all?: true
  }

  export type MeditationSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeditationSession to aggregate.
     */
    where?: MeditationSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeditationSessions to fetch.
     */
    orderBy?: MeditationSessionOrderByWithRelationInput | MeditationSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeditationSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeditationSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeditationSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MeditationSessions
    **/
    _count?: true | MeditationSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeditationSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeditationSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeditationSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeditationSessionMaxAggregateInputType
  }

  export type GetMeditationSessionAggregateType<T extends MeditationSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateMeditationSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeditationSession[P]>
      : GetScalarType<T[P], AggregateMeditationSession[P]>
  }




  export type MeditationSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeditationSessionWhereInput
    orderBy?: MeditationSessionOrderByWithAggregationInput | MeditationSessionOrderByWithAggregationInput[]
    by: MeditationSessionScalarFieldEnum[] | MeditationSessionScalarFieldEnum
    having?: MeditationSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeditationSessionCountAggregateInputType | true
    _avg?: MeditationSessionAvgAggregateInputType
    _sum?: MeditationSessionSumAggregateInputType
    _min?: MeditationSessionMinAggregateInputType
    _max?: MeditationSessionMaxAggregateInputType
  }

  export type MeditationSessionGroupByOutputType = {
    id: string
    profileId: string
    duration: number
    technique: string | null
    guidedSession: boolean
    guideUrl: string | null
    rating: number | null
    notes: string | null
    mood: string | null
    location: string | null
    distractions: string | null
    createdAt: Date
    _count: MeditationSessionCountAggregateOutputType | null
    _avg: MeditationSessionAvgAggregateOutputType | null
    _sum: MeditationSessionSumAggregateOutputType | null
    _min: MeditationSessionMinAggregateOutputType | null
    _max: MeditationSessionMaxAggregateOutputType | null
  }

  type GetMeditationSessionGroupByPayload<T extends MeditationSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeditationSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeditationSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeditationSessionGroupByOutputType[P]>
            : GetScalarType<T[P], MeditationSessionGroupByOutputType[P]>
        }
      >
    >


  export type MeditationSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    duration?: boolean
    technique?: boolean
    guidedSession?: boolean
    guideUrl?: boolean
    rating?: boolean
    notes?: boolean
    mood?: boolean
    location?: boolean
    distractions?: boolean
    createdAt?: boolean
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meditationSession"]>

  export type MeditationSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    duration?: boolean
    technique?: boolean
    guidedSession?: boolean
    guideUrl?: boolean
    rating?: boolean
    notes?: boolean
    mood?: boolean
    location?: boolean
    distractions?: boolean
    createdAt?: boolean
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meditationSession"]>

  export type MeditationSessionSelectScalar = {
    id?: boolean
    profileId?: boolean
    duration?: boolean
    technique?: boolean
    guidedSession?: boolean
    guideUrl?: boolean
    rating?: boolean
    notes?: boolean
    mood?: boolean
    location?: boolean
    distractions?: boolean
    createdAt?: boolean
  }

  export type MeditationSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
  }
  export type MeditationSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
  }

  export type $MeditationSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MeditationSession"
    objects: {
      profile: Prisma.$LifeOSProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      duration: number
      technique: string | null
      guidedSession: boolean
      guideUrl: string | null
      rating: number | null
      notes: string | null
      mood: string | null
      location: string | null
      distractions: string | null
      createdAt: Date
    }, ExtArgs["result"]["meditationSession"]>
    composites: {}
  }

  type MeditationSessionGetPayload<S extends boolean | null | undefined | MeditationSessionDefaultArgs> = $Result.GetResult<Prisma.$MeditationSessionPayload, S>

  type MeditationSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MeditationSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MeditationSessionCountAggregateInputType | true
    }

  export interface MeditationSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MeditationSession'], meta: { name: 'MeditationSession' } }
    /**
     * Find zero or one MeditationSession that matches the filter.
     * @param {MeditationSessionFindUniqueArgs} args - Arguments to find a MeditationSession
     * @example
     * // Get one MeditationSession
     * const meditationSession = await prisma.meditationSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeditationSessionFindUniqueArgs>(args: SelectSubset<T, MeditationSessionFindUniqueArgs<ExtArgs>>): Prisma__MeditationSessionClient<$Result.GetResult<Prisma.$MeditationSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MeditationSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MeditationSessionFindUniqueOrThrowArgs} args - Arguments to find a MeditationSession
     * @example
     * // Get one MeditationSession
     * const meditationSession = await prisma.meditationSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeditationSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, MeditationSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeditationSessionClient<$Result.GetResult<Prisma.$MeditationSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MeditationSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationSessionFindFirstArgs} args - Arguments to find a MeditationSession
     * @example
     * // Get one MeditationSession
     * const meditationSession = await prisma.meditationSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeditationSessionFindFirstArgs>(args?: SelectSubset<T, MeditationSessionFindFirstArgs<ExtArgs>>): Prisma__MeditationSessionClient<$Result.GetResult<Prisma.$MeditationSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MeditationSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationSessionFindFirstOrThrowArgs} args - Arguments to find a MeditationSession
     * @example
     * // Get one MeditationSession
     * const meditationSession = await prisma.meditationSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeditationSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, MeditationSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeditationSessionClient<$Result.GetResult<Prisma.$MeditationSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MeditationSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MeditationSessions
     * const meditationSessions = await prisma.meditationSession.findMany()
     * 
     * // Get first 10 MeditationSessions
     * const meditationSessions = await prisma.meditationSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meditationSessionWithIdOnly = await prisma.meditationSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeditationSessionFindManyArgs>(args?: SelectSubset<T, MeditationSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeditationSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MeditationSession.
     * @param {MeditationSessionCreateArgs} args - Arguments to create a MeditationSession.
     * @example
     * // Create one MeditationSession
     * const MeditationSession = await prisma.meditationSession.create({
     *   data: {
     *     // ... data to create a MeditationSession
     *   }
     * })
     * 
     */
    create<T extends MeditationSessionCreateArgs>(args: SelectSubset<T, MeditationSessionCreateArgs<ExtArgs>>): Prisma__MeditationSessionClient<$Result.GetResult<Prisma.$MeditationSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MeditationSessions.
     * @param {MeditationSessionCreateManyArgs} args - Arguments to create many MeditationSessions.
     * @example
     * // Create many MeditationSessions
     * const meditationSession = await prisma.meditationSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeditationSessionCreateManyArgs>(args?: SelectSubset<T, MeditationSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MeditationSessions and returns the data saved in the database.
     * @param {MeditationSessionCreateManyAndReturnArgs} args - Arguments to create many MeditationSessions.
     * @example
     * // Create many MeditationSessions
     * const meditationSession = await prisma.meditationSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MeditationSessions and only return the `id`
     * const meditationSessionWithIdOnly = await prisma.meditationSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeditationSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, MeditationSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeditationSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MeditationSession.
     * @param {MeditationSessionDeleteArgs} args - Arguments to delete one MeditationSession.
     * @example
     * // Delete one MeditationSession
     * const MeditationSession = await prisma.meditationSession.delete({
     *   where: {
     *     // ... filter to delete one MeditationSession
     *   }
     * })
     * 
     */
    delete<T extends MeditationSessionDeleteArgs>(args: SelectSubset<T, MeditationSessionDeleteArgs<ExtArgs>>): Prisma__MeditationSessionClient<$Result.GetResult<Prisma.$MeditationSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MeditationSession.
     * @param {MeditationSessionUpdateArgs} args - Arguments to update one MeditationSession.
     * @example
     * // Update one MeditationSession
     * const meditationSession = await prisma.meditationSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeditationSessionUpdateArgs>(args: SelectSubset<T, MeditationSessionUpdateArgs<ExtArgs>>): Prisma__MeditationSessionClient<$Result.GetResult<Prisma.$MeditationSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MeditationSessions.
     * @param {MeditationSessionDeleteManyArgs} args - Arguments to filter MeditationSessions to delete.
     * @example
     * // Delete a few MeditationSessions
     * const { count } = await prisma.meditationSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeditationSessionDeleteManyArgs>(args?: SelectSubset<T, MeditationSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeditationSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MeditationSessions
     * const meditationSession = await prisma.meditationSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeditationSessionUpdateManyArgs>(args: SelectSubset<T, MeditationSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MeditationSession.
     * @param {MeditationSessionUpsertArgs} args - Arguments to update or create a MeditationSession.
     * @example
     * // Update or create a MeditationSession
     * const meditationSession = await prisma.meditationSession.upsert({
     *   create: {
     *     // ... data to create a MeditationSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MeditationSession we want to update
     *   }
     * })
     */
    upsert<T extends MeditationSessionUpsertArgs>(args: SelectSubset<T, MeditationSessionUpsertArgs<ExtArgs>>): Prisma__MeditationSessionClient<$Result.GetResult<Prisma.$MeditationSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MeditationSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationSessionCountArgs} args - Arguments to filter MeditationSessions to count.
     * @example
     * // Count the number of MeditationSessions
     * const count = await prisma.meditationSession.count({
     *   where: {
     *     // ... the filter for the MeditationSessions we want to count
     *   }
     * })
    **/
    count<T extends MeditationSessionCountArgs>(
      args?: Subset<T, MeditationSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeditationSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MeditationSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeditationSessionAggregateArgs>(args: Subset<T, MeditationSessionAggregateArgs>): Prisma.PrismaPromise<GetMeditationSessionAggregateType<T>>

    /**
     * Group by MeditationSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeditationSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeditationSessionGroupByArgs['orderBy'] }
        : { orderBy?: MeditationSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeditationSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeditationSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MeditationSession model
   */
  readonly fields: MeditationSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MeditationSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeditationSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends LifeOSProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LifeOSProfileDefaultArgs<ExtArgs>>): Prisma__LifeOSProfileClient<$Result.GetResult<Prisma.$LifeOSProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MeditationSession model
   */ 
  interface MeditationSessionFieldRefs {
    readonly id: FieldRef<"MeditationSession", 'String'>
    readonly profileId: FieldRef<"MeditationSession", 'String'>
    readonly duration: FieldRef<"MeditationSession", 'Int'>
    readonly technique: FieldRef<"MeditationSession", 'String'>
    readonly guidedSession: FieldRef<"MeditationSession", 'Boolean'>
    readonly guideUrl: FieldRef<"MeditationSession", 'String'>
    readonly rating: FieldRef<"MeditationSession", 'Int'>
    readonly notes: FieldRef<"MeditationSession", 'String'>
    readonly mood: FieldRef<"MeditationSession", 'String'>
    readonly location: FieldRef<"MeditationSession", 'String'>
    readonly distractions: FieldRef<"MeditationSession", 'String'>
    readonly createdAt: FieldRef<"MeditationSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MeditationSession findUnique
   */
  export type MeditationSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationSession
     */
    select?: MeditationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationSessionInclude<ExtArgs> | null
    /**
     * Filter, which MeditationSession to fetch.
     */
    where: MeditationSessionWhereUniqueInput
  }

  /**
   * MeditationSession findUniqueOrThrow
   */
  export type MeditationSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationSession
     */
    select?: MeditationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationSessionInclude<ExtArgs> | null
    /**
     * Filter, which MeditationSession to fetch.
     */
    where: MeditationSessionWhereUniqueInput
  }

  /**
   * MeditationSession findFirst
   */
  export type MeditationSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationSession
     */
    select?: MeditationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationSessionInclude<ExtArgs> | null
    /**
     * Filter, which MeditationSession to fetch.
     */
    where?: MeditationSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeditationSessions to fetch.
     */
    orderBy?: MeditationSessionOrderByWithRelationInput | MeditationSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeditationSessions.
     */
    cursor?: MeditationSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeditationSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeditationSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeditationSessions.
     */
    distinct?: MeditationSessionScalarFieldEnum | MeditationSessionScalarFieldEnum[]
  }

  /**
   * MeditationSession findFirstOrThrow
   */
  export type MeditationSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationSession
     */
    select?: MeditationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationSessionInclude<ExtArgs> | null
    /**
     * Filter, which MeditationSession to fetch.
     */
    where?: MeditationSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeditationSessions to fetch.
     */
    orderBy?: MeditationSessionOrderByWithRelationInput | MeditationSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeditationSessions.
     */
    cursor?: MeditationSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeditationSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeditationSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeditationSessions.
     */
    distinct?: MeditationSessionScalarFieldEnum | MeditationSessionScalarFieldEnum[]
  }

  /**
   * MeditationSession findMany
   */
  export type MeditationSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationSession
     */
    select?: MeditationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationSessionInclude<ExtArgs> | null
    /**
     * Filter, which MeditationSessions to fetch.
     */
    where?: MeditationSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeditationSessions to fetch.
     */
    orderBy?: MeditationSessionOrderByWithRelationInput | MeditationSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MeditationSessions.
     */
    cursor?: MeditationSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeditationSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeditationSessions.
     */
    skip?: number
    distinct?: MeditationSessionScalarFieldEnum | MeditationSessionScalarFieldEnum[]
  }

  /**
   * MeditationSession create
   */
  export type MeditationSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationSession
     */
    select?: MeditationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a MeditationSession.
     */
    data: XOR<MeditationSessionCreateInput, MeditationSessionUncheckedCreateInput>
  }

  /**
   * MeditationSession createMany
   */
  export type MeditationSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MeditationSessions.
     */
    data: MeditationSessionCreateManyInput | MeditationSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MeditationSession createManyAndReturn
   */
  export type MeditationSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationSession
     */
    select?: MeditationSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MeditationSessions.
     */
    data: MeditationSessionCreateManyInput | MeditationSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MeditationSession update
   */
  export type MeditationSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationSession
     */
    select?: MeditationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a MeditationSession.
     */
    data: XOR<MeditationSessionUpdateInput, MeditationSessionUncheckedUpdateInput>
    /**
     * Choose, which MeditationSession to update.
     */
    where: MeditationSessionWhereUniqueInput
  }

  /**
   * MeditationSession updateMany
   */
  export type MeditationSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MeditationSessions.
     */
    data: XOR<MeditationSessionUpdateManyMutationInput, MeditationSessionUncheckedUpdateManyInput>
    /**
     * Filter which MeditationSessions to update
     */
    where?: MeditationSessionWhereInput
  }

  /**
   * MeditationSession upsert
   */
  export type MeditationSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationSession
     */
    select?: MeditationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the MeditationSession to update in case it exists.
     */
    where: MeditationSessionWhereUniqueInput
    /**
     * In case the MeditationSession found by the `where` argument doesn't exist, create a new MeditationSession with this data.
     */
    create: XOR<MeditationSessionCreateInput, MeditationSessionUncheckedCreateInput>
    /**
     * In case the MeditationSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeditationSessionUpdateInput, MeditationSessionUncheckedUpdateInput>
  }

  /**
   * MeditationSession delete
   */
  export type MeditationSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationSession
     */
    select?: MeditationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationSessionInclude<ExtArgs> | null
    /**
     * Filter which MeditationSession to delete.
     */
    where: MeditationSessionWhereUniqueInput
  }

  /**
   * MeditationSession deleteMany
   */
  export type MeditationSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeditationSessions to delete
     */
    where?: MeditationSessionWhereInput
  }

  /**
   * MeditationSession without action
   */
  export type MeditationSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationSession
     */
    select?: MeditationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationSessionInclude<ExtArgs> | null
  }


  /**
   * Model MoodEntry
   */

  export type AggregateMoodEntry = {
    _count: MoodEntryCountAggregateOutputType | null
    _avg: MoodEntryAvgAggregateOutputType | null
    _sum: MoodEntrySumAggregateOutputType | null
    _min: MoodEntryMinAggregateOutputType | null
    _max: MoodEntryMaxAggregateOutputType | null
  }

  export type MoodEntryAvgAggregateOutputType = {
    intensity: number | null
  }

  export type MoodEntrySumAggregateOutputType = {
    intensity: number | null
  }

  export type MoodEntryMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    mood: string | null
    intensity: number | null
    location: string | null
    weather: string | null
    notes: string | null
    triggers: string | null
    gratitude: string | null
    recordedAt: Date | null
    createdAt: Date | null
  }

  export type MoodEntryMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    mood: string | null
    intensity: number | null
    location: string | null
    weather: string | null
    notes: string | null
    triggers: string | null
    gratitude: string | null
    recordedAt: Date | null
    createdAt: Date | null
  }

  export type MoodEntryCountAggregateOutputType = {
    id: number
    profileId: number
    mood: number
    intensity: number
    emotions: number
    activities: number
    location: number
    weather: number
    notes: number
    triggers: number
    gratitude: number
    recordedAt: number
    createdAt: number
    _all: number
  }


  export type MoodEntryAvgAggregateInputType = {
    intensity?: true
  }

  export type MoodEntrySumAggregateInputType = {
    intensity?: true
  }

  export type MoodEntryMinAggregateInputType = {
    id?: true
    profileId?: true
    mood?: true
    intensity?: true
    location?: true
    weather?: true
    notes?: true
    triggers?: true
    gratitude?: true
    recordedAt?: true
    createdAt?: true
  }

  export type MoodEntryMaxAggregateInputType = {
    id?: true
    profileId?: true
    mood?: true
    intensity?: true
    location?: true
    weather?: true
    notes?: true
    triggers?: true
    gratitude?: true
    recordedAt?: true
    createdAt?: true
  }

  export type MoodEntryCountAggregateInputType = {
    id?: true
    profileId?: true
    mood?: true
    intensity?: true
    emotions?: true
    activities?: true
    location?: true
    weather?: true
    notes?: true
    triggers?: true
    gratitude?: true
    recordedAt?: true
    createdAt?: true
    _all?: true
  }

  export type MoodEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MoodEntry to aggregate.
     */
    where?: MoodEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodEntries to fetch.
     */
    orderBy?: MoodEntryOrderByWithRelationInput | MoodEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MoodEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MoodEntries
    **/
    _count?: true | MoodEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MoodEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MoodEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MoodEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MoodEntryMaxAggregateInputType
  }

  export type GetMoodEntryAggregateType<T extends MoodEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateMoodEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMoodEntry[P]>
      : GetScalarType<T[P], AggregateMoodEntry[P]>
  }




  export type MoodEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoodEntryWhereInput
    orderBy?: MoodEntryOrderByWithAggregationInput | MoodEntryOrderByWithAggregationInput[]
    by: MoodEntryScalarFieldEnum[] | MoodEntryScalarFieldEnum
    having?: MoodEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MoodEntryCountAggregateInputType | true
    _avg?: MoodEntryAvgAggregateInputType
    _sum?: MoodEntrySumAggregateInputType
    _min?: MoodEntryMinAggregateInputType
    _max?: MoodEntryMaxAggregateInputType
  }

  export type MoodEntryGroupByOutputType = {
    id: string
    profileId: string
    mood: string
    intensity: number
    emotions: string[]
    activities: string[]
    location: string | null
    weather: string | null
    notes: string | null
    triggers: string | null
    gratitude: string | null
    recordedAt: Date
    createdAt: Date
    _count: MoodEntryCountAggregateOutputType | null
    _avg: MoodEntryAvgAggregateOutputType | null
    _sum: MoodEntrySumAggregateOutputType | null
    _min: MoodEntryMinAggregateOutputType | null
    _max: MoodEntryMaxAggregateOutputType | null
  }

  type GetMoodEntryGroupByPayload<T extends MoodEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MoodEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MoodEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MoodEntryGroupByOutputType[P]>
            : GetScalarType<T[P], MoodEntryGroupByOutputType[P]>
        }
      >
    >


  export type MoodEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    mood?: boolean
    intensity?: boolean
    emotions?: boolean
    activities?: boolean
    location?: boolean
    weather?: boolean
    notes?: boolean
    triggers?: boolean
    gratitude?: boolean
    recordedAt?: boolean
    createdAt?: boolean
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moodEntry"]>

  export type MoodEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    mood?: boolean
    intensity?: boolean
    emotions?: boolean
    activities?: boolean
    location?: boolean
    weather?: boolean
    notes?: boolean
    triggers?: boolean
    gratitude?: boolean
    recordedAt?: boolean
    createdAt?: boolean
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moodEntry"]>

  export type MoodEntrySelectScalar = {
    id?: boolean
    profileId?: boolean
    mood?: boolean
    intensity?: boolean
    emotions?: boolean
    activities?: boolean
    location?: boolean
    weather?: boolean
    notes?: boolean
    triggers?: boolean
    gratitude?: boolean
    recordedAt?: boolean
    createdAt?: boolean
  }

  export type MoodEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
  }
  export type MoodEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
  }

  export type $MoodEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MoodEntry"
    objects: {
      profile: Prisma.$LifeOSProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      mood: string
      intensity: number
      emotions: string[]
      activities: string[]
      location: string | null
      weather: string | null
      notes: string | null
      triggers: string | null
      gratitude: string | null
      recordedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["moodEntry"]>
    composites: {}
  }

  type MoodEntryGetPayload<S extends boolean | null | undefined | MoodEntryDefaultArgs> = $Result.GetResult<Prisma.$MoodEntryPayload, S>

  type MoodEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MoodEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MoodEntryCountAggregateInputType | true
    }

  export interface MoodEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MoodEntry'], meta: { name: 'MoodEntry' } }
    /**
     * Find zero or one MoodEntry that matches the filter.
     * @param {MoodEntryFindUniqueArgs} args - Arguments to find a MoodEntry
     * @example
     * // Get one MoodEntry
     * const moodEntry = await prisma.moodEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MoodEntryFindUniqueArgs>(args: SelectSubset<T, MoodEntryFindUniqueArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MoodEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MoodEntryFindUniqueOrThrowArgs} args - Arguments to find a MoodEntry
     * @example
     * // Get one MoodEntry
     * const moodEntry = await prisma.moodEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MoodEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, MoodEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MoodEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryFindFirstArgs} args - Arguments to find a MoodEntry
     * @example
     * // Get one MoodEntry
     * const moodEntry = await prisma.moodEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MoodEntryFindFirstArgs>(args?: SelectSubset<T, MoodEntryFindFirstArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MoodEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryFindFirstOrThrowArgs} args - Arguments to find a MoodEntry
     * @example
     * // Get one MoodEntry
     * const moodEntry = await prisma.moodEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MoodEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, MoodEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MoodEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MoodEntries
     * const moodEntries = await prisma.moodEntry.findMany()
     * 
     * // Get first 10 MoodEntries
     * const moodEntries = await prisma.moodEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moodEntryWithIdOnly = await prisma.moodEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MoodEntryFindManyArgs>(args?: SelectSubset<T, MoodEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MoodEntry.
     * @param {MoodEntryCreateArgs} args - Arguments to create a MoodEntry.
     * @example
     * // Create one MoodEntry
     * const MoodEntry = await prisma.moodEntry.create({
     *   data: {
     *     // ... data to create a MoodEntry
     *   }
     * })
     * 
     */
    create<T extends MoodEntryCreateArgs>(args: SelectSubset<T, MoodEntryCreateArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MoodEntries.
     * @param {MoodEntryCreateManyArgs} args - Arguments to create many MoodEntries.
     * @example
     * // Create many MoodEntries
     * const moodEntry = await prisma.moodEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MoodEntryCreateManyArgs>(args?: SelectSubset<T, MoodEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MoodEntries and returns the data saved in the database.
     * @param {MoodEntryCreateManyAndReturnArgs} args - Arguments to create many MoodEntries.
     * @example
     * // Create many MoodEntries
     * const moodEntry = await prisma.moodEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MoodEntries and only return the `id`
     * const moodEntryWithIdOnly = await prisma.moodEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MoodEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, MoodEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MoodEntry.
     * @param {MoodEntryDeleteArgs} args - Arguments to delete one MoodEntry.
     * @example
     * // Delete one MoodEntry
     * const MoodEntry = await prisma.moodEntry.delete({
     *   where: {
     *     // ... filter to delete one MoodEntry
     *   }
     * })
     * 
     */
    delete<T extends MoodEntryDeleteArgs>(args: SelectSubset<T, MoodEntryDeleteArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MoodEntry.
     * @param {MoodEntryUpdateArgs} args - Arguments to update one MoodEntry.
     * @example
     * // Update one MoodEntry
     * const moodEntry = await prisma.moodEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MoodEntryUpdateArgs>(args: SelectSubset<T, MoodEntryUpdateArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MoodEntries.
     * @param {MoodEntryDeleteManyArgs} args - Arguments to filter MoodEntries to delete.
     * @example
     * // Delete a few MoodEntries
     * const { count } = await prisma.moodEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MoodEntryDeleteManyArgs>(args?: SelectSubset<T, MoodEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MoodEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MoodEntries
     * const moodEntry = await prisma.moodEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MoodEntryUpdateManyArgs>(args: SelectSubset<T, MoodEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MoodEntry.
     * @param {MoodEntryUpsertArgs} args - Arguments to update or create a MoodEntry.
     * @example
     * // Update or create a MoodEntry
     * const moodEntry = await prisma.moodEntry.upsert({
     *   create: {
     *     // ... data to create a MoodEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MoodEntry we want to update
     *   }
     * })
     */
    upsert<T extends MoodEntryUpsertArgs>(args: SelectSubset<T, MoodEntryUpsertArgs<ExtArgs>>): Prisma__MoodEntryClient<$Result.GetResult<Prisma.$MoodEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MoodEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryCountArgs} args - Arguments to filter MoodEntries to count.
     * @example
     * // Count the number of MoodEntries
     * const count = await prisma.moodEntry.count({
     *   where: {
     *     // ... the filter for the MoodEntries we want to count
     *   }
     * })
    **/
    count<T extends MoodEntryCountArgs>(
      args?: Subset<T, MoodEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MoodEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MoodEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MoodEntryAggregateArgs>(args: Subset<T, MoodEntryAggregateArgs>): Prisma.PrismaPromise<GetMoodEntryAggregateType<T>>

    /**
     * Group by MoodEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MoodEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MoodEntryGroupByArgs['orderBy'] }
        : { orderBy?: MoodEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MoodEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMoodEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MoodEntry model
   */
  readonly fields: MoodEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MoodEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MoodEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends LifeOSProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LifeOSProfileDefaultArgs<ExtArgs>>): Prisma__LifeOSProfileClient<$Result.GetResult<Prisma.$LifeOSProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MoodEntry model
   */ 
  interface MoodEntryFieldRefs {
    readonly id: FieldRef<"MoodEntry", 'String'>
    readonly profileId: FieldRef<"MoodEntry", 'String'>
    readonly mood: FieldRef<"MoodEntry", 'String'>
    readonly intensity: FieldRef<"MoodEntry", 'Int'>
    readonly emotions: FieldRef<"MoodEntry", 'String[]'>
    readonly activities: FieldRef<"MoodEntry", 'String[]'>
    readonly location: FieldRef<"MoodEntry", 'String'>
    readonly weather: FieldRef<"MoodEntry", 'String'>
    readonly notes: FieldRef<"MoodEntry", 'String'>
    readonly triggers: FieldRef<"MoodEntry", 'String'>
    readonly gratitude: FieldRef<"MoodEntry", 'String'>
    readonly recordedAt: FieldRef<"MoodEntry", 'DateTime'>
    readonly createdAt: FieldRef<"MoodEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MoodEntry findUnique
   */
  export type MoodEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * Filter, which MoodEntry to fetch.
     */
    where: MoodEntryWhereUniqueInput
  }

  /**
   * MoodEntry findUniqueOrThrow
   */
  export type MoodEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * Filter, which MoodEntry to fetch.
     */
    where: MoodEntryWhereUniqueInput
  }

  /**
   * MoodEntry findFirst
   */
  export type MoodEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * Filter, which MoodEntry to fetch.
     */
    where?: MoodEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodEntries to fetch.
     */
    orderBy?: MoodEntryOrderByWithRelationInput | MoodEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MoodEntries.
     */
    cursor?: MoodEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MoodEntries.
     */
    distinct?: MoodEntryScalarFieldEnum | MoodEntryScalarFieldEnum[]
  }

  /**
   * MoodEntry findFirstOrThrow
   */
  export type MoodEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * Filter, which MoodEntry to fetch.
     */
    where?: MoodEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodEntries to fetch.
     */
    orderBy?: MoodEntryOrderByWithRelationInput | MoodEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MoodEntries.
     */
    cursor?: MoodEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MoodEntries.
     */
    distinct?: MoodEntryScalarFieldEnum | MoodEntryScalarFieldEnum[]
  }

  /**
   * MoodEntry findMany
   */
  export type MoodEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * Filter, which MoodEntries to fetch.
     */
    where?: MoodEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodEntries to fetch.
     */
    orderBy?: MoodEntryOrderByWithRelationInput | MoodEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MoodEntries.
     */
    cursor?: MoodEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodEntries.
     */
    skip?: number
    distinct?: MoodEntryScalarFieldEnum | MoodEntryScalarFieldEnum[]
  }

  /**
   * MoodEntry create
   */
  export type MoodEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a MoodEntry.
     */
    data: XOR<MoodEntryCreateInput, MoodEntryUncheckedCreateInput>
  }

  /**
   * MoodEntry createMany
   */
  export type MoodEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MoodEntries.
     */
    data: MoodEntryCreateManyInput | MoodEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MoodEntry createManyAndReturn
   */
  export type MoodEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MoodEntries.
     */
    data: MoodEntryCreateManyInput | MoodEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MoodEntry update
   */
  export type MoodEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a MoodEntry.
     */
    data: XOR<MoodEntryUpdateInput, MoodEntryUncheckedUpdateInput>
    /**
     * Choose, which MoodEntry to update.
     */
    where: MoodEntryWhereUniqueInput
  }

  /**
   * MoodEntry updateMany
   */
  export type MoodEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MoodEntries.
     */
    data: XOR<MoodEntryUpdateManyMutationInput, MoodEntryUncheckedUpdateManyInput>
    /**
     * Filter which MoodEntries to update
     */
    where?: MoodEntryWhereInput
  }

  /**
   * MoodEntry upsert
   */
  export type MoodEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the MoodEntry to update in case it exists.
     */
    where: MoodEntryWhereUniqueInput
    /**
     * In case the MoodEntry found by the `where` argument doesn't exist, create a new MoodEntry with this data.
     */
    create: XOR<MoodEntryCreateInput, MoodEntryUncheckedCreateInput>
    /**
     * In case the MoodEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MoodEntryUpdateInput, MoodEntryUncheckedUpdateInput>
  }

  /**
   * MoodEntry delete
   */
  export type MoodEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
    /**
     * Filter which MoodEntry to delete.
     */
    where: MoodEntryWhereUniqueInput
  }

  /**
   * MoodEntry deleteMany
   */
  export type MoodEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MoodEntries to delete
     */
    where?: MoodEntryWhereInput
  }

  /**
   * MoodEntry without action
   */
  export type MoodEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodEntry
     */
    select?: MoodEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodEntryInclude<ExtArgs> | null
  }


  /**
   * Model Journal
   */

  export type AggregateJournal = {
    _count: JournalCountAggregateOutputType | null
    _min: JournalMinAggregateOutputType | null
    _max: JournalMaxAggregateOutputType | null
  }

  export type JournalMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    title: string | null
    content: string | null
    mood: string | null
    isPrivate: boolean | null
    template: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    title: string | null
    content: string | null
    mood: string | null
    isPrivate: boolean | null
    template: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalCountAggregateOutputType = {
    id: number
    profileId: number
    title: number
    content: number
    mood: number
    tags: number
    isPrivate: number
    template: number
    prompts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JournalMinAggregateInputType = {
    id?: true
    profileId?: true
    title?: true
    content?: true
    mood?: true
    isPrivate?: true
    template?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalMaxAggregateInputType = {
    id?: true
    profileId?: true
    title?: true
    content?: true
    mood?: true
    isPrivate?: true
    template?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalCountAggregateInputType = {
    id?: true
    profileId?: true
    title?: true
    content?: true
    mood?: true
    tags?: true
    isPrivate?: true
    template?: true
    prompts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JournalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Journal to aggregate.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Journals
    **/
    _count?: true | JournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalMaxAggregateInputType
  }

  export type GetJournalAggregateType<T extends JournalAggregateArgs> = {
        [P in keyof T & keyof AggregateJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournal[P]>
      : GetScalarType<T[P], AggregateJournal[P]>
  }




  export type JournalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalWhereInput
    orderBy?: JournalOrderByWithAggregationInput | JournalOrderByWithAggregationInput[]
    by: JournalScalarFieldEnum[] | JournalScalarFieldEnum
    having?: JournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalCountAggregateInputType | true
    _min?: JournalMinAggregateInputType
    _max?: JournalMaxAggregateInputType
  }

  export type JournalGroupByOutputType = {
    id: string
    profileId: string
    title: string | null
    content: string
    mood: string | null
    tags: string[]
    isPrivate: boolean
    template: string | null
    prompts: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: JournalCountAggregateOutputType | null
    _min: JournalMinAggregateOutputType | null
    _max: JournalMaxAggregateOutputType | null
  }

  type GetJournalGroupByPayload<T extends JournalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalGroupByOutputType[P]>
            : GetScalarType<T[P], JournalGroupByOutputType[P]>
        }
      >
    >


  export type JournalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    title?: boolean
    content?: boolean
    mood?: boolean
    tags?: boolean
    isPrivate?: boolean
    template?: boolean
    prompts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journal"]>

  export type JournalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    title?: boolean
    content?: boolean
    mood?: boolean
    tags?: boolean
    isPrivate?: boolean
    template?: boolean
    prompts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journal"]>

  export type JournalSelectScalar = {
    id?: boolean
    profileId?: boolean
    title?: boolean
    content?: boolean
    mood?: boolean
    tags?: boolean
    isPrivate?: boolean
    template?: boolean
    prompts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JournalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
  }
  export type JournalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
  }

  export type $JournalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Journal"
    objects: {
      profile: Prisma.$LifeOSProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      title: string | null
      content: string
      mood: string | null
      tags: string[]
      isPrivate: boolean
      template: string | null
      prompts: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["journal"]>
    composites: {}
  }

  type JournalGetPayload<S extends boolean | null | undefined | JournalDefaultArgs> = $Result.GetResult<Prisma.$JournalPayload, S>

  type JournalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JournalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JournalCountAggregateInputType | true
    }

  export interface JournalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Journal'], meta: { name: 'Journal' } }
    /**
     * Find zero or one Journal that matches the filter.
     * @param {JournalFindUniqueArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalFindUniqueArgs>(args: SelectSubset<T, JournalFindUniqueArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Journal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JournalFindUniqueOrThrowArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Journal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindFirstArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalFindFirstArgs>(args?: SelectSubset<T, JournalFindFirstArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Journal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindFirstOrThrowArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Journals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Journals
     * const journals = await prisma.journal.findMany()
     * 
     * // Get first 10 Journals
     * const journals = await prisma.journal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalWithIdOnly = await prisma.journal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalFindManyArgs>(args?: SelectSubset<T, JournalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Journal.
     * @param {JournalCreateArgs} args - Arguments to create a Journal.
     * @example
     * // Create one Journal
     * const Journal = await prisma.journal.create({
     *   data: {
     *     // ... data to create a Journal
     *   }
     * })
     * 
     */
    create<T extends JournalCreateArgs>(args: SelectSubset<T, JournalCreateArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Journals.
     * @param {JournalCreateManyArgs} args - Arguments to create many Journals.
     * @example
     * // Create many Journals
     * const journal = await prisma.journal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalCreateManyArgs>(args?: SelectSubset<T, JournalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Journals and returns the data saved in the database.
     * @param {JournalCreateManyAndReturnArgs} args - Arguments to create many Journals.
     * @example
     * // Create many Journals
     * const journal = await prisma.journal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Journals and only return the `id`
     * const journalWithIdOnly = await prisma.journal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Journal.
     * @param {JournalDeleteArgs} args - Arguments to delete one Journal.
     * @example
     * // Delete one Journal
     * const Journal = await prisma.journal.delete({
     *   where: {
     *     // ... filter to delete one Journal
     *   }
     * })
     * 
     */
    delete<T extends JournalDeleteArgs>(args: SelectSubset<T, JournalDeleteArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Journal.
     * @param {JournalUpdateArgs} args - Arguments to update one Journal.
     * @example
     * // Update one Journal
     * const journal = await prisma.journal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalUpdateArgs>(args: SelectSubset<T, JournalUpdateArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Journals.
     * @param {JournalDeleteManyArgs} args - Arguments to filter Journals to delete.
     * @example
     * // Delete a few Journals
     * const { count } = await prisma.journal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalDeleteManyArgs>(args?: SelectSubset<T, JournalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Journals
     * const journal = await prisma.journal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalUpdateManyArgs>(args: SelectSubset<T, JournalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Journal.
     * @param {JournalUpsertArgs} args - Arguments to update or create a Journal.
     * @example
     * // Update or create a Journal
     * const journal = await prisma.journal.upsert({
     *   create: {
     *     // ... data to create a Journal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Journal we want to update
     *   }
     * })
     */
    upsert<T extends JournalUpsertArgs>(args: SelectSubset<T, JournalUpsertArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCountArgs} args - Arguments to filter Journals to count.
     * @example
     * // Count the number of Journals
     * const count = await prisma.journal.count({
     *   where: {
     *     // ... the filter for the Journals we want to count
     *   }
     * })
    **/
    count<T extends JournalCountArgs>(
      args?: Subset<T, JournalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Journal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalAggregateArgs>(args: Subset<T, JournalAggregateArgs>): Prisma.PrismaPromise<GetJournalAggregateType<T>>

    /**
     * Group by Journal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalGroupByArgs['orderBy'] }
        : { orderBy?: JournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Journal model
   */
  readonly fields: JournalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Journal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends LifeOSProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LifeOSProfileDefaultArgs<ExtArgs>>): Prisma__LifeOSProfileClient<$Result.GetResult<Prisma.$LifeOSProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Journal model
   */ 
  interface JournalFieldRefs {
    readonly id: FieldRef<"Journal", 'String'>
    readonly profileId: FieldRef<"Journal", 'String'>
    readonly title: FieldRef<"Journal", 'String'>
    readonly content: FieldRef<"Journal", 'String'>
    readonly mood: FieldRef<"Journal", 'String'>
    readonly tags: FieldRef<"Journal", 'String[]'>
    readonly isPrivate: FieldRef<"Journal", 'Boolean'>
    readonly template: FieldRef<"Journal", 'String'>
    readonly prompts: FieldRef<"Journal", 'Json'>
    readonly createdAt: FieldRef<"Journal", 'DateTime'>
    readonly updatedAt: FieldRef<"Journal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Journal findUnique
   */
  export type JournalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal findUniqueOrThrow
   */
  export type JournalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal findFirst
   */
  export type JournalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journals.
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journals.
     */
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Journal findFirstOrThrow
   */
  export type JournalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journals.
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journals.
     */
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Journal findMany
   */
  export type JournalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journals to fetch.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Journals.
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Journal create
   */
  export type JournalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * The data needed to create a Journal.
     */
    data: XOR<JournalCreateInput, JournalUncheckedCreateInput>
  }

  /**
   * Journal createMany
   */
  export type JournalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Journals.
     */
    data: JournalCreateManyInput | JournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Journal createManyAndReturn
   */
  export type JournalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Journals.
     */
    data: JournalCreateManyInput | JournalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Journal update
   */
  export type JournalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * The data needed to update a Journal.
     */
    data: XOR<JournalUpdateInput, JournalUncheckedUpdateInput>
    /**
     * Choose, which Journal to update.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal updateMany
   */
  export type JournalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Journals.
     */
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyInput>
    /**
     * Filter which Journals to update
     */
    where?: JournalWhereInput
  }

  /**
   * Journal upsert
   */
  export type JournalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * The filter to search for the Journal to update in case it exists.
     */
    where: JournalWhereUniqueInput
    /**
     * In case the Journal found by the `where` argument doesn't exist, create a new Journal with this data.
     */
    create: XOR<JournalCreateInput, JournalUncheckedCreateInput>
    /**
     * In case the Journal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalUpdateInput, JournalUncheckedUpdateInput>
  }

  /**
   * Journal delete
   */
  export type JournalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter which Journal to delete.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal deleteMany
   */
  export type JournalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Journals to delete
     */
    where?: JournalWhereInput
  }

  /**
   * Journal without action
   */
  export type JournalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
  }


  /**
   * Model CalendarEvent
   */

  export type AggregateCalendarEvent = {
    _count: CalendarEventCountAggregateOutputType | null
    _min: CalendarEventMinAggregateOutputType | null
    _max: CalendarEventMaxAggregateOutputType | null
  }

  export type CalendarEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    isAllDay: boolean | null
    location: string | null
    url: string | null
    category: string | null
    color: string | null
    isRecurring: boolean | null
    recurrenceRule: string | null
    parentEventId: string | null
    eventType: $Enums.EventType | null
    visibility: $Enums.Visibility | null
    projectId: string | null
    communityEvent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    isAllDay: boolean | null
    location: string | null
    url: string | null
    category: string | null
    color: string | null
    isRecurring: boolean | null
    recurrenceRule: string | null
    parentEventId: string | null
    eventType: $Enums.EventType | null
    visibility: $Enums.Visibility | null
    projectId: string | null
    communityEvent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarEventCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    startTime: number
    endTime: number
    isAllDay: number
    location: number
    url: number
    category: number
    color: number
    isRecurring: number
    recurrenceRule: number
    parentEventId: number
    eventType: number
    visibility: number
    projectId: number
    communityEvent: number
    reminders: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CalendarEventMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    isAllDay?: true
    location?: true
    url?: true
    category?: true
    color?: true
    isRecurring?: true
    recurrenceRule?: true
    parentEventId?: true
    eventType?: true
    visibility?: true
    projectId?: true
    communityEvent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarEventMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    isAllDay?: true
    location?: true
    url?: true
    category?: true
    color?: true
    isRecurring?: true
    recurrenceRule?: true
    parentEventId?: true
    eventType?: true
    visibility?: true
    projectId?: true
    communityEvent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarEventCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    isAllDay?: true
    location?: true
    url?: true
    category?: true
    color?: true
    isRecurring?: true
    recurrenceRule?: true
    parentEventId?: true
    eventType?: true
    visibility?: true
    projectId?: true
    communityEvent?: true
    reminders?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CalendarEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEvent to aggregate.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarEvents
    **/
    _count?: true | CalendarEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarEventMaxAggregateInputType
  }

  export type GetCalendarEventAggregateType<T extends CalendarEventAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarEvent[P]>
      : GetScalarType<T[P], AggregateCalendarEvent[P]>
  }




  export type CalendarEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithAggregationInput | CalendarEventOrderByWithAggregationInput[]
    by: CalendarEventScalarFieldEnum[] | CalendarEventScalarFieldEnum
    having?: CalendarEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarEventCountAggregateInputType | true
    _min?: CalendarEventMinAggregateInputType
    _max?: CalendarEventMaxAggregateInputType
  }

  export type CalendarEventGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string | null
    startTime: Date
    endTime: Date | null
    isAllDay: boolean
    location: string | null
    url: string | null
    category: string | null
    color: string | null
    isRecurring: boolean
    recurrenceRule: string | null
    parentEventId: string | null
    eventType: $Enums.EventType
    visibility: $Enums.Visibility
    projectId: string | null
    communityEvent: boolean
    reminders: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: CalendarEventCountAggregateOutputType | null
    _min: CalendarEventMinAggregateOutputType | null
    _max: CalendarEventMaxAggregateOutputType | null
  }

  type GetCalendarEventGroupByPayload<T extends CalendarEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarEventGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarEventGroupByOutputType[P]>
        }
      >
    >


  export type CalendarEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    isAllDay?: boolean
    location?: boolean
    url?: boolean
    category?: boolean
    color?: boolean
    isRecurring?: boolean
    recurrenceRule?: boolean
    parentEventId?: boolean
    eventType?: boolean
    visibility?: boolean
    projectId?: boolean
    communityEvent?: boolean
    reminders?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | CalendarEvent$projectArgs<ExtArgs>
    attendees?: boolean | CalendarEvent$attendeesArgs<ExtArgs>
    _count?: boolean | CalendarEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEvent"]>

  export type CalendarEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    isAllDay?: boolean
    location?: boolean
    url?: boolean
    category?: boolean
    color?: boolean
    isRecurring?: boolean
    recurrenceRule?: boolean
    parentEventId?: boolean
    eventType?: boolean
    visibility?: boolean
    projectId?: boolean
    communityEvent?: boolean
    reminders?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | CalendarEvent$projectArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEvent"]>

  export type CalendarEventSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    isAllDay?: boolean
    location?: boolean
    url?: boolean
    category?: boolean
    color?: boolean
    isRecurring?: boolean
    recurrenceRule?: boolean
    parentEventId?: boolean
    eventType?: boolean
    visibility?: boolean
    projectId?: boolean
    communityEvent?: boolean
    reminders?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CalendarEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | CalendarEvent$projectArgs<ExtArgs>
    attendees?: boolean | CalendarEvent$attendeesArgs<ExtArgs>
    _count?: boolean | CalendarEventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CalendarEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | CalendarEvent$projectArgs<ExtArgs>
  }

  export type $CalendarEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
      attendees: Prisma.$EventAttendeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string | null
      startTime: Date
      endTime: Date | null
      isAllDay: boolean
      location: string | null
      url: string | null
      category: string | null
      color: string | null
      isRecurring: boolean
      recurrenceRule: string | null
      parentEventId: string | null
      eventType: $Enums.EventType
      visibility: $Enums.Visibility
      projectId: string | null
      communityEvent: boolean
      reminders: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["calendarEvent"]>
    composites: {}
  }

  type CalendarEventGetPayload<S extends boolean | null | undefined | CalendarEventDefaultArgs> = $Result.GetResult<Prisma.$CalendarEventPayload, S>

  type CalendarEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CalendarEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CalendarEventCountAggregateInputType | true
    }

  export interface CalendarEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarEvent'], meta: { name: 'CalendarEvent' } }
    /**
     * Find zero or one CalendarEvent that matches the filter.
     * @param {CalendarEventFindUniqueArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarEventFindUniqueArgs>(args: SelectSubset<T, CalendarEventFindUniqueArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CalendarEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CalendarEventFindUniqueOrThrowArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarEventFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CalendarEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindFirstArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarEventFindFirstArgs>(args?: SelectSubset<T, CalendarEventFindFirstArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CalendarEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindFirstOrThrowArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarEventFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CalendarEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarEvents
     * const calendarEvents = await prisma.calendarEvent.findMany()
     * 
     * // Get first 10 CalendarEvents
     * const calendarEvents = await prisma.calendarEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarEventFindManyArgs>(args?: SelectSubset<T, CalendarEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CalendarEvent.
     * @param {CalendarEventCreateArgs} args - Arguments to create a CalendarEvent.
     * @example
     * // Create one CalendarEvent
     * const CalendarEvent = await prisma.calendarEvent.create({
     *   data: {
     *     // ... data to create a CalendarEvent
     *   }
     * })
     * 
     */
    create<T extends CalendarEventCreateArgs>(args: SelectSubset<T, CalendarEventCreateArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CalendarEvents.
     * @param {CalendarEventCreateManyArgs} args - Arguments to create many CalendarEvents.
     * @example
     * // Create many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarEventCreateManyArgs>(args?: SelectSubset<T, CalendarEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarEvents and returns the data saved in the database.
     * @param {CalendarEventCreateManyAndReturnArgs} args - Arguments to create many CalendarEvents.
     * @example
     * // Create many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarEvents and only return the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarEventCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CalendarEvent.
     * @param {CalendarEventDeleteArgs} args - Arguments to delete one CalendarEvent.
     * @example
     * // Delete one CalendarEvent
     * const CalendarEvent = await prisma.calendarEvent.delete({
     *   where: {
     *     // ... filter to delete one CalendarEvent
     *   }
     * })
     * 
     */
    delete<T extends CalendarEventDeleteArgs>(args: SelectSubset<T, CalendarEventDeleteArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CalendarEvent.
     * @param {CalendarEventUpdateArgs} args - Arguments to update one CalendarEvent.
     * @example
     * // Update one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarEventUpdateArgs>(args: SelectSubset<T, CalendarEventUpdateArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CalendarEvents.
     * @param {CalendarEventDeleteManyArgs} args - Arguments to filter CalendarEvents to delete.
     * @example
     * // Delete a few CalendarEvents
     * const { count } = await prisma.calendarEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarEventDeleteManyArgs>(args?: SelectSubset<T, CalendarEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarEventUpdateManyArgs>(args: SelectSubset<T, CalendarEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CalendarEvent.
     * @param {CalendarEventUpsertArgs} args - Arguments to update or create a CalendarEvent.
     * @example
     * // Update or create a CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.upsert({
     *   create: {
     *     // ... data to create a CalendarEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarEvent we want to update
     *   }
     * })
     */
    upsert<T extends CalendarEventUpsertArgs>(args: SelectSubset<T, CalendarEventUpsertArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CalendarEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventCountArgs} args - Arguments to filter CalendarEvents to count.
     * @example
     * // Count the number of CalendarEvents
     * const count = await prisma.calendarEvent.count({
     *   where: {
     *     // ... the filter for the CalendarEvents we want to count
     *   }
     * })
    **/
    count<T extends CalendarEventCountArgs>(
      args?: Subset<T, CalendarEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarEventAggregateArgs>(args: Subset<T, CalendarEventAggregateArgs>): Prisma.PrismaPromise<GetCalendarEventAggregateType<T>>

    /**
     * Group by CalendarEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarEventGroupByArgs['orderBy'] }
        : { orderBy?: CalendarEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarEvent model
   */
  readonly fields: CalendarEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends CalendarEvent$projectArgs<ExtArgs> = {}>(args?: Subset<T, CalendarEvent$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    attendees<T extends CalendarEvent$attendeesArgs<ExtArgs> = {}>(args?: Subset<T, CalendarEvent$attendeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarEvent model
   */ 
  interface CalendarEventFieldRefs {
    readonly id: FieldRef<"CalendarEvent", 'String'>
    readonly userId: FieldRef<"CalendarEvent", 'String'>
    readonly title: FieldRef<"CalendarEvent", 'String'>
    readonly description: FieldRef<"CalendarEvent", 'String'>
    readonly startTime: FieldRef<"CalendarEvent", 'DateTime'>
    readonly endTime: FieldRef<"CalendarEvent", 'DateTime'>
    readonly isAllDay: FieldRef<"CalendarEvent", 'Boolean'>
    readonly location: FieldRef<"CalendarEvent", 'String'>
    readonly url: FieldRef<"CalendarEvent", 'String'>
    readonly category: FieldRef<"CalendarEvent", 'String'>
    readonly color: FieldRef<"CalendarEvent", 'String'>
    readonly isRecurring: FieldRef<"CalendarEvent", 'Boolean'>
    readonly recurrenceRule: FieldRef<"CalendarEvent", 'String'>
    readonly parentEventId: FieldRef<"CalendarEvent", 'String'>
    readonly eventType: FieldRef<"CalendarEvent", 'EventType'>
    readonly visibility: FieldRef<"CalendarEvent", 'Visibility'>
    readonly projectId: FieldRef<"CalendarEvent", 'String'>
    readonly communityEvent: FieldRef<"CalendarEvent", 'Boolean'>
    readonly reminders: FieldRef<"CalendarEvent", 'Json'>
    readonly createdAt: FieldRef<"CalendarEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"CalendarEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalendarEvent findUnique
   */
  export type CalendarEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent findUniqueOrThrow
   */
  export type CalendarEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent findFirst
   */
  export type CalendarEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEvents.
     */
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent findFirstOrThrow
   */
  export type CalendarEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEvents.
     */
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent findMany
   */
  export type CalendarEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEvents to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent create
   */
  export type CalendarEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarEvent.
     */
    data: XOR<CalendarEventCreateInput, CalendarEventUncheckedCreateInput>
  }

  /**
   * CalendarEvent createMany
   */
  export type CalendarEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarEvents.
     */
    data: CalendarEventCreateManyInput | CalendarEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarEvent createManyAndReturn
   */
  export type CalendarEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CalendarEvents.
     */
    data: CalendarEventCreateManyInput | CalendarEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarEvent update
   */
  export type CalendarEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarEvent.
     */
    data: XOR<CalendarEventUpdateInput, CalendarEventUncheckedUpdateInput>
    /**
     * Choose, which CalendarEvent to update.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent updateMany
   */
  export type CalendarEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarEvents.
     */
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEvents to update
     */
    where?: CalendarEventWhereInput
  }

  /**
   * CalendarEvent upsert
   */
  export type CalendarEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarEvent to update in case it exists.
     */
    where: CalendarEventWhereUniqueInput
    /**
     * In case the CalendarEvent found by the `where` argument doesn't exist, create a new CalendarEvent with this data.
     */
    create: XOR<CalendarEventCreateInput, CalendarEventUncheckedCreateInput>
    /**
     * In case the CalendarEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarEventUpdateInput, CalendarEventUncheckedUpdateInput>
  }

  /**
   * CalendarEvent delete
   */
  export type CalendarEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
    /**
     * Filter which CalendarEvent to delete.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent deleteMany
   */
  export type CalendarEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEvents to delete
     */
    where?: CalendarEventWhereInput
  }

  /**
   * CalendarEvent.project
   */
  export type CalendarEvent$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * CalendarEvent.attendees
   */
  export type CalendarEvent$attendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    where?: EventAttendeeWhereInput
    orderBy?: EventAttendeeOrderByWithRelationInput | EventAttendeeOrderByWithRelationInput[]
    cursor?: EventAttendeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventAttendeeScalarFieldEnum | EventAttendeeScalarFieldEnum[]
  }

  /**
   * CalendarEvent without action
   */
  export type CalendarEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventInclude<ExtArgs> | null
  }


  /**
   * Model EventAttendee
   */

  export type AggregateEventAttendee = {
    _count: EventAttendeeCountAggregateOutputType | null
    _min: EventAttendeeMinAggregateOutputType | null
    _max: EventAttendeeMaxAggregateOutputType | null
  }

  export type EventAttendeeMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    status: $Enums.AttendeeStatus | null
    response: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventAttendeeMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    status: $Enums.AttendeeStatus | null
    response: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventAttendeeCountAggregateOutputType = {
    id: number
    eventId: number
    userId: number
    status: number
    response: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventAttendeeMinAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    status?: true
    response?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventAttendeeMaxAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    status?: true
    response?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventAttendeeCountAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    status?: true
    response?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAttendeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventAttendee to aggregate.
     */
    where?: EventAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventAttendees to fetch.
     */
    orderBy?: EventAttendeeOrderByWithRelationInput | EventAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventAttendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventAttendees
    **/
    _count?: true | EventAttendeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventAttendeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventAttendeeMaxAggregateInputType
  }

  export type GetEventAttendeeAggregateType<T extends EventAttendeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEventAttendee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventAttendee[P]>
      : GetScalarType<T[P], AggregateEventAttendee[P]>
  }




  export type EventAttendeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventAttendeeWhereInput
    orderBy?: EventAttendeeOrderByWithAggregationInput | EventAttendeeOrderByWithAggregationInput[]
    by: EventAttendeeScalarFieldEnum[] | EventAttendeeScalarFieldEnum
    having?: EventAttendeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventAttendeeCountAggregateInputType | true
    _min?: EventAttendeeMinAggregateInputType
    _max?: EventAttendeeMaxAggregateInputType
  }

  export type EventAttendeeGroupByOutputType = {
    id: string
    eventId: string
    userId: string
    status: $Enums.AttendeeStatus
    response: string | null
    createdAt: Date
    updatedAt: Date
    _count: EventAttendeeCountAggregateOutputType | null
    _min: EventAttendeeMinAggregateOutputType | null
    _max: EventAttendeeMaxAggregateOutputType | null
  }

  type GetEventAttendeeGroupByPayload<T extends EventAttendeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventAttendeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventAttendeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventAttendeeGroupByOutputType[P]>
            : GetScalarType<T[P], EventAttendeeGroupByOutputType[P]>
        }
      >
    >


  export type EventAttendeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    status?: boolean
    response?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | CalendarEventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventAttendee"]>

  export type EventAttendeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    status?: boolean
    response?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | CalendarEventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventAttendee"]>

  export type EventAttendeeSelectScalar = {
    id?: boolean
    eventId?: boolean
    userId?: boolean
    status?: boolean
    response?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventAttendeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | CalendarEventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EventAttendeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | CalendarEventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EventAttendeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventAttendee"
    objects: {
      event: Prisma.$CalendarEventPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      userId: string
      status: $Enums.AttendeeStatus
      response: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["eventAttendee"]>
    composites: {}
  }

  type EventAttendeeGetPayload<S extends boolean | null | undefined | EventAttendeeDefaultArgs> = $Result.GetResult<Prisma.$EventAttendeePayload, S>

  type EventAttendeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventAttendeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventAttendeeCountAggregateInputType | true
    }

  export interface EventAttendeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventAttendee'], meta: { name: 'EventAttendee' } }
    /**
     * Find zero or one EventAttendee that matches the filter.
     * @param {EventAttendeeFindUniqueArgs} args - Arguments to find a EventAttendee
     * @example
     * // Get one EventAttendee
     * const eventAttendee = await prisma.eventAttendee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventAttendeeFindUniqueArgs>(args: SelectSubset<T, EventAttendeeFindUniqueArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventAttendee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventAttendeeFindUniqueOrThrowArgs} args - Arguments to find a EventAttendee
     * @example
     * // Get one EventAttendee
     * const eventAttendee = await prisma.eventAttendee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventAttendeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EventAttendeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventAttendee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeFindFirstArgs} args - Arguments to find a EventAttendee
     * @example
     * // Get one EventAttendee
     * const eventAttendee = await prisma.eventAttendee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventAttendeeFindFirstArgs>(args?: SelectSubset<T, EventAttendeeFindFirstArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventAttendee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeFindFirstOrThrowArgs} args - Arguments to find a EventAttendee
     * @example
     * // Get one EventAttendee
     * const eventAttendee = await prisma.eventAttendee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventAttendeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EventAttendeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventAttendees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventAttendees
     * const eventAttendees = await prisma.eventAttendee.findMany()
     * 
     * // Get first 10 EventAttendees
     * const eventAttendees = await prisma.eventAttendee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventAttendeeWithIdOnly = await prisma.eventAttendee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventAttendeeFindManyArgs>(args?: SelectSubset<T, EventAttendeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventAttendee.
     * @param {EventAttendeeCreateArgs} args - Arguments to create a EventAttendee.
     * @example
     * // Create one EventAttendee
     * const EventAttendee = await prisma.eventAttendee.create({
     *   data: {
     *     // ... data to create a EventAttendee
     *   }
     * })
     * 
     */
    create<T extends EventAttendeeCreateArgs>(args: SelectSubset<T, EventAttendeeCreateArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventAttendees.
     * @param {EventAttendeeCreateManyArgs} args - Arguments to create many EventAttendees.
     * @example
     * // Create many EventAttendees
     * const eventAttendee = await prisma.eventAttendee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventAttendeeCreateManyArgs>(args?: SelectSubset<T, EventAttendeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventAttendees and returns the data saved in the database.
     * @param {EventAttendeeCreateManyAndReturnArgs} args - Arguments to create many EventAttendees.
     * @example
     * // Create many EventAttendees
     * const eventAttendee = await prisma.eventAttendee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventAttendees and only return the `id`
     * const eventAttendeeWithIdOnly = await prisma.eventAttendee.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventAttendeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EventAttendeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EventAttendee.
     * @param {EventAttendeeDeleteArgs} args - Arguments to delete one EventAttendee.
     * @example
     * // Delete one EventAttendee
     * const EventAttendee = await prisma.eventAttendee.delete({
     *   where: {
     *     // ... filter to delete one EventAttendee
     *   }
     * })
     * 
     */
    delete<T extends EventAttendeeDeleteArgs>(args: SelectSubset<T, EventAttendeeDeleteArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventAttendee.
     * @param {EventAttendeeUpdateArgs} args - Arguments to update one EventAttendee.
     * @example
     * // Update one EventAttendee
     * const eventAttendee = await prisma.eventAttendee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventAttendeeUpdateArgs>(args: SelectSubset<T, EventAttendeeUpdateArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventAttendees.
     * @param {EventAttendeeDeleteManyArgs} args - Arguments to filter EventAttendees to delete.
     * @example
     * // Delete a few EventAttendees
     * const { count } = await prisma.eventAttendee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventAttendeeDeleteManyArgs>(args?: SelectSubset<T, EventAttendeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventAttendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventAttendees
     * const eventAttendee = await prisma.eventAttendee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventAttendeeUpdateManyArgs>(args: SelectSubset<T, EventAttendeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventAttendee.
     * @param {EventAttendeeUpsertArgs} args - Arguments to update or create a EventAttendee.
     * @example
     * // Update or create a EventAttendee
     * const eventAttendee = await prisma.eventAttendee.upsert({
     *   create: {
     *     // ... data to create a EventAttendee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventAttendee we want to update
     *   }
     * })
     */
    upsert<T extends EventAttendeeUpsertArgs>(args: SelectSubset<T, EventAttendeeUpsertArgs<ExtArgs>>): Prisma__EventAttendeeClient<$Result.GetResult<Prisma.$EventAttendeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventAttendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeCountArgs} args - Arguments to filter EventAttendees to count.
     * @example
     * // Count the number of EventAttendees
     * const count = await prisma.eventAttendee.count({
     *   where: {
     *     // ... the filter for the EventAttendees we want to count
     *   }
     * })
    **/
    count<T extends EventAttendeeCountArgs>(
      args?: Subset<T, EventAttendeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventAttendeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventAttendee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAttendeeAggregateArgs>(args: Subset<T, EventAttendeeAggregateArgs>): Prisma.PrismaPromise<GetEventAttendeeAggregateType<T>>

    /**
     * Group by EventAttendee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAttendeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventAttendeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventAttendeeGroupByArgs['orderBy'] }
        : { orderBy?: EventAttendeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventAttendeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventAttendeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventAttendee model
   */
  readonly fields: EventAttendeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventAttendee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventAttendeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends CalendarEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CalendarEventDefaultArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventAttendee model
   */ 
  interface EventAttendeeFieldRefs {
    readonly id: FieldRef<"EventAttendee", 'String'>
    readonly eventId: FieldRef<"EventAttendee", 'String'>
    readonly userId: FieldRef<"EventAttendee", 'String'>
    readonly status: FieldRef<"EventAttendee", 'AttendeeStatus'>
    readonly response: FieldRef<"EventAttendee", 'String'>
    readonly createdAt: FieldRef<"EventAttendee", 'DateTime'>
    readonly updatedAt: FieldRef<"EventAttendee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventAttendee findUnique
   */
  export type EventAttendeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which EventAttendee to fetch.
     */
    where: EventAttendeeWhereUniqueInput
  }

  /**
   * EventAttendee findUniqueOrThrow
   */
  export type EventAttendeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which EventAttendee to fetch.
     */
    where: EventAttendeeWhereUniqueInput
  }

  /**
   * EventAttendee findFirst
   */
  export type EventAttendeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which EventAttendee to fetch.
     */
    where?: EventAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventAttendees to fetch.
     */
    orderBy?: EventAttendeeOrderByWithRelationInput | EventAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventAttendees.
     */
    cursor?: EventAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventAttendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventAttendees.
     */
    distinct?: EventAttendeeScalarFieldEnum | EventAttendeeScalarFieldEnum[]
  }

  /**
   * EventAttendee findFirstOrThrow
   */
  export type EventAttendeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which EventAttendee to fetch.
     */
    where?: EventAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventAttendees to fetch.
     */
    orderBy?: EventAttendeeOrderByWithRelationInput | EventAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventAttendees.
     */
    cursor?: EventAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventAttendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventAttendees.
     */
    distinct?: EventAttendeeScalarFieldEnum | EventAttendeeScalarFieldEnum[]
  }

  /**
   * EventAttendee findMany
   */
  export type EventAttendeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * Filter, which EventAttendees to fetch.
     */
    where?: EventAttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventAttendees to fetch.
     */
    orderBy?: EventAttendeeOrderByWithRelationInput | EventAttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventAttendees.
     */
    cursor?: EventAttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventAttendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventAttendees.
     */
    skip?: number
    distinct?: EventAttendeeScalarFieldEnum | EventAttendeeScalarFieldEnum[]
  }

  /**
   * EventAttendee create
   */
  export type EventAttendeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * The data needed to create a EventAttendee.
     */
    data: XOR<EventAttendeeCreateInput, EventAttendeeUncheckedCreateInput>
  }

  /**
   * EventAttendee createMany
   */
  export type EventAttendeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventAttendees.
     */
    data: EventAttendeeCreateManyInput | EventAttendeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventAttendee createManyAndReturn
   */
  export type EventAttendeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EventAttendees.
     */
    data: EventAttendeeCreateManyInput | EventAttendeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventAttendee update
   */
  export type EventAttendeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * The data needed to update a EventAttendee.
     */
    data: XOR<EventAttendeeUpdateInput, EventAttendeeUncheckedUpdateInput>
    /**
     * Choose, which EventAttendee to update.
     */
    where: EventAttendeeWhereUniqueInput
  }

  /**
   * EventAttendee updateMany
   */
  export type EventAttendeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventAttendees.
     */
    data: XOR<EventAttendeeUpdateManyMutationInput, EventAttendeeUncheckedUpdateManyInput>
    /**
     * Filter which EventAttendees to update
     */
    where?: EventAttendeeWhereInput
  }

  /**
   * EventAttendee upsert
   */
  export type EventAttendeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * The filter to search for the EventAttendee to update in case it exists.
     */
    where: EventAttendeeWhereUniqueInput
    /**
     * In case the EventAttendee found by the `where` argument doesn't exist, create a new EventAttendee with this data.
     */
    create: XOR<EventAttendeeCreateInput, EventAttendeeUncheckedCreateInput>
    /**
     * In case the EventAttendee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventAttendeeUpdateInput, EventAttendeeUncheckedUpdateInput>
  }

  /**
   * EventAttendee delete
   */
  export type EventAttendeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
    /**
     * Filter which EventAttendee to delete.
     */
    where: EventAttendeeWhereUniqueInput
  }

  /**
   * EventAttendee deleteMany
   */
  export type EventAttendeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventAttendees to delete
     */
    where?: EventAttendeeWhereInput
  }

  /**
   * EventAttendee without action
   */
  export type EventAttendeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventAttendee
     */
    select?: EventAttendeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventAttendeeInclude<ExtArgs> | null
  }


  /**
   * Model FinancialTransaction
   */

  export type AggregateFinancialTransaction = {
    _count: FinancialTransactionCountAggregateOutputType | null
    _avg: FinancialTransactionAvgAggregateOutputType | null
    _sum: FinancialTransactionSumAggregateOutputType | null
    _min: FinancialTransactionMinAggregateOutputType | null
    _max: FinancialTransactionMaxAggregateOutputType | null
  }

  export type FinancialTransactionAvgAggregateOutputType = {
    amount: number | null
    gstAmount: number | null
  }

  export type FinancialTransactionSumAggregateOutputType = {
    amount: number | null
    gstAmount: number | null
  }

  export type FinancialTransactionMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    amount: number | null
    currency: string | null
    description: string | null
    notes: string | null
    type: $Enums.TransactionType | null
    category: string | null
    subcategory: string | null
    merchant: string | null
    location: string | null
    paymentMethod: string | null
    budgetId: string | null
    gstAmount: number | null
    taxCategory: string | null
    transactionDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FinancialTransactionMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    amount: number | null
    currency: string | null
    description: string | null
    notes: string | null
    type: $Enums.TransactionType | null
    category: string | null
    subcategory: string | null
    merchant: string | null
    location: string | null
    paymentMethod: string | null
    budgetId: string | null
    gstAmount: number | null
    taxCategory: string | null
    transactionDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FinancialTransactionCountAggregateOutputType = {
    id: number
    profileId: number
    amount: number
    currency: number
    description: number
    notes: number
    type: number
    category: number
    subcategory: number
    merchant: number
    location: number
    paymentMethod: number
    budgetId: number
    tags: number
    gstAmount: number
    taxCategory: number
    transactionDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FinancialTransactionAvgAggregateInputType = {
    amount?: true
    gstAmount?: true
  }

  export type FinancialTransactionSumAggregateInputType = {
    amount?: true
    gstAmount?: true
  }

  export type FinancialTransactionMinAggregateInputType = {
    id?: true
    profileId?: true
    amount?: true
    currency?: true
    description?: true
    notes?: true
    type?: true
    category?: true
    subcategory?: true
    merchant?: true
    location?: true
    paymentMethod?: true
    budgetId?: true
    gstAmount?: true
    taxCategory?: true
    transactionDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FinancialTransactionMaxAggregateInputType = {
    id?: true
    profileId?: true
    amount?: true
    currency?: true
    description?: true
    notes?: true
    type?: true
    category?: true
    subcategory?: true
    merchant?: true
    location?: true
    paymentMethod?: true
    budgetId?: true
    gstAmount?: true
    taxCategory?: true
    transactionDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FinancialTransactionCountAggregateInputType = {
    id?: true
    profileId?: true
    amount?: true
    currency?: true
    description?: true
    notes?: true
    type?: true
    category?: true
    subcategory?: true
    merchant?: true
    location?: true
    paymentMethod?: true
    budgetId?: true
    tags?: true
    gstAmount?: true
    taxCategory?: true
    transactionDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FinancialTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialTransaction to aggregate.
     */
    where?: FinancialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialTransactions to fetch.
     */
    orderBy?: FinancialTransactionOrderByWithRelationInput | FinancialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialTransactions
    **/
    _count?: true | FinancialTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancialTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancialTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialTransactionMaxAggregateInputType
  }

  export type GetFinancialTransactionAggregateType<T extends FinancialTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialTransaction[P]>
      : GetScalarType<T[P], AggregateFinancialTransaction[P]>
  }




  export type FinancialTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialTransactionWhereInput
    orderBy?: FinancialTransactionOrderByWithAggregationInput | FinancialTransactionOrderByWithAggregationInput[]
    by: FinancialTransactionScalarFieldEnum[] | FinancialTransactionScalarFieldEnum
    having?: FinancialTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialTransactionCountAggregateInputType | true
    _avg?: FinancialTransactionAvgAggregateInputType
    _sum?: FinancialTransactionSumAggregateInputType
    _min?: FinancialTransactionMinAggregateInputType
    _max?: FinancialTransactionMaxAggregateInputType
  }

  export type FinancialTransactionGroupByOutputType = {
    id: string
    profileId: string
    amount: number
    currency: string
    description: string
    notes: string | null
    type: $Enums.TransactionType
    category: string
    subcategory: string | null
    merchant: string | null
    location: string | null
    paymentMethod: string | null
    budgetId: string | null
    tags: string[]
    gstAmount: number | null
    taxCategory: string | null
    transactionDate: Date
    createdAt: Date
    updatedAt: Date
    _count: FinancialTransactionCountAggregateOutputType | null
    _avg: FinancialTransactionAvgAggregateOutputType | null
    _sum: FinancialTransactionSumAggregateOutputType | null
    _min: FinancialTransactionMinAggregateOutputType | null
    _max: FinancialTransactionMaxAggregateOutputType | null
  }

  type GetFinancialTransactionGroupByPayload<T extends FinancialTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialTransactionGroupByOutputType[P]>
        }
      >
    >


  export type FinancialTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    notes?: boolean
    type?: boolean
    category?: boolean
    subcategory?: boolean
    merchant?: boolean
    location?: boolean
    paymentMethod?: boolean
    budgetId?: boolean
    tags?: boolean
    gstAmount?: boolean
    taxCategory?: boolean
    transactionDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
    budget?: boolean | FinancialTransaction$budgetArgs<ExtArgs>
  }, ExtArgs["result"]["financialTransaction"]>

  export type FinancialTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    notes?: boolean
    type?: boolean
    category?: boolean
    subcategory?: boolean
    merchant?: boolean
    location?: boolean
    paymentMethod?: boolean
    budgetId?: boolean
    tags?: boolean
    gstAmount?: boolean
    taxCategory?: boolean
    transactionDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
    budget?: boolean | FinancialTransaction$budgetArgs<ExtArgs>
  }, ExtArgs["result"]["financialTransaction"]>

  export type FinancialTransactionSelectScalar = {
    id?: boolean
    profileId?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    notes?: boolean
    type?: boolean
    category?: boolean
    subcategory?: boolean
    merchant?: boolean
    location?: boolean
    paymentMethod?: boolean
    budgetId?: boolean
    tags?: boolean
    gstAmount?: boolean
    taxCategory?: boolean
    transactionDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FinancialTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
    budget?: boolean | FinancialTransaction$budgetArgs<ExtArgs>
  }
  export type FinancialTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
    budget?: boolean | FinancialTransaction$budgetArgs<ExtArgs>
  }

  export type $FinancialTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialTransaction"
    objects: {
      profile: Prisma.$LifeOSProfilePayload<ExtArgs>
      budget: Prisma.$BudgetPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      amount: number
      currency: string
      description: string
      notes: string | null
      type: $Enums.TransactionType
      category: string
      subcategory: string | null
      merchant: string | null
      location: string | null
      paymentMethod: string | null
      budgetId: string | null
      tags: string[]
      gstAmount: number | null
      taxCategory: string | null
      transactionDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["financialTransaction"]>
    composites: {}
  }

  type FinancialTransactionGetPayload<S extends boolean | null | undefined | FinancialTransactionDefaultArgs> = $Result.GetResult<Prisma.$FinancialTransactionPayload, S>

  type FinancialTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FinancialTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FinancialTransactionCountAggregateInputType | true
    }

  export interface FinancialTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialTransaction'], meta: { name: 'FinancialTransaction' } }
    /**
     * Find zero or one FinancialTransaction that matches the filter.
     * @param {FinancialTransactionFindUniqueArgs} args - Arguments to find a FinancialTransaction
     * @example
     * // Get one FinancialTransaction
     * const financialTransaction = await prisma.financialTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancialTransactionFindUniqueArgs>(args: SelectSubset<T, FinancialTransactionFindUniqueArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FinancialTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FinancialTransactionFindUniqueOrThrowArgs} args - Arguments to find a FinancialTransaction
     * @example
     * // Get one FinancialTransaction
     * const financialTransaction = await prisma.financialTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancialTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancialTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FinancialTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionFindFirstArgs} args - Arguments to find a FinancialTransaction
     * @example
     * // Get one FinancialTransaction
     * const financialTransaction = await prisma.financialTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancialTransactionFindFirstArgs>(args?: SelectSubset<T, FinancialTransactionFindFirstArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FinancialTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionFindFirstOrThrowArgs} args - Arguments to find a FinancialTransaction
     * @example
     * // Get one FinancialTransaction
     * const financialTransaction = await prisma.financialTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancialTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancialTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FinancialTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialTransactions
     * const financialTransactions = await prisma.financialTransaction.findMany()
     * 
     * // Get first 10 FinancialTransactions
     * const financialTransactions = await prisma.financialTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financialTransactionWithIdOnly = await prisma.financialTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancialTransactionFindManyArgs>(args?: SelectSubset<T, FinancialTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FinancialTransaction.
     * @param {FinancialTransactionCreateArgs} args - Arguments to create a FinancialTransaction.
     * @example
     * // Create one FinancialTransaction
     * const FinancialTransaction = await prisma.financialTransaction.create({
     *   data: {
     *     // ... data to create a FinancialTransaction
     *   }
     * })
     * 
     */
    create<T extends FinancialTransactionCreateArgs>(args: SelectSubset<T, FinancialTransactionCreateArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FinancialTransactions.
     * @param {FinancialTransactionCreateManyArgs} args - Arguments to create many FinancialTransactions.
     * @example
     * // Create many FinancialTransactions
     * const financialTransaction = await prisma.financialTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancialTransactionCreateManyArgs>(args?: SelectSubset<T, FinancialTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinancialTransactions and returns the data saved in the database.
     * @param {FinancialTransactionCreateManyAndReturnArgs} args - Arguments to create many FinancialTransactions.
     * @example
     * // Create many FinancialTransactions
     * const financialTransaction = await prisma.financialTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinancialTransactions and only return the `id`
     * const financialTransactionWithIdOnly = await prisma.financialTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinancialTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, FinancialTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FinancialTransaction.
     * @param {FinancialTransactionDeleteArgs} args - Arguments to delete one FinancialTransaction.
     * @example
     * // Delete one FinancialTransaction
     * const FinancialTransaction = await prisma.financialTransaction.delete({
     *   where: {
     *     // ... filter to delete one FinancialTransaction
     *   }
     * })
     * 
     */
    delete<T extends FinancialTransactionDeleteArgs>(args: SelectSubset<T, FinancialTransactionDeleteArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FinancialTransaction.
     * @param {FinancialTransactionUpdateArgs} args - Arguments to update one FinancialTransaction.
     * @example
     * // Update one FinancialTransaction
     * const financialTransaction = await prisma.financialTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancialTransactionUpdateArgs>(args: SelectSubset<T, FinancialTransactionUpdateArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FinancialTransactions.
     * @param {FinancialTransactionDeleteManyArgs} args - Arguments to filter FinancialTransactions to delete.
     * @example
     * // Delete a few FinancialTransactions
     * const { count } = await prisma.financialTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancialTransactionDeleteManyArgs>(args?: SelectSubset<T, FinancialTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialTransactions
     * const financialTransaction = await prisma.financialTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancialTransactionUpdateManyArgs>(args: SelectSubset<T, FinancialTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FinancialTransaction.
     * @param {FinancialTransactionUpsertArgs} args - Arguments to update or create a FinancialTransaction.
     * @example
     * // Update or create a FinancialTransaction
     * const financialTransaction = await prisma.financialTransaction.upsert({
     *   create: {
     *     // ... data to create a FinancialTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialTransaction we want to update
     *   }
     * })
     */
    upsert<T extends FinancialTransactionUpsertArgs>(args: SelectSubset<T, FinancialTransactionUpsertArgs<ExtArgs>>): Prisma__FinancialTransactionClient<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FinancialTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionCountArgs} args - Arguments to filter FinancialTransactions to count.
     * @example
     * // Count the number of FinancialTransactions
     * const count = await prisma.financialTransaction.count({
     *   where: {
     *     // ... the filter for the FinancialTransactions we want to count
     *   }
     * })
    **/
    count<T extends FinancialTransactionCountArgs>(
      args?: Subset<T, FinancialTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialTransactionAggregateArgs>(args: Subset<T, FinancialTransactionAggregateArgs>): Prisma.PrismaPromise<GetFinancialTransactionAggregateType<T>>

    /**
     * Group by FinancialTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialTransactionGroupByArgs['orderBy'] }
        : { orderBy?: FinancialTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialTransaction model
   */
  readonly fields: FinancialTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends LifeOSProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LifeOSProfileDefaultArgs<ExtArgs>>): Prisma__LifeOSProfileClient<$Result.GetResult<Prisma.$LifeOSProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    budget<T extends FinancialTransaction$budgetArgs<ExtArgs> = {}>(args?: Subset<T, FinancialTransaction$budgetArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancialTransaction model
   */ 
  interface FinancialTransactionFieldRefs {
    readonly id: FieldRef<"FinancialTransaction", 'String'>
    readonly profileId: FieldRef<"FinancialTransaction", 'String'>
    readonly amount: FieldRef<"FinancialTransaction", 'Float'>
    readonly currency: FieldRef<"FinancialTransaction", 'String'>
    readonly description: FieldRef<"FinancialTransaction", 'String'>
    readonly notes: FieldRef<"FinancialTransaction", 'String'>
    readonly type: FieldRef<"FinancialTransaction", 'TransactionType'>
    readonly category: FieldRef<"FinancialTransaction", 'String'>
    readonly subcategory: FieldRef<"FinancialTransaction", 'String'>
    readonly merchant: FieldRef<"FinancialTransaction", 'String'>
    readonly location: FieldRef<"FinancialTransaction", 'String'>
    readonly paymentMethod: FieldRef<"FinancialTransaction", 'String'>
    readonly budgetId: FieldRef<"FinancialTransaction", 'String'>
    readonly tags: FieldRef<"FinancialTransaction", 'String[]'>
    readonly gstAmount: FieldRef<"FinancialTransaction", 'Float'>
    readonly taxCategory: FieldRef<"FinancialTransaction", 'String'>
    readonly transactionDate: FieldRef<"FinancialTransaction", 'DateTime'>
    readonly createdAt: FieldRef<"FinancialTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"FinancialTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FinancialTransaction findUnique
   */
  export type FinancialTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which FinancialTransaction to fetch.
     */
    where: FinancialTransactionWhereUniqueInput
  }

  /**
   * FinancialTransaction findUniqueOrThrow
   */
  export type FinancialTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which FinancialTransaction to fetch.
     */
    where: FinancialTransactionWhereUniqueInput
  }

  /**
   * FinancialTransaction findFirst
   */
  export type FinancialTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which FinancialTransaction to fetch.
     */
    where?: FinancialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialTransactions to fetch.
     */
    orderBy?: FinancialTransactionOrderByWithRelationInput | FinancialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialTransactions.
     */
    cursor?: FinancialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialTransactions.
     */
    distinct?: FinancialTransactionScalarFieldEnum | FinancialTransactionScalarFieldEnum[]
  }

  /**
   * FinancialTransaction findFirstOrThrow
   */
  export type FinancialTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which FinancialTransaction to fetch.
     */
    where?: FinancialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialTransactions to fetch.
     */
    orderBy?: FinancialTransactionOrderByWithRelationInput | FinancialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialTransactions.
     */
    cursor?: FinancialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialTransactions.
     */
    distinct?: FinancialTransactionScalarFieldEnum | FinancialTransactionScalarFieldEnum[]
  }

  /**
   * FinancialTransaction findMany
   */
  export type FinancialTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * Filter, which FinancialTransactions to fetch.
     */
    where?: FinancialTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialTransactions to fetch.
     */
    orderBy?: FinancialTransactionOrderByWithRelationInput | FinancialTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialTransactions.
     */
    cursor?: FinancialTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialTransactions.
     */
    skip?: number
    distinct?: FinancialTransactionScalarFieldEnum | FinancialTransactionScalarFieldEnum[]
  }

  /**
   * FinancialTransaction create
   */
  export type FinancialTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a FinancialTransaction.
     */
    data: XOR<FinancialTransactionCreateInput, FinancialTransactionUncheckedCreateInput>
  }

  /**
   * FinancialTransaction createMany
   */
  export type FinancialTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialTransactions.
     */
    data: FinancialTransactionCreateManyInput | FinancialTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancialTransaction createManyAndReturn
   */
  export type FinancialTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FinancialTransactions.
     */
    data: FinancialTransactionCreateManyInput | FinancialTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialTransaction update
   */
  export type FinancialTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a FinancialTransaction.
     */
    data: XOR<FinancialTransactionUpdateInput, FinancialTransactionUncheckedUpdateInput>
    /**
     * Choose, which FinancialTransaction to update.
     */
    where: FinancialTransactionWhereUniqueInput
  }

  /**
   * FinancialTransaction updateMany
   */
  export type FinancialTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialTransactions.
     */
    data: XOR<FinancialTransactionUpdateManyMutationInput, FinancialTransactionUncheckedUpdateManyInput>
    /**
     * Filter which FinancialTransactions to update
     */
    where?: FinancialTransactionWhereInput
  }

  /**
   * FinancialTransaction upsert
   */
  export type FinancialTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the FinancialTransaction to update in case it exists.
     */
    where: FinancialTransactionWhereUniqueInput
    /**
     * In case the FinancialTransaction found by the `where` argument doesn't exist, create a new FinancialTransaction with this data.
     */
    create: XOR<FinancialTransactionCreateInput, FinancialTransactionUncheckedCreateInput>
    /**
     * In case the FinancialTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialTransactionUpdateInput, FinancialTransactionUncheckedUpdateInput>
  }

  /**
   * FinancialTransaction delete
   */
  export type FinancialTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    /**
     * Filter which FinancialTransaction to delete.
     */
    where: FinancialTransactionWhereUniqueInput
  }

  /**
   * FinancialTransaction deleteMany
   */
  export type FinancialTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialTransactions to delete
     */
    where?: FinancialTransactionWhereInput
  }

  /**
   * FinancialTransaction.budget
   */
  export type FinancialTransaction$budgetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    where?: BudgetWhereInput
  }

  /**
   * FinancialTransaction without action
   */
  export type FinancialTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Budget
   */

  export type AggregateBudget = {
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  export type BudgetAvgAggregateOutputType = {
    totalAmount: number | null
    spentAmount: number | null
    alertThreshold: number | null
  }

  export type BudgetSumAggregateOutputType = {
    totalAmount: number | null
    spentAmount: number | null
    alertThreshold: number | null
  }

  export type BudgetMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    name: string | null
    description: string | null
    totalAmount: number | null
    spentAmount: number | null
    period: $Enums.BudgetPeriod | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    alertThreshold: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    name: string | null
    description: string | null
    totalAmount: number | null
    spentAmount: number | null
    period: $Enums.BudgetPeriod | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    alertThreshold: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetCountAggregateOutputType = {
    id: number
    profileId: number
    name: number
    description: number
    totalAmount: number
    spentAmount: number
    period: number
    startDate: number
    endDate: number
    categories: number
    isActive: number
    alertThreshold: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BudgetAvgAggregateInputType = {
    totalAmount?: true
    spentAmount?: true
    alertThreshold?: true
  }

  export type BudgetSumAggregateInputType = {
    totalAmount?: true
    spentAmount?: true
    alertThreshold?: true
  }

  export type BudgetMinAggregateInputType = {
    id?: true
    profileId?: true
    name?: true
    description?: true
    totalAmount?: true
    spentAmount?: true
    period?: true
    startDate?: true
    endDate?: true
    isActive?: true
    alertThreshold?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetMaxAggregateInputType = {
    id?: true
    profileId?: true
    name?: true
    description?: true
    totalAmount?: true
    spentAmount?: true
    period?: true
    startDate?: true
    endDate?: true
    isActive?: true
    alertThreshold?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetCountAggregateInputType = {
    id?: true
    profileId?: true
    name?: true
    description?: true
    totalAmount?: true
    spentAmount?: true
    period?: true
    startDate?: true
    endDate?: true
    categories?: true
    isActive?: true
    alertThreshold?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BudgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budget to aggregate.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Budgets
    **/
    _count?: true | BudgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetMaxAggregateInputType
  }

  export type GetBudgetAggregateType<T extends BudgetAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget[P]>
      : GetScalarType<T[P], AggregateBudget[P]>
  }




  export type BudgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithAggregationInput | BudgetOrderByWithAggregationInput[]
    by: BudgetScalarFieldEnum[] | BudgetScalarFieldEnum
    having?: BudgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetCountAggregateInputType | true
    _avg?: BudgetAvgAggregateInputType
    _sum?: BudgetSumAggregateInputType
    _min?: BudgetMinAggregateInputType
    _max?: BudgetMaxAggregateInputType
  }

  export type BudgetGroupByOutputType = {
    id: string
    profileId: string
    name: string
    description: string | null
    totalAmount: number
    spentAmount: number
    period: $Enums.BudgetPeriod
    startDate: Date
    endDate: Date | null
    categories: JsonValue
    isActive: boolean
    alertThreshold: number
    createdAt: Date
    updatedAt: Date
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  type GetBudgetGroupByPayload<T extends BudgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetGroupByOutputType[P]>
        }
      >
    >


  export type BudgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    name?: boolean
    description?: boolean
    totalAmount?: boolean
    spentAmount?: boolean
    period?: boolean
    startDate?: boolean
    endDate?: boolean
    categories?: boolean
    isActive?: boolean
    alertThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
    transactions?: boolean | Budget$transactionsArgs<ExtArgs>
    _count?: boolean | BudgetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    name?: boolean
    description?: boolean
    totalAmount?: boolean
    spentAmount?: boolean
    period?: boolean
    startDate?: boolean
    endDate?: boolean
    categories?: boolean
    isActive?: boolean
    alertThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectScalar = {
    id?: boolean
    profileId?: boolean
    name?: boolean
    description?: boolean
    totalAmount?: boolean
    spentAmount?: boolean
    period?: boolean
    startDate?: boolean
    endDate?: boolean
    categories?: boolean
    isActive?: boolean
    alertThreshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BudgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
    transactions?: boolean | Budget$transactionsArgs<ExtArgs>
    _count?: boolean | BudgetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | LifeOSProfileDefaultArgs<ExtArgs>
  }

  export type $BudgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Budget"
    objects: {
      profile: Prisma.$LifeOSProfilePayload<ExtArgs>
      transactions: Prisma.$FinancialTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      name: string
      description: string | null
      totalAmount: number
      spentAmount: number
      period: $Enums.BudgetPeriod
      startDate: Date
      endDate: Date | null
      categories: Prisma.JsonValue
      isActive: boolean
      alertThreshold: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["budget"]>
    composites: {}
  }

  type BudgetGetPayload<S extends boolean | null | undefined | BudgetDefaultArgs> = $Result.GetResult<Prisma.$BudgetPayload, S>

  type BudgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BudgetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BudgetCountAggregateInputType | true
    }

  export interface BudgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Budget'], meta: { name: 'Budget' } }
    /**
     * Find zero or one Budget that matches the filter.
     * @param {BudgetFindUniqueArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetFindUniqueArgs>(args: SelectSubset<T, BudgetFindUniqueArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Budget that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BudgetFindUniqueOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Budget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetFindFirstArgs>(args?: SelectSubset<T, BudgetFindFirstArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Budget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Budgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budgets
     * const budgets = await prisma.budget.findMany()
     * 
     * // Get first 10 Budgets
     * const budgets = await prisma.budget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetWithIdOnly = await prisma.budget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetFindManyArgs>(args?: SelectSubset<T, BudgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Budget.
     * @param {BudgetCreateArgs} args - Arguments to create a Budget.
     * @example
     * // Create one Budget
     * const Budget = await prisma.budget.create({
     *   data: {
     *     // ... data to create a Budget
     *   }
     * })
     * 
     */
    create<T extends BudgetCreateArgs>(args: SelectSubset<T, BudgetCreateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Budgets.
     * @param {BudgetCreateManyArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetCreateManyArgs>(args?: SelectSubset<T, BudgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Budgets and returns the data saved in the database.
     * @param {BudgetCreateManyAndReturnArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Budget.
     * @param {BudgetDeleteArgs} args - Arguments to delete one Budget.
     * @example
     * // Delete one Budget
     * const Budget = await prisma.budget.delete({
     *   where: {
     *     // ... filter to delete one Budget
     *   }
     * })
     * 
     */
    delete<T extends BudgetDeleteArgs>(args: SelectSubset<T, BudgetDeleteArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Budget.
     * @param {BudgetUpdateArgs} args - Arguments to update one Budget.
     * @example
     * // Update one Budget
     * const budget = await prisma.budget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetUpdateArgs>(args: SelectSubset<T, BudgetUpdateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Budgets.
     * @param {BudgetDeleteManyArgs} args - Arguments to filter Budgets to delete.
     * @example
     * // Delete a few Budgets
     * const { count } = await prisma.budget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetDeleteManyArgs>(args?: SelectSubset<T, BudgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetUpdateManyArgs>(args: SelectSubset<T, BudgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Budget.
     * @param {BudgetUpsertArgs} args - Arguments to update or create a Budget.
     * @example
     * // Update or create a Budget
     * const budget = await prisma.budget.upsert({
     *   create: {
     *     // ... data to create a Budget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget we want to update
     *   }
     * })
     */
    upsert<T extends BudgetUpsertArgs>(args: SelectSubset<T, BudgetUpsertArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCountArgs} args - Arguments to filter Budgets to count.
     * @example
     * // Count the number of Budgets
     * const count = await prisma.budget.count({
     *   where: {
     *     // ... the filter for the Budgets we want to count
     *   }
     * })
    **/
    count<T extends BudgetCountArgs>(
      args?: Subset<T, BudgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetAggregateArgs>(args: Subset<T, BudgetAggregateArgs>): Prisma.PrismaPromise<GetBudgetAggregateType<T>>

    /**
     * Group by Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetGroupByArgs['orderBy'] }
        : { orderBy?: BudgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Budget model
   */
  readonly fields: BudgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Budget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends LifeOSProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LifeOSProfileDefaultArgs<ExtArgs>>): Prisma__LifeOSProfileClient<$Result.GetResult<Prisma.$LifeOSProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends Budget$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Budget$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Budget model
   */ 
  interface BudgetFieldRefs {
    readonly id: FieldRef<"Budget", 'String'>
    readonly profileId: FieldRef<"Budget", 'String'>
    readonly name: FieldRef<"Budget", 'String'>
    readonly description: FieldRef<"Budget", 'String'>
    readonly totalAmount: FieldRef<"Budget", 'Float'>
    readonly spentAmount: FieldRef<"Budget", 'Float'>
    readonly period: FieldRef<"Budget", 'BudgetPeriod'>
    readonly startDate: FieldRef<"Budget", 'DateTime'>
    readonly endDate: FieldRef<"Budget", 'DateTime'>
    readonly categories: FieldRef<"Budget", 'Json'>
    readonly isActive: FieldRef<"Budget", 'Boolean'>
    readonly alertThreshold: FieldRef<"Budget", 'Float'>
    readonly createdAt: FieldRef<"Budget", 'DateTime'>
    readonly updatedAt: FieldRef<"Budget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Budget findUnique
   */
  export type BudgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findUniqueOrThrow
   */
  export type BudgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findFirst
   */
  export type BudgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findFirstOrThrow
   */
  export type BudgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findMany
   */
  export type BudgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budgets to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget create
   */
  export type BudgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to create a Budget.
     */
    data: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
  }

  /**
   * Budget createMany
   */
  export type BudgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Budget createManyAndReturn
   */
  export type BudgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget update
   */
  export type BudgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to update a Budget.
     */
    data: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
    /**
     * Choose, which Budget to update.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget updateMany
   */
  export type BudgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
  }

  /**
   * Budget upsert
   */
  export type BudgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The filter to search for the Budget to update in case it exists.
     */
    where: BudgetWhereUniqueInput
    /**
     * In case the Budget found by the `where` argument doesn't exist, create a new Budget with this data.
     */
    create: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
    /**
     * In case the Budget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
  }

  /**
   * Budget delete
   */
  export type BudgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter which Budget to delete.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget deleteMany
   */
  export type BudgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budgets to delete
     */
    where?: BudgetWhereInput
  }

  /**
   * Budget.transactions
   */
  export type Budget$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialTransaction
     */
    select?: FinancialTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialTransactionInclude<ExtArgs> | null
    where?: FinancialTransactionWhereInput
    orderBy?: FinancialTransactionOrderByWithRelationInput | FinancialTransactionOrderByWithRelationInput[]
    cursor?: FinancialTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialTransactionScalarFieldEnum | FinancialTransactionScalarFieldEnum[]
  }

  /**
   * Budget without action
   */
  export type BudgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    avatar: 'avatar',
    bio: 'bio',
    location: 'location',
    website: 'website',
    emailVerified: 'emailVerified',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    skills: 'skills',
    interests: 'interests'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    content: 'content',
    status: 'status',
    visibility: 'visibility',
    category: 'category',
    tags: 'tags',
    location: 'location',
    region: 'region',
    coordinates: 'coordinates',
    coverImage: 'coverImage',
    images: 'images',
    documents: 'documents',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectMemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    projectId: 'projectId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectMemberScalarFieldEnum = (typeof ProjectMemberScalarFieldEnum)[keyof typeof ProjectMemberScalarFieldEnum]


  export const StoryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    excerpt: 'excerpt',
    status: 'status',
    visibility: 'visibility',
    category: 'category',
    tags: 'tags',
    coverImage: 'coverImage',
    images: 'images',
    slug: 'slug',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    viewCount: 'viewCount',
    shareCount: 'shareCount',
    authorId: 'authorId',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    publishedAt: 'publishedAt'
  };

  export type StoryScalarFieldEnum = (typeof StoryScalarFieldEnum)[keyof typeof StoryScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    status: 'status',
    authorId: 'authorId',
    storyId: 'storyId',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const OpportunityScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    content: 'content',
    type: 'type',
    status: 'status',
    category: 'category',
    tags: 'tags',
    skills: 'skills',
    timeCommitment: 'timeCommitment',
    location: 'location',
    remote: 'remote',
    isPaid: 'isPaid',
    compensation: 'compensation',
    deadline: 'deadline',
    startDate: 'startDate',
    duration: 'duration',
    coverImage: 'coverImage',
    images: 'images',
    projectId: 'projectId',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    applicationUrl: 'applicationUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OpportunityScalarFieldEnum = (typeof OpportunityScalarFieldEnum)[keyof typeof OpportunityScalarFieldEnum]


  export const OpportunityApplicationScalarFieldEnum: {
    id: 'id',
    message: 'message',
    resume: 'resume',
    portfolio: 'portfolio',
    status: 'status',
    userId: 'userId',
    opportunityId: 'opportunityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OpportunityApplicationScalarFieldEnum = (typeof OpportunityApplicationScalarFieldEnum)[keyof typeof OpportunityApplicationScalarFieldEnum]


  export const PageViewScalarFieldEnum: {
    id: 'id',
    path: 'path',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    referer: 'referer',
    sessionId: 'sessionId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type PageViewScalarFieldEnum = (typeof PageViewScalarFieldEnum)[keyof typeof PageViewScalarFieldEnum]


  export const SearchQueryScalarFieldEnum: {
    id: 'id',
    query: 'query',
    results: 'results',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type SearchQueryScalarFieldEnum = (typeof SearchQueryScalarFieldEnum)[keyof typeof SearchQueryScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    value: 'value',
    updatedAt: 'updatedAt'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    originalName: 'originalName',
    mimeType: 'mimeType',
    size: 'size',
    url: 'url',
    alt: 'alt',
    caption: 'caption',
    width: 'width',
    height: 'height',
    duration: 'duration',
    uploadedById: 'uploadedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const LifeOSProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    timezone: 'timezone',
    locale: 'locale',
    currency: 'currency',
    themePreference: 'themePreference',
    notificationSettings: 'notificationSettings',
    privacySettings: 'privacySettings',
    extractiveSystemsTargeting: 'extractiveSystemsTargeting',
    communityControlEnabled: 'communityControlEnabled',
    dataResidencyPreference: 'dataResidencyPreference',
    onboardingCompleted: 'onboardingCompleted',
    lastActiveAt: 'lastActiveAt',
    activationDate: 'activationDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LifeOSProfileScalarFieldEnum = (typeof LifeOSProfileScalarFieldEnum)[keyof typeof LifeOSProfileScalarFieldEnum]


  export const HabitScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    name: 'name',
    description: 'description',
    category: 'category',
    frequency: 'frequency',
    targetValue: 'targetValue',
    unit: 'unit',
    color: 'color',
    icon: 'icon',
    reminder: 'reminder',
    isActive: 'isActive',
    currentStreak: 'currentStreak',
    longestStreak: 'longestStreak',
    lastCompletedDate: 'lastCompletedDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HabitScalarFieldEnum = (typeof HabitScalarFieldEnum)[keyof typeof HabitScalarFieldEnum]


  export const HabitCompletionScalarFieldEnum: {
    id: 'id',
    habitId: 'habitId',
    completedAt: 'completedAt',
    value: 'value',
    notes: 'notes',
    satisfaction: 'satisfaction',
    difficulty: 'difficulty'
  };

  export type HabitCompletionScalarFieldEnum = (typeof HabitCompletionScalarFieldEnum)[keyof typeof HabitCompletionScalarFieldEnum]


  export const GoalScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    title: 'title',
    description: 'description',
    category: 'category',
    targetValue: 'targetValue',
    currentValue: 'currentValue',
    unit: 'unit',
    startDate: 'startDate',
    targetDate: 'targetDate',
    completedAt: 'completedAt',
    status: 'status',
    priority: 'priority',
    progress: 'progress',
    motivation: 'motivation',
    visualisation: 'visualisation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GoalScalarFieldEnum = (typeof GoalScalarFieldEnum)[keyof typeof GoalScalarFieldEnum]


  export const GoalMilestoneScalarFieldEnum: {
    id: 'id',
    goalId: 'goalId',
    title: 'title',
    description: 'description',
    targetDate: 'targetDate',
    completedAt: 'completedAt',
    targetValue: 'targetValue',
    currentValue: 'currentValue',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GoalMilestoneScalarFieldEnum = (typeof GoalMilestoneScalarFieldEnum)[keyof typeof GoalMilestoneScalarFieldEnum]


  export const GoalUpdateScalarFieldEnum: {
    id: 'id',
    goalId: 'goalId',
    content: 'content',
    value: 'value',
    createdAt: 'createdAt'
  };

  export type GoalUpdateScalarFieldEnum = (typeof GoalUpdateScalarFieldEnum)[keyof typeof GoalUpdateScalarFieldEnum]


  export const MeditationSessionScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    duration: 'duration',
    technique: 'technique',
    guidedSession: 'guidedSession',
    guideUrl: 'guideUrl',
    rating: 'rating',
    notes: 'notes',
    mood: 'mood',
    location: 'location',
    distractions: 'distractions',
    createdAt: 'createdAt'
  };

  export type MeditationSessionScalarFieldEnum = (typeof MeditationSessionScalarFieldEnum)[keyof typeof MeditationSessionScalarFieldEnum]


  export const MoodEntryScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    mood: 'mood',
    intensity: 'intensity',
    emotions: 'emotions',
    activities: 'activities',
    location: 'location',
    weather: 'weather',
    notes: 'notes',
    triggers: 'triggers',
    gratitude: 'gratitude',
    recordedAt: 'recordedAt',
    createdAt: 'createdAt'
  };

  export type MoodEntryScalarFieldEnum = (typeof MoodEntryScalarFieldEnum)[keyof typeof MoodEntryScalarFieldEnum]


  export const JournalScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    title: 'title',
    content: 'content',
    mood: 'mood',
    tags: 'tags',
    isPrivate: 'isPrivate',
    template: 'template',
    prompts: 'prompts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JournalScalarFieldEnum = (typeof JournalScalarFieldEnum)[keyof typeof JournalScalarFieldEnum]


  export const CalendarEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    isAllDay: 'isAllDay',
    location: 'location',
    url: 'url',
    category: 'category',
    color: 'color',
    isRecurring: 'isRecurring',
    recurrenceRule: 'recurrenceRule',
    parentEventId: 'parentEventId',
    eventType: 'eventType',
    visibility: 'visibility',
    projectId: 'projectId',
    communityEvent: 'communityEvent',
    reminders: 'reminders',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CalendarEventScalarFieldEnum = (typeof CalendarEventScalarFieldEnum)[keyof typeof CalendarEventScalarFieldEnum]


  export const EventAttendeeScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userId: 'userId',
    status: 'status',
    response: 'response',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventAttendeeScalarFieldEnum = (typeof EventAttendeeScalarFieldEnum)[keyof typeof EventAttendeeScalarFieldEnum]


  export const FinancialTransactionScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    amount: 'amount',
    currency: 'currency',
    description: 'description',
    notes: 'notes',
    type: 'type',
    category: 'category',
    subcategory: 'subcategory',
    merchant: 'merchant',
    location: 'location',
    paymentMethod: 'paymentMethod',
    budgetId: 'budgetId',
    tags: 'tags',
    gstAmount: 'gstAmount',
    taxCategory: 'taxCategory',
    transactionDate: 'transactionDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FinancialTransactionScalarFieldEnum = (typeof FinancialTransactionScalarFieldEnum)[keyof typeof FinancialTransactionScalarFieldEnum]


  export const BudgetScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    name: 'name',
    description: 'description',
    totalAmount: 'totalAmount',
    spentAmount: 'spentAmount',
    period: 'period',
    startDate: 'startDate',
    endDate: 'endDate',
    categories: 'categories',
    isActive: 'isActive',
    alertThreshold: 'alertThreshold',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BudgetScalarFieldEnum = (typeof BudgetScalarFieldEnum)[keyof typeof BudgetScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'Visibility'
   */
  export type EnumVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Visibility'>
    


  /**
   * Reference to a field of type 'Visibility[]'
   */
  export type ListEnumVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Visibility[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'ProjectRole'
   */
  export type EnumProjectRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectRole'>
    


  /**
   * Reference to a field of type 'ProjectRole[]'
   */
  export type ListEnumProjectRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectRole[]'>
    


  /**
   * Reference to a field of type 'StoryStatus'
   */
  export type EnumStoryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoryStatus'>
    


  /**
   * Reference to a field of type 'StoryStatus[]'
   */
  export type ListEnumStoryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoryStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'CommentStatus'
   */
  export type EnumCommentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommentStatus'>
    


  /**
   * Reference to a field of type 'CommentStatus[]'
   */
  export type ListEnumCommentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommentStatus[]'>
    


  /**
   * Reference to a field of type 'OpportunityType'
   */
  export type EnumOpportunityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OpportunityType'>
    


  /**
   * Reference to a field of type 'OpportunityType[]'
   */
  export type ListEnumOpportunityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OpportunityType[]'>
    


  /**
   * Reference to a field of type 'OpportunityStatus'
   */
  export type EnumOpportunityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OpportunityStatus'>
    


  /**
   * Reference to a field of type 'OpportunityStatus[]'
   */
  export type ListEnumOpportunityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OpportunityStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ApplicationStatus'
   */
  export type EnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus'>
    


  /**
   * Reference to a field of type 'ApplicationStatus[]'
   */
  export type ListEnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus[]'>
    


  /**
   * Reference to a field of type 'HabitFrequency'
   */
  export type EnumHabitFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HabitFrequency'>
    


  /**
   * Reference to a field of type 'HabitFrequency[]'
   */
  export type ListEnumHabitFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HabitFrequency[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'GoalStatus'
   */
  export type EnumGoalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalStatus'>
    


  /**
   * Reference to a field of type 'GoalStatus[]'
   */
  export type ListEnumGoalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalStatus[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'MilestoneStatus'
   */
  export type EnumMilestoneStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MilestoneStatus'>
    


  /**
   * Reference to a field of type 'MilestoneStatus[]'
   */
  export type ListEnumMilestoneStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MilestoneStatus[]'>
    


  /**
   * Reference to a field of type 'EventType'
   */
  export type EnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType'>
    


  /**
   * Reference to a field of type 'EventType[]'
   */
  export type ListEnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType[]'>
    


  /**
   * Reference to a field of type 'AttendeeStatus'
   */
  export type EnumAttendeeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendeeStatus'>
    


  /**
   * Reference to a field of type 'AttendeeStatus[]'
   */
  export type ListEnumAttendeeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendeeStatus[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'BudgetPeriod'
   */
  export type EnumBudgetPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetPeriod'>
    


  /**
   * Reference to a field of type 'BudgetPeriod[]'
   */
  export type ListEnumBudgetPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetPeriod[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    website?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    skills?: StringNullableListFilter<"User">
    interests?: StringNullableListFilter<"User">
    stories?: StoryListRelationFilter
    projects?: ProjectMemberListRelationFilter
    comments?: CommentListRelationFilter
    opportunities?: OpportunityApplicationListRelationFilter
    lifeOSProfile?: XOR<LifeOSProfileNullableRelationFilter, LifeOSProfileWhereInput> | null
    calendarEvents?: CalendarEventListRelationFilter
    eventAttendance?: EventAttendeeListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    skills?: SortOrder
    interests?: SortOrder
    stories?: StoryOrderByRelationAggregateInput
    projects?: ProjectMemberOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    opportunities?: OpportunityApplicationOrderByRelationAggregateInput
    lifeOSProfile?: LifeOSProfileOrderByWithRelationInput
    calendarEvents?: CalendarEventOrderByRelationAggregateInput
    eventAttendance?: EventAttendeeOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    website?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    skills?: StringNullableListFilter<"User">
    interests?: StringNullableListFilter<"User">
    stories?: StoryListRelationFilter
    projects?: ProjectMemberListRelationFilter
    comments?: CommentListRelationFilter
    opportunities?: OpportunityApplicationListRelationFilter
    lifeOSProfile?: XOR<LifeOSProfileNullableRelationFilter, LifeOSProfileWhereInput> | null
    calendarEvents?: CalendarEventListRelationFilter
    eventAttendance?: EventAttendeeListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    skills?: SortOrder
    interests?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    location?: StringNullableWithAggregatesFilter<"User"> | string | null
    website?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    skills?: StringNullableListFilter<"User">
    interests?: StringNullableListFilter<"User">
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    content?: StringNullableFilter<"Project"> | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    visibility?: EnumVisibilityFilter<"Project"> | $Enums.Visibility
    category?: StringNullableFilter<"Project"> | string | null
    tags?: StringNullableListFilter<"Project">
    location?: StringNullableFilter<"Project"> | string | null
    region?: StringNullableFilter<"Project"> | string | null
    coordinates?: JsonNullableFilter<"Project">
    coverImage?: StringNullableFilter<"Project"> | string | null
    images?: StringNullableListFilter<"Project">
    documents?: StringNullableListFilter<"Project">
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    members?: ProjectMemberListRelationFilter
    stories?: StoryListRelationFilter
    opportunities?: OpportunityListRelationFilter
    calendarEvents?: CalendarEventListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrderInput | SortOrder
    status?: SortOrder
    visibility?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    location?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    coordinates?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    images?: SortOrder
    documents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    members?: ProjectMemberOrderByRelationAggregateInput
    stories?: StoryOrderByRelationAggregateInput
    opportunities?: OpportunityOrderByRelationAggregateInput
    calendarEvents?: CalendarEventOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    content?: StringNullableFilter<"Project"> | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    visibility?: EnumVisibilityFilter<"Project"> | $Enums.Visibility
    category?: StringNullableFilter<"Project"> | string | null
    tags?: StringNullableListFilter<"Project">
    location?: StringNullableFilter<"Project"> | string | null
    region?: StringNullableFilter<"Project"> | string | null
    coordinates?: JsonNullableFilter<"Project">
    coverImage?: StringNullableFilter<"Project"> | string | null
    images?: StringNullableListFilter<"Project">
    documents?: StringNullableListFilter<"Project">
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    members?: ProjectMemberListRelationFilter
    stories?: StoryListRelationFilter
    opportunities?: OpportunityListRelationFilter
    calendarEvents?: CalendarEventListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrderInput | SortOrder
    status?: SortOrder
    visibility?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    location?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    coordinates?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    images?: SortOrder
    documents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    title?: StringWithAggregatesFilter<"Project"> | string
    description?: StringWithAggregatesFilter<"Project"> | string
    content?: StringNullableWithAggregatesFilter<"Project"> | string | null
    status?: EnumProjectStatusWithAggregatesFilter<"Project"> | $Enums.ProjectStatus
    visibility?: EnumVisibilityWithAggregatesFilter<"Project"> | $Enums.Visibility
    category?: StringNullableWithAggregatesFilter<"Project"> | string | null
    tags?: StringNullableListFilter<"Project">
    location?: StringNullableWithAggregatesFilter<"Project"> | string | null
    region?: StringNullableWithAggregatesFilter<"Project"> | string | null
    coordinates?: JsonNullableWithAggregatesFilter<"Project">
    coverImage?: StringNullableWithAggregatesFilter<"Project"> | string | null
    images?: StringNullableListFilter<"Project">
    documents?: StringNullableListFilter<"Project">
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    startDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
  }

  export type ProjectMemberWhereInput = {
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    id?: StringFilter<"ProjectMember"> | string
    userId?: StringFilter<"ProjectMember"> | string
    projectId?: StringFilter<"ProjectMember"> | string
    role?: EnumProjectRoleFilter<"ProjectMember"> | $Enums.ProjectRole
    createdAt?: DateTimeFilter<"ProjectMember"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ProjectMemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_projectId?: ProjectMemberUserIdProjectIdCompoundUniqueInput
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    userId?: StringFilter<"ProjectMember"> | string
    projectId?: StringFilter<"ProjectMember"> | string
    role?: EnumProjectRoleFilter<"ProjectMember"> | $Enums.ProjectRole
    createdAt?: DateTimeFilter<"ProjectMember"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id" | "userId_projectId">

  export type ProjectMemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectMemberCountOrderByAggregateInput
    _max?: ProjectMemberMaxOrderByAggregateInput
    _min?: ProjectMemberMinOrderByAggregateInput
  }

  export type ProjectMemberScalarWhereWithAggregatesInput = {
    AND?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    OR?: ProjectMemberScalarWhereWithAggregatesInput[]
    NOT?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectMember"> | string
    userId?: StringWithAggregatesFilter<"ProjectMember"> | string
    projectId?: StringWithAggregatesFilter<"ProjectMember"> | string
    role?: EnumProjectRoleWithAggregatesFilter<"ProjectMember"> | $Enums.ProjectRole
    createdAt?: DateTimeWithAggregatesFilter<"ProjectMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectMember"> | Date | string
  }

  export type StoryWhereInput = {
    AND?: StoryWhereInput | StoryWhereInput[]
    OR?: StoryWhereInput[]
    NOT?: StoryWhereInput | StoryWhereInput[]
    id?: StringFilter<"Story"> | string
    title?: StringFilter<"Story"> | string
    content?: StringFilter<"Story"> | string
    excerpt?: StringNullableFilter<"Story"> | string | null
    status?: EnumStoryStatusFilter<"Story"> | $Enums.StoryStatus
    visibility?: EnumVisibilityFilter<"Story"> | $Enums.Visibility
    category?: StringNullableFilter<"Story"> | string | null
    tags?: StringNullableListFilter<"Story">
    coverImage?: StringNullableFilter<"Story"> | string | null
    images?: StringNullableListFilter<"Story">
    slug?: StringFilter<"Story"> | string
    metaTitle?: StringNullableFilter<"Story"> | string | null
    metaDescription?: StringNullableFilter<"Story"> | string | null
    viewCount?: IntFilter<"Story"> | number
    shareCount?: IntFilter<"Story"> | number
    authorId?: StringFilter<"Story"> | string
    projectId?: StringNullableFilter<"Story"> | string | null
    createdAt?: DateTimeFilter<"Story"> | Date | string
    updatedAt?: DateTimeFilter<"Story"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Story"> | Date | string | null
    author?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    comments?: CommentListRelationFilter
  }

  export type StoryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    status?: SortOrder
    visibility?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    coverImage?: SortOrderInput | SortOrder
    images?: SortOrder
    slug?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    author?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type StoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: StoryWhereInput | StoryWhereInput[]
    OR?: StoryWhereInput[]
    NOT?: StoryWhereInput | StoryWhereInput[]
    title?: StringFilter<"Story"> | string
    content?: StringFilter<"Story"> | string
    excerpt?: StringNullableFilter<"Story"> | string | null
    status?: EnumStoryStatusFilter<"Story"> | $Enums.StoryStatus
    visibility?: EnumVisibilityFilter<"Story"> | $Enums.Visibility
    category?: StringNullableFilter<"Story"> | string | null
    tags?: StringNullableListFilter<"Story">
    coverImage?: StringNullableFilter<"Story"> | string | null
    images?: StringNullableListFilter<"Story">
    metaTitle?: StringNullableFilter<"Story"> | string | null
    metaDescription?: StringNullableFilter<"Story"> | string | null
    viewCount?: IntFilter<"Story"> | number
    shareCount?: IntFilter<"Story"> | number
    authorId?: StringFilter<"Story"> | string
    projectId?: StringNullableFilter<"Story"> | string | null
    createdAt?: DateTimeFilter<"Story"> | Date | string
    updatedAt?: DateTimeFilter<"Story"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Story"> | Date | string | null
    author?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    comments?: CommentListRelationFilter
  }, "id" | "slug">

  export type StoryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    status?: SortOrder
    visibility?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    coverImage?: SortOrderInput | SortOrder
    images?: SortOrder
    slug?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    _count?: StoryCountOrderByAggregateInput
    _avg?: StoryAvgOrderByAggregateInput
    _max?: StoryMaxOrderByAggregateInput
    _min?: StoryMinOrderByAggregateInput
    _sum?: StorySumOrderByAggregateInput
  }

  export type StoryScalarWhereWithAggregatesInput = {
    AND?: StoryScalarWhereWithAggregatesInput | StoryScalarWhereWithAggregatesInput[]
    OR?: StoryScalarWhereWithAggregatesInput[]
    NOT?: StoryScalarWhereWithAggregatesInput | StoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Story"> | string
    title?: StringWithAggregatesFilter<"Story"> | string
    content?: StringWithAggregatesFilter<"Story"> | string
    excerpt?: StringNullableWithAggregatesFilter<"Story"> | string | null
    status?: EnumStoryStatusWithAggregatesFilter<"Story"> | $Enums.StoryStatus
    visibility?: EnumVisibilityWithAggregatesFilter<"Story"> | $Enums.Visibility
    category?: StringNullableWithAggregatesFilter<"Story"> | string | null
    tags?: StringNullableListFilter<"Story">
    coverImage?: StringNullableWithAggregatesFilter<"Story"> | string | null
    images?: StringNullableListFilter<"Story">
    slug?: StringWithAggregatesFilter<"Story"> | string
    metaTitle?: StringNullableWithAggregatesFilter<"Story"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Story"> | string | null
    viewCount?: IntWithAggregatesFilter<"Story"> | number
    shareCount?: IntWithAggregatesFilter<"Story"> | number
    authorId?: StringWithAggregatesFilter<"Story"> | string
    projectId?: StringNullableWithAggregatesFilter<"Story"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Story"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Story"> | Date | string
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Story"> | Date | string | null
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    status?: EnumCommentStatusFilter<"Comment"> | $Enums.CommentStatus
    authorId?: StringFilter<"Comment"> | string
    storyId?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    story?: XOR<StoryRelationFilter, StoryWhereInput>
    parent?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    storyId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    story?: StoryOrderByWithRelationInput
    parent?: CommentOrderByWithRelationInput
    replies?: CommentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringFilter<"Comment"> | string
    status?: EnumCommentStatusFilter<"Comment"> | $Enums.CommentStatus
    authorId?: StringFilter<"Comment"> | string
    storyId?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    story?: XOR<StoryRelationFilter, StoryWhereInput>
    parent?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    storyId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    status?: EnumCommentStatusWithAggregatesFilter<"Comment"> | $Enums.CommentStatus
    authorId?: StringWithAggregatesFilter<"Comment"> | string
    storyId?: StringWithAggregatesFilter<"Comment"> | string
    parentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type OpportunityWhereInput = {
    AND?: OpportunityWhereInput | OpportunityWhereInput[]
    OR?: OpportunityWhereInput[]
    NOT?: OpportunityWhereInput | OpportunityWhereInput[]
    id?: StringFilter<"Opportunity"> | string
    title?: StringFilter<"Opportunity"> | string
    description?: StringFilter<"Opportunity"> | string
    content?: StringNullableFilter<"Opportunity"> | string | null
    type?: EnumOpportunityTypeFilter<"Opportunity"> | $Enums.OpportunityType
    status?: EnumOpportunityStatusFilter<"Opportunity"> | $Enums.OpportunityStatus
    category?: StringNullableFilter<"Opportunity"> | string | null
    tags?: StringNullableListFilter<"Opportunity">
    skills?: StringNullableListFilter<"Opportunity">
    timeCommitment?: StringNullableFilter<"Opportunity"> | string | null
    location?: StringNullableFilter<"Opportunity"> | string | null
    remote?: BoolFilter<"Opportunity"> | boolean
    isPaid?: BoolFilter<"Opportunity"> | boolean
    compensation?: StringNullableFilter<"Opportunity"> | string | null
    deadline?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    startDate?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    duration?: StringNullableFilter<"Opportunity"> | string | null
    coverImage?: StringNullableFilter<"Opportunity"> | string | null
    images?: StringNullableListFilter<"Opportunity">
    projectId?: StringNullableFilter<"Opportunity"> | string | null
    contactEmail?: StringNullableFilter<"Opportunity"> | string | null
    contactPhone?: StringNullableFilter<"Opportunity"> | string | null
    applicationUrl?: StringNullableFilter<"Opportunity"> | string | null
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeFilter<"Opportunity"> | Date | string
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    applications?: OpportunityApplicationListRelationFilter
  }

  export type OpportunityOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    skills?: SortOrder
    timeCommitment?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    remote?: SortOrder
    isPaid?: SortOrder
    compensation?: SortOrderInput | SortOrder
    deadline?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    images?: SortOrder
    projectId?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    applicationUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    applications?: OpportunityApplicationOrderByRelationAggregateInput
  }

  export type OpportunityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OpportunityWhereInput | OpportunityWhereInput[]
    OR?: OpportunityWhereInput[]
    NOT?: OpportunityWhereInput | OpportunityWhereInput[]
    title?: StringFilter<"Opportunity"> | string
    description?: StringFilter<"Opportunity"> | string
    content?: StringNullableFilter<"Opportunity"> | string | null
    type?: EnumOpportunityTypeFilter<"Opportunity"> | $Enums.OpportunityType
    status?: EnumOpportunityStatusFilter<"Opportunity"> | $Enums.OpportunityStatus
    category?: StringNullableFilter<"Opportunity"> | string | null
    tags?: StringNullableListFilter<"Opportunity">
    skills?: StringNullableListFilter<"Opportunity">
    timeCommitment?: StringNullableFilter<"Opportunity"> | string | null
    location?: StringNullableFilter<"Opportunity"> | string | null
    remote?: BoolFilter<"Opportunity"> | boolean
    isPaid?: BoolFilter<"Opportunity"> | boolean
    compensation?: StringNullableFilter<"Opportunity"> | string | null
    deadline?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    startDate?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    duration?: StringNullableFilter<"Opportunity"> | string | null
    coverImage?: StringNullableFilter<"Opportunity"> | string | null
    images?: StringNullableListFilter<"Opportunity">
    projectId?: StringNullableFilter<"Opportunity"> | string | null
    contactEmail?: StringNullableFilter<"Opportunity"> | string | null
    contactPhone?: StringNullableFilter<"Opportunity"> | string | null
    applicationUrl?: StringNullableFilter<"Opportunity"> | string | null
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeFilter<"Opportunity"> | Date | string
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    applications?: OpportunityApplicationListRelationFilter
  }, "id">

  export type OpportunityOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    skills?: SortOrder
    timeCommitment?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    remote?: SortOrder
    isPaid?: SortOrder
    compensation?: SortOrderInput | SortOrder
    deadline?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    images?: SortOrder
    projectId?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    applicationUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OpportunityCountOrderByAggregateInput
    _max?: OpportunityMaxOrderByAggregateInput
    _min?: OpportunityMinOrderByAggregateInput
  }

  export type OpportunityScalarWhereWithAggregatesInput = {
    AND?: OpportunityScalarWhereWithAggregatesInput | OpportunityScalarWhereWithAggregatesInput[]
    OR?: OpportunityScalarWhereWithAggregatesInput[]
    NOT?: OpportunityScalarWhereWithAggregatesInput | OpportunityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Opportunity"> | string
    title?: StringWithAggregatesFilter<"Opportunity"> | string
    description?: StringWithAggregatesFilter<"Opportunity"> | string
    content?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    type?: EnumOpportunityTypeWithAggregatesFilter<"Opportunity"> | $Enums.OpportunityType
    status?: EnumOpportunityStatusWithAggregatesFilter<"Opportunity"> | $Enums.OpportunityStatus
    category?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    tags?: StringNullableListFilter<"Opportunity">
    skills?: StringNullableListFilter<"Opportunity">
    timeCommitment?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    location?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    remote?: BoolWithAggregatesFilter<"Opportunity"> | boolean
    isPaid?: BoolWithAggregatesFilter<"Opportunity"> | boolean
    compensation?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    deadline?: DateTimeNullableWithAggregatesFilter<"Opportunity"> | Date | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Opportunity"> | Date | string | null
    duration?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    images?: StringNullableListFilter<"Opportunity">
    projectId?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    applicationUrl?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Opportunity"> | Date | string
  }

  export type OpportunityApplicationWhereInput = {
    AND?: OpportunityApplicationWhereInput | OpportunityApplicationWhereInput[]
    OR?: OpportunityApplicationWhereInput[]
    NOT?: OpportunityApplicationWhereInput | OpportunityApplicationWhereInput[]
    id?: StringFilter<"OpportunityApplication"> | string
    message?: StringFilter<"OpportunityApplication"> | string
    resume?: StringNullableFilter<"OpportunityApplication"> | string | null
    portfolio?: StringNullableFilter<"OpportunityApplication"> | string | null
    status?: EnumApplicationStatusFilter<"OpportunityApplication"> | $Enums.ApplicationStatus
    userId?: StringFilter<"OpportunityApplication"> | string
    opportunityId?: StringFilter<"OpportunityApplication"> | string
    createdAt?: DateTimeFilter<"OpportunityApplication"> | Date | string
    updatedAt?: DateTimeFilter<"OpportunityApplication"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    opportunity?: XOR<OpportunityRelationFilter, OpportunityWhereInput>
  }

  export type OpportunityApplicationOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrder
    resume?: SortOrderInput | SortOrder
    portfolio?: SortOrderInput | SortOrder
    status?: SortOrder
    userId?: SortOrder
    opportunityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    opportunity?: OpportunityOrderByWithRelationInput
  }

  export type OpportunityApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_opportunityId?: OpportunityApplicationUserIdOpportunityIdCompoundUniqueInput
    AND?: OpportunityApplicationWhereInput | OpportunityApplicationWhereInput[]
    OR?: OpportunityApplicationWhereInput[]
    NOT?: OpportunityApplicationWhereInput | OpportunityApplicationWhereInput[]
    message?: StringFilter<"OpportunityApplication"> | string
    resume?: StringNullableFilter<"OpportunityApplication"> | string | null
    portfolio?: StringNullableFilter<"OpportunityApplication"> | string | null
    status?: EnumApplicationStatusFilter<"OpportunityApplication"> | $Enums.ApplicationStatus
    userId?: StringFilter<"OpportunityApplication"> | string
    opportunityId?: StringFilter<"OpportunityApplication"> | string
    createdAt?: DateTimeFilter<"OpportunityApplication"> | Date | string
    updatedAt?: DateTimeFilter<"OpportunityApplication"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    opportunity?: XOR<OpportunityRelationFilter, OpportunityWhereInput>
  }, "id" | "userId_opportunityId">

  export type OpportunityApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrder
    resume?: SortOrderInput | SortOrder
    portfolio?: SortOrderInput | SortOrder
    status?: SortOrder
    userId?: SortOrder
    opportunityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OpportunityApplicationCountOrderByAggregateInput
    _max?: OpportunityApplicationMaxOrderByAggregateInput
    _min?: OpportunityApplicationMinOrderByAggregateInput
  }

  export type OpportunityApplicationScalarWhereWithAggregatesInput = {
    AND?: OpportunityApplicationScalarWhereWithAggregatesInput | OpportunityApplicationScalarWhereWithAggregatesInput[]
    OR?: OpportunityApplicationScalarWhereWithAggregatesInput[]
    NOT?: OpportunityApplicationScalarWhereWithAggregatesInput | OpportunityApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OpportunityApplication"> | string
    message?: StringWithAggregatesFilter<"OpportunityApplication"> | string
    resume?: StringNullableWithAggregatesFilter<"OpportunityApplication"> | string | null
    portfolio?: StringNullableWithAggregatesFilter<"OpportunityApplication"> | string | null
    status?: EnumApplicationStatusWithAggregatesFilter<"OpportunityApplication"> | $Enums.ApplicationStatus
    userId?: StringWithAggregatesFilter<"OpportunityApplication"> | string
    opportunityId?: StringWithAggregatesFilter<"OpportunityApplication"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OpportunityApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OpportunityApplication"> | Date | string
  }

  export type PageViewWhereInput = {
    AND?: PageViewWhereInput | PageViewWhereInput[]
    OR?: PageViewWhereInput[]
    NOT?: PageViewWhereInput | PageViewWhereInput[]
    id?: StringFilter<"PageView"> | string
    path?: StringFilter<"PageView"> | string
    userAgent?: StringNullableFilter<"PageView"> | string | null
    ipAddress?: StringNullableFilter<"PageView"> | string | null
    referer?: StringNullableFilter<"PageView"> | string | null
    sessionId?: StringNullableFilter<"PageView"> | string | null
    userId?: StringNullableFilter<"PageView"> | string | null
    createdAt?: DateTimeFilter<"PageView"> | Date | string
  }

  export type PageViewOrderByWithRelationInput = {
    id?: SortOrder
    path?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    referer?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type PageViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PageViewWhereInput | PageViewWhereInput[]
    OR?: PageViewWhereInput[]
    NOT?: PageViewWhereInput | PageViewWhereInput[]
    path?: StringFilter<"PageView"> | string
    userAgent?: StringNullableFilter<"PageView"> | string | null
    ipAddress?: StringNullableFilter<"PageView"> | string | null
    referer?: StringNullableFilter<"PageView"> | string | null
    sessionId?: StringNullableFilter<"PageView"> | string | null
    userId?: StringNullableFilter<"PageView"> | string | null
    createdAt?: DateTimeFilter<"PageView"> | Date | string
  }, "id">

  export type PageViewOrderByWithAggregationInput = {
    id?: SortOrder
    path?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    referer?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PageViewCountOrderByAggregateInput
    _max?: PageViewMaxOrderByAggregateInput
    _min?: PageViewMinOrderByAggregateInput
  }

  export type PageViewScalarWhereWithAggregatesInput = {
    AND?: PageViewScalarWhereWithAggregatesInput | PageViewScalarWhereWithAggregatesInput[]
    OR?: PageViewScalarWhereWithAggregatesInput[]
    NOT?: PageViewScalarWhereWithAggregatesInput | PageViewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PageView"> | string
    path?: StringWithAggregatesFilter<"PageView"> | string
    userAgent?: StringNullableWithAggregatesFilter<"PageView"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"PageView"> | string | null
    referer?: StringNullableWithAggregatesFilter<"PageView"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"PageView"> | string | null
    userId?: StringNullableWithAggregatesFilter<"PageView"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PageView"> | Date | string
  }

  export type SearchQueryWhereInput = {
    AND?: SearchQueryWhereInput | SearchQueryWhereInput[]
    OR?: SearchQueryWhereInput[]
    NOT?: SearchQueryWhereInput | SearchQueryWhereInput[]
    id?: StringFilter<"SearchQuery"> | string
    query?: StringFilter<"SearchQuery"> | string
    results?: IntFilter<"SearchQuery"> | number
    userId?: StringNullableFilter<"SearchQuery"> | string | null
    createdAt?: DateTimeFilter<"SearchQuery"> | Date | string
  }

  export type SearchQueryOrderByWithRelationInput = {
    id?: SortOrder
    query?: SortOrder
    results?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type SearchQueryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SearchQueryWhereInput | SearchQueryWhereInput[]
    OR?: SearchQueryWhereInput[]
    NOT?: SearchQueryWhereInput | SearchQueryWhereInput[]
    query?: StringFilter<"SearchQuery"> | string
    results?: IntFilter<"SearchQuery"> | number
    userId?: StringNullableFilter<"SearchQuery"> | string | null
    createdAt?: DateTimeFilter<"SearchQuery"> | Date | string
  }, "id">

  export type SearchQueryOrderByWithAggregationInput = {
    id?: SortOrder
    query?: SortOrder
    results?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SearchQueryCountOrderByAggregateInput
    _avg?: SearchQueryAvgOrderByAggregateInput
    _max?: SearchQueryMaxOrderByAggregateInput
    _min?: SearchQueryMinOrderByAggregateInput
    _sum?: SearchQuerySumOrderByAggregateInput
  }

  export type SearchQueryScalarWhereWithAggregatesInput = {
    AND?: SearchQueryScalarWhereWithAggregatesInput | SearchQueryScalarWhereWithAggregatesInput[]
    OR?: SearchQueryScalarWhereWithAggregatesInput[]
    NOT?: SearchQueryScalarWhereWithAggregatesInput | SearchQueryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SearchQuery"> | string
    query?: StringWithAggregatesFilter<"SearchQuery"> | string
    results?: IntWithAggregatesFilter<"SearchQuery"> | number
    userId?: StringNullableWithAggregatesFilter<"SearchQuery"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SearchQuery"> | Date | string
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    id?: StringFilter<"Setting"> | string
    value?: JsonFilter<"Setting">
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    value?: JsonFilter<"Setting">
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }, "id">

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingCountOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Setting"> | string
    value?: JsonWithAggregatesFilter<"Setting">
    updatedAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: StringFilter<"Media"> | string
    filename?: StringFilter<"Media"> | string
    originalName?: StringFilter<"Media"> | string
    mimeType?: StringFilter<"Media"> | string
    size?: IntFilter<"Media"> | number
    url?: StringFilter<"Media"> | string
    alt?: StringNullableFilter<"Media"> | string | null
    caption?: StringNullableFilter<"Media"> | string | null
    width?: IntNullableFilter<"Media"> | number | null
    height?: IntNullableFilter<"Media"> | number | null
    duration?: IntNullableFilter<"Media"> | number | null
    uploadedById?: StringNullableFilter<"Media"> | string | null
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    alt?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    uploadedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    filename?: StringFilter<"Media"> | string
    originalName?: StringFilter<"Media"> | string
    mimeType?: StringFilter<"Media"> | string
    size?: IntFilter<"Media"> | number
    url?: StringFilter<"Media"> | string
    alt?: StringNullableFilter<"Media"> | string | null
    caption?: StringNullableFilter<"Media"> | string | null
    width?: IntNullableFilter<"Media"> | number | null
    height?: IntNullableFilter<"Media"> | number | null
    duration?: IntNullableFilter<"Media"> | number | null
    uploadedById?: StringNullableFilter<"Media"> | string | null
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
  }, "id">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    alt?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    uploadedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _avg?: MediaAvgOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
    _sum?: MediaSumOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Media"> | string
    filename?: StringWithAggregatesFilter<"Media"> | string
    originalName?: StringWithAggregatesFilter<"Media"> | string
    mimeType?: StringWithAggregatesFilter<"Media"> | string
    size?: IntWithAggregatesFilter<"Media"> | number
    url?: StringWithAggregatesFilter<"Media"> | string
    alt?: StringNullableWithAggregatesFilter<"Media"> | string | null
    caption?: StringNullableWithAggregatesFilter<"Media"> | string | null
    width?: IntNullableWithAggregatesFilter<"Media"> | number | null
    height?: IntNullableWithAggregatesFilter<"Media"> | number | null
    duration?: IntNullableWithAggregatesFilter<"Media"> | number | null
    uploadedById?: StringNullableWithAggregatesFilter<"Media"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
  }

  export type LifeOSProfileWhereInput = {
    AND?: LifeOSProfileWhereInput | LifeOSProfileWhereInput[]
    OR?: LifeOSProfileWhereInput[]
    NOT?: LifeOSProfileWhereInput | LifeOSProfileWhereInput[]
    id?: StringFilter<"LifeOSProfile"> | string
    userId?: StringFilter<"LifeOSProfile"> | string
    timezone?: StringFilter<"LifeOSProfile"> | string
    locale?: StringFilter<"LifeOSProfile"> | string
    currency?: StringFilter<"LifeOSProfile"> | string
    themePreference?: StringFilter<"LifeOSProfile"> | string
    notificationSettings?: JsonFilter<"LifeOSProfile">
    privacySettings?: JsonFilter<"LifeOSProfile">
    extractiveSystemsTargeting?: BoolFilter<"LifeOSProfile"> | boolean
    communityControlEnabled?: BoolFilter<"LifeOSProfile"> | boolean
    dataResidencyPreference?: StringFilter<"LifeOSProfile"> | string
    onboardingCompleted?: BoolFilter<"LifeOSProfile"> | boolean
    lastActiveAt?: DateTimeFilter<"LifeOSProfile"> | Date | string
    activationDate?: DateTimeNullableFilter<"LifeOSProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"LifeOSProfile"> | Date | string
    updatedAt?: DateTimeFilter<"LifeOSProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    habits?: HabitListRelationFilter
    goals?: GoalListRelationFilter
    moodEntries?: MoodEntryListRelationFilter
    meditations?: MeditationSessionListRelationFilter
    journals?: JournalListRelationFilter
    transactions?: FinancialTransactionListRelationFilter
    budgets?: BudgetListRelationFilter
  }

  export type LifeOSProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    timezone?: SortOrder
    locale?: SortOrder
    currency?: SortOrder
    themePreference?: SortOrder
    notificationSettings?: SortOrder
    privacySettings?: SortOrder
    extractiveSystemsTargeting?: SortOrder
    communityControlEnabled?: SortOrder
    dataResidencyPreference?: SortOrder
    onboardingCompleted?: SortOrder
    lastActiveAt?: SortOrder
    activationDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    habits?: HabitOrderByRelationAggregateInput
    goals?: GoalOrderByRelationAggregateInput
    moodEntries?: MoodEntryOrderByRelationAggregateInput
    meditations?: MeditationSessionOrderByRelationAggregateInput
    journals?: JournalOrderByRelationAggregateInput
    transactions?: FinancialTransactionOrderByRelationAggregateInput
    budgets?: BudgetOrderByRelationAggregateInput
  }

  export type LifeOSProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: LifeOSProfileWhereInput | LifeOSProfileWhereInput[]
    OR?: LifeOSProfileWhereInput[]
    NOT?: LifeOSProfileWhereInput | LifeOSProfileWhereInput[]
    timezone?: StringFilter<"LifeOSProfile"> | string
    locale?: StringFilter<"LifeOSProfile"> | string
    currency?: StringFilter<"LifeOSProfile"> | string
    themePreference?: StringFilter<"LifeOSProfile"> | string
    notificationSettings?: JsonFilter<"LifeOSProfile">
    privacySettings?: JsonFilter<"LifeOSProfile">
    extractiveSystemsTargeting?: BoolFilter<"LifeOSProfile"> | boolean
    communityControlEnabled?: BoolFilter<"LifeOSProfile"> | boolean
    dataResidencyPreference?: StringFilter<"LifeOSProfile"> | string
    onboardingCompleted?: BoolFilter<"LifeOSProfile"> | boolean
    lastActiveAt?: DateTimeFilter<"LifeOSProfile"> | Date | string
    activationDate?: DateTimeNullableFilter<"LifeOSProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"LifeOSProfile"> | Date | string
    updatedAt?: DateTimeFilter<"LifeOSProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    habits?: HabitListRelationFilter
    goals?: GoalListRelationFilter
    moodEntries?: MoodEntryListRelationFilter
    meditations?: MeditationSessionListRelationFilter
    journals?: JournalListRelationFilter
    transactions?: FinancialTransactionListRelationFilter
    budgets?: BudgetListRelationFilter
  }, "id" | "userId">

  export type LifeOSProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    timezone?: SortOrder
    locale?: SortOrder
    currency?: SortOrder
    themePreference?: SortOrder
    notificationSettings?: SortOrder
    privacySettings?: SortOrder
    extractiveSystemsTargeting?: SortOrder
    communityControlEnabled?: SortOrder
    dataResidencyPreference?: SortOrder
    onboardingCompleted?: SortOrder
    lastActiveAt?: SortOrder
    activationDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LifeOSProfileCountOrderByAggregateInput
    _max?: LifeOSProfileMaxOrderByAggregateInput
    _min?: LifeOSProfileMinOrderByAggregateInput
  }

  export type LifeOSProfileScalarWhereWithAggregatesInput = {
    AND?: LifeOSProfileScalarWhereWithAggregatesInput | LifeOSProfileScalarWhereWithAggregatesInput[]
    OR?: LifeOSProfileScalarWhereWithAggregatesInput[]
    NOT?: LifeOSProfileScalarWhereWithAggregatesInput | LifeOSProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LifeOSProfile"> | string
    userId?: StringWithAggregatesFilter<"LifeOSProfile"> | string
    timezone?: StringWithAggregatesFilter<"LifeOSProfile"> | string
    locale?: StringWithAggregatesFilter<"LifeOSProfile"> | string
    currency?: StringWithAggregatesFilter<"LifeOSProfile"> | string
    themePreference?: StringWithAggregatesFilter<"LifeOSProfile"> | string
    notificationSettings?: JsonWithAggregatesFilter<"LifeOSProfile">
    privacySettings?: JsonWithAggregatesFilter<"LifeOSProfile">
    extractiveSystemsTargeting?: BoolWithAggregatesFilter<"LifeOSProfile"> | boolean
    communityControlEnabled?: BoolWithAggregatesFilter<"LifeOSProfile"> | boolean
    dataResidencyPreference?: StringWithAggregatesFilter<"LifeOSProfile"> | string
    onboardingCompleted?: BoolWithAggregatesFilter<"LifeOSProfile"> | boolean
    lastActiveAt?: DateTimeWithAggregatesFilter<"LifeOSProfile"> | Date | string
    activationDate?: DateTimeNullableWithAggregatesFilter<"LifeOSProfile"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LifeOSProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LifeOSProfile"> | Date | string
  }

  export type HabitWhereInput = {
    AND?: HabitWhereInput | HabitWhereInput[]
    OR?: HabitWhereInput[]
    NOT?: HabitWhereInput | HabitWhereInput[]
    id?: StringFilter<"Habit"> | string
    profileId?: StringFilter<"Habit"> | string
    name?: StringFilter<"Habit"> | string
    description?: StringNullableFilter<"Habit"> | string | null
    category?: StringNullableFilter<"Habit"> | string | null
    frequency?: EnumHabitFrequencyFilter<"Habit"> | $Enums.HabitFrequency
    targetValue?: IntFilter<"Habit"> | number
    unit?: StringNullableFilter<"Habit"> | string | null
    color?: StringNullableFilter<"Habit"> | string | null
    icon?: StringNullableFilter<"Habit"> | string | null
    reminder?: JsonNullableFilter<"Habit">
    isActive?: BoolFilter<"Habit"> | boolean
    currentStreak?: IntFilter<"Habit"> | number
    longestStreak?: IntFilter<"Habit"> | number
    lastCompletedDate?: DateTimeNullableFilter<"Habit"> | Date | string | null
    createdAt?: DateTimeFilter<"Habit"> | Date | string
    updatedAt?: DateTimeFilter<"Habit"> | Date | string
    profile?: XOR<LifeOSProfileRelationFilter, LifeOSProfileWhereInput>
    completions?: HabitCompletionListRelationFilter
  }

  export type HabitOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    frequency?: SortOrder
    targetValue?: SortOrder
    unit?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    reminder?: SortOrderInput | SortOrder
    isActive?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastCompletedDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: LifeOSProfileOrderByWithRelationInput
    completions?: HabitCompletionOrderByRelationAggregateInput
  }

  export type HabitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HabitWhereInput | HabitWhereInput[]
    OR?: HabitWhereInput[]
    NOT?: HabitWhereInput | HabitWhereInput[]
    profileId?: StringFilter<"Habit"> | string
    name?: StringFilter<"Habit"> | string
    description?: StringNullableFilter<"Habit"> | string | null
    category?: StringNullableFilter<"Habit"> | string | null
    frequency?: EnumHabitFrequencyFilter<"Habit"> | $Enums.HabitFrequency
    targetValue?: IntFilter<"Habit"> | number
    unit?: StringNullableFilter<"Habit"> | string | null
    color?: StringNullableFilter<"Habit"> | string | null
    icon?: StringNullableFilter<"Habit"> | string | null
    reminder?: JsonNullableFilter<"Habit">
    isActive?: BoolFilter<"Habit"> | boolean
    currentStreak?: IntFilter<"Habit"> | number
    longestStreak?: IntFilter<"Habit"> | number
    lastCompletedDate?: DateTimeNullableFilter<"Habit"> | Date | string | null
    createdAt?: DateTimeFilter<"Habit"> | Date | string
    updatedAt?: DateTimeFilter<"Habit"> | Date | string
    profile?: XOR<LifeOSProfileRelationFilter, LifeOSProfileWhereInput>
    completions?: HabitCompletionListRelationFilter
  }, "id">

  export type HabitOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    frequency?: SortOrder
    targetValue?: SortOrder
    unit?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    reminder?: SortOrderInput | SortOrder
    isActive?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastCompletedDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HabitCountOrderByAggregateInput
    _avg?: HabitAvgOrderByAggregateInput
    _max?: HabitMaxOrderByAggregateInput
    _min?: HabitMinOrderByAggregateInput
    _sum?: HabitSumOrderByAggregateInput
  }

  export type HabitScalarWhereWithAggregatesInput = {
    AND?: HabitScalarWhereWithAggregatesInput | HabitScalarWhereWithAggregatesInput[]
    OR?: HabitScalarWhereWithAggregatesInput[]
    NOT?: HabitScalarWhereWithAggregatesInput | HabitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Habit"> | string
    profileId?: StringWithAggregatesFilter<"Habit"> | string
    name?: StringWithAggregatesFilter<"Habit"> | string
    description?: StringNullableWithAggregatesFilter<"Habit"> | string | null
    category?: StringNullableWithAggregatesFilter<"Habit"> | string | null
    frequency?: EnumHabitFrequencyWithAggregatesFilter<"Habit"> | $Enums.HabitFrequency
    targetValue?: IntWithAggregatesFilter<"Habit"> | number
    unit?: StringNullableWithAggregatesFilter<"Habit"> | string | null
    color?: StringNullableWithAggregatesFilter<"Habit"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Habit"> | string | null
    reminder?: JsonNullableWithAggregatesFilter<"Habit">
    isActive?: BoolWithAggregatesFilter<"Habit"> | boolean
    currentStreak?: IntWithAggregatesFilter<"Habit"> | number
    longestStreak?: IntWithAggregatesFilter<"Habit"> | number
    lastCompletedDate?: DateTimeNullableWithAggregatesFilter<"Habit"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Habit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Habit"> | Date | string
  }

  export type HabitCompletionWhereInput = {
    AND?: HabitCompletionWhereInput | HabitCompletionWhereInput[]
    OR?: HabitCompletionWhereInput[]
    NOT?: HabitCompletionWhereInput | HabitCompletionWhereInput[]
    id?: StringFilter<"HabitCompletion"> | string
    habitId?: StringFilter<"HabitCompletion"> | string
    completedAt?: DateTimeFilter<"HabitCompletion"> | Date | string
    value?: IntFilter<"HabitCompletion"> | number
    notes?: StringNullableFilter<"HabitCompletion"> | string | null
    satisfaction?: IntNullableFilter<"HabitCompletion"> | number | null
    difficulty?: IntNullableFilter<"HabitCompletion"> | number | null
    habit?: XOR<HabitRelationFilter, HabitWhereInput>
  }

  export type HabitCompletionOrderByWithRelationInput = {
    id?: SortOrder
    habitId?: SortOrder
    completedAt?: SortOrder
    value?: SortOrder
    notes?: SortOrderInput | SortOrder
    satisfaction?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    habit?: HabitOrderByWithRelationInput
  }

  export type HabitCompletionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    habitId_completedAt?: HabitCompletionHabitIdCompletedAtCompoundUniqueInput
    AND?: HabitCompletionWhereInput | HabitCompletionWhereInput[]
    OR?: HabitCompletionWhereInput[]
    NOT?: HabitCompletionWhereInput | HabitCompletionWhereInput[]
    habitId?: StringFilter<"HabitCompletion"> | string
    completedAt?: DateTimeFilter<"HabitCompletion"> | Date | string
    value?: IntFilter<"HabitCompletion"> | number
    notes?: StringNullableFilter<"HabitCompletion"> | string | null
    satisfaction?: IntNullableFilter<"HabitCompletion"> | number | null
    difficulty?: IntNullableFilter<"HabitCompletion"> | number | null
    habit?: XOR<HabitRelationFilter, HabitWhereInput>
  }, "id" | "habitId_completedAt">

  export type HabitCompletionOrderByWithAggregationInput = {
    id?: SortOrder
    habitId?: SortOrder
    completedAt?: SortOrder
    value?: SortOrder
    notes?: SortOrderInput | SortOrder
    satisfaction?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    _count?: HabitCompletionCountOrderByAggregateInput
    _avg?: HabitCompletionAvgOrderByAggregateInput
    _max?: HabitCompletionMaxOrderByAggregateInput
    _min?: HabitCompletionMinOrderByAggregateInput
    _sum?: HabitCompletionSumOrderByAggregateInput
  }

  export type HabitCompletionScalarWhereWithAggregatesInput = {
    AND?: HabitCompletionScalarWhereWithAggregatesInput | HabitCompletionScalarWhereWithAggregatesInput[]
    OR?: HabitCompletionScalarWhereWithAggregatesInput[]
    NOT?: HabitCompletionScalarWhereWithAggregatesInput | HabitCompletionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HabitCompletion"> | string
    habitId?: StringWithAggregatesFilter<"HabitCompletion"> | string
    completedAt?: DateTimeWithAggregatesFilter<"HabitCompletion"> | Date | string
    value?: IntWithAggregatesFilter<"HabitCompletion"> | number
    notes?: StringNullableWithAggregatesFilter<"HabitCompletion"> | string | null
    satisfaction?: IntNullableWithAggregatesFilter<"HabitCompletion"> | number | null
    difficulty?: IntNullableWithAggregatesFilter<"HabitCompletion"> | number | null
  }

  export type GoalWhereInput = {
    AND?: GoalWhereInput | GoalWhereInput[]
    OR?: GoalWhereInput[]
    NOT?: GoalWhereInput | GoalWhereInput[]
    id?: StringFilter<"Goal"> | string
    profileId?: StringFilter<"Goal"> | string
    title?: StringFilter<"Goal"> | string
    description?: StringNullableFilter<"Goal"> | string | null
    category?: StringNullableFilter<"Goal"> | string | null
    targetValue?: FloatNullableFilter<"Goal"> | number | null
    currentValue?: FloatFilter<"Goal"> | number
    unit?: StringNullableFilter<"Goal"> | string | null
    startDate?: DateTimeFilter<"Goal"> | Date | string
    targetDate?: DateTimeNullableFilter<"Goal"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Goal"> | Date | string | null
    status?: EnumGoalStatusFilter<"Goal"> | $Enums.GoalStatus
    priority?: EnumPriorityFilter<"Goal"> | $Enums.Priority
    progress?: FloatFilter<"Goal"> | number
    motivation?: StringNullableFilter<"Goal"> | string | null
    visualisation?: StringNullableFilter<"Goal"> | string | null
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    updatedAt?: DateTimeFilter<"Goal"> | Date | string
    profile?: XOR<LifeOSProfileRelationFilter, LifeOSProfileWhereInput>
    milestones?: GoalMilestoneListRelationFilter
    updates?: GoalUpdateListRelationFilter
  }

  export type GoalOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    targetValue?: SortOrderInput | SortOrder
    currentValue?: SortOrder
    unit?: SortOrderInput | SortOrder
    startDate?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    motivation?: SortOrderInput | SortOrder
    visualisation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: LifeOSProfileOrderByWithRelationInput
    milestones?: GoalMilestoneOrderByRelationAggregateInput
    updates?: GoalUpdateOrderByRelationAggregateInput
  }

  export type GoalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GoalWhereInput | GoalWhereInput[]
    OR?: GoalWhereInput[]
    NOT?: GoalWhereInput | GoalWhereInput[]
    profileId?: StringFilter<"Goal"> | string
    title?: StringFilter<"Goal"> | string
    description?: StringNullableFilter<"Goal"> | string | null
    category?: StringNullableFilter<"Goal"> | string | null
    targetValue?: FloatNullableFilter<"Goal"> | number | null
    currentValue?: FloatFilter<"Goal"> | number
    unit?: StringNullableFilter<"Goal"> | string | null
    startDate?: DateTimeFilter<"Goal"> | Date | string
    targetDate?: DateTimeNullableFilter<"Goal"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Goal"> | Date | string | null
    status?: EnumGoalStatusFilter<"Goal"> | $Enums.GoalStatus
    priority?: EnumPriorityFilter<"Goal"> | $Enums.Priority
    progress?: FloatFilter<"Goal"> | number
    motivation?: StringNullableFilter<"Goal"> | string | null
    visualisation?: StringNullableFilter<"Goal"> | string | null
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    updatedAt?: DateTimeFilter<"Goal"> | Date | string
    profile?: XOR<LifeOSProfileRelationFilter, LifeOSProfileWhereInput>
    milestones?: GoalMilestoneListRelationFilter
    updates?: GoalUpdateListRelationFilter
  }, "id">

  export type GoalOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    targetValue?: SortOrderInput | SortOrder
    currentValue?: SortOrder
    unit?: SortOrderInput | SortOrder
    startDate?: SortOrder
    targetDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    motivation?: SortOrderInput | SortOrder
    visualisation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GoalCountOrderByAggregateInput
    _avg?: GoalAvgOrderByAggregateInput
    _max?: GoalMaxOrderByAggregateInput
    _min?: GoalMinOrderByAggregateInput
    _sum?: GoalSumOrderByAggregateInput
  }

  export type GoalScalarWhereWithAggregatesInput = {
    AND?: GoalScalarWhereWithAggregatesInput | GoalScalarWhereWithAggregatesInput[]
    OR?: GoalScalarWhereWithAggregatesInput[]
    NOT?: GoalScalarWhereWithAggregatesInput | GoalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Goal"> | string
    profileId?: StringWithAggregatesFilter<"Goal"> | string
    title?: StringWithAggregatesFilter<"Goal"> | string
    description?: StringNullableWithAggregatesFilter<"Goal"> | string | null
    category?: StringNullableWithAggregatesFilter<"Goal"> | string | null
    targetValue?: FloatNullableWithAggregatesFilter<"Goal"> | number | null
    currentValue?: FloatWithAggregatesFilter<"Goal"> | number
    unit?: StringNullableWithAggregatesFilter<"Goal"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Goal"> | Date | string
    targetDate?: DateTimeNullableWithAggregatesFilter<"Goal"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Goal"> | Date | string | null
    status?: EnumGoalStatusWithAggregatesFilter<"Goal"> | $Enums.GoalStatus
    priority?: EnumPriorityWithAggregatesFilter<"Goal"> | $Enums.Priority
    progress?: FloatWithAggregatesFilter<"Goal"> | number
    motivation?: StringNullableWithAggregatesFilter<"Goal"> | string | null
    visualisation?: StringNullableWithAggregatesFilter<"Goal"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Goal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Goal"> | Date | string
  }

  export type GoalMilestoneWhereInput = {
    AND?: GoalMilestoneWhereInput | GoalMilestoneWhereInput[]
    OR?: GoalMilestoneWhereInput[]
    NOT?: GoalMilestoneWhereInput | GoalMilestoneWhereInput[]
    id?: StringFilter<"GoalMilestone"> | string
    goalId?: StringFilter<"GoalMilestone"> | string
    title?: StringFilter<"GoalMilestone"> | string
    description?: StringNullableFilter<"GoalMilestone"> | string | null
    targetDate?: DateTimeNullableFilter<"GoalMilestone"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"GoalMilestone"> | Date | string | null
    targetValue?: FloatNullableFilter<"GoalMilestone"> | number | null
    currentValue?: FloatFilter<"GoalMilestone"> | number
    status?: EnumMilestoneStatusFilter<"GoalMilestone"> | $Enums.MilestoneStatus
    createdAt?: DateTimeFilter<"GoalMilestone"> | Date | string
    updatedAt?: DateTimeFilter<"GoalMilestone"> | Date | string
    goal?: XOR<GoalRelationFilter, GoalWhereInput>
  }

  export type GoalMilestoneOrderByWithRelationInput = {
    id?: SortOrder
    goalId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    targetDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    targetValue?: SortOrderInput | SortOrder
    currentValue?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goal?: GoalOrderByWithRelationInput
  }

  export type GoalMilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GoalMilestoneWhereInput | GoalMilestoneWhereInput[]
    OR?: GoalMilestoneWhereInput[]
    NOT?: GoalMilestoneWhereInput | GoalMilestoneWhereInput[]
    goalId?: StringFilter<"GoalMilestone"> | string
    title?: StringFilter<"GoalMilestone"> | string
    description?: StringNullableFilter<"GoalMilestone"> | string | null
    targetDate?: DateTimeNullableFilter<"GoalMilestone"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"GoalMilestone"> | Date | string | null
    targetValue?: FloatNullableFilter<"GoalMilestone"> | number | null
    currentValue?: FloatFilter<"GoalMilestone"> | number
    status?: EnumMilestoneStatusFilter<"GoalMilestone"> | $Enums.MilestoneStatus
    createdAt?: DateTimeFilter<"GoalMilestone"> | Date | string
    updatedAt?: DateTimeFilter<"GoalMilestone"> | Date | string
    goal?: XOR<GoalRelationFilter, GoalWhereInput>
  }, "id">

  export type GoalMilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    goalId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    targetDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    targetValue?: SortOrderInput | SortOrder
    currentValue?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GoalMilestoneCountOrderByAggregateInput
    _avg?: GoalMilestoneAvgOrderByAggregateInput
    _max?: GoalMilestoneMaxOrderByAggregateInput
    _min?: GoalMilestoneMinOrderByAggregateInput
    _sum?: GoalMilestoneSumOrderByAggregateInput
  }

  export type GoalMilestoneScalarWhereWithAggregatesInput = {
    AND?: GoalMilestoneScalarWhereWithAggregatesInput | GoalMilestoneScalarWhereWithAggregatesInput[]
    OR?: GoalMilestoneScalarWhereWithAggregatesInput[]
    NOT?: GoalMilestoneScalarWhereWithAggregatesInput | GoalMilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GoalMilestone"> | string
    goalId?: StringWithAggregatesFilter<"GoalMilestone"> | string
    title?: StringWithAggregatesFilter<"GoalMilestone"> | string
    description?: StringNullableWithAggregatesFilter<"GoalMilestone"> | string | null
    targetDate?: DateTimeNullableWithAggregatesFilter<"GoalMilestone"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"GoalMilestone"> | Date | string | null
    targetValue?: FloatNullableWithAggregatesFilter<"GoalMilestone"> | number | null
    currentValue?: FloatWithAggregatesFilter<"GoalMilestone"> | number
    status?: EnumMilestoneStatusWithAggregatesFilter<"GoalMilestone"> | $Enums.MilestoneStatus
    createdAt?: DateTimeWithAggregatesFilter<"GoalMilestone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GoalMilestone"> | Date | string
  }

  export type GoalUpdateWhereInput = {
    AND?: GoalUpdateWhereInput | GoalUpdateWhereInput[]
    OR?: GoalUpdateWhereInput[]
    NOT?: GoalUpdateWhereInput | GoalUpdateWhereInput[]
    id?: StringFilter<"GoalUpdate"> | string
    goalId?: StringFilter<"GoalUpdate"> | string
    content?: StringFilter<"GoalUpdate"> | string
    value?: FloatNullableFilter<"GoalUpdate"> | number | null
    createdAt?: DateTimeFilter<"GoalUpdate"> | Date | string
    goal?: XOR<GoalRelationFilter, GoalWhereInput>
  }

  export type GoalUpdateOrderByWithRelationInput = {
    id?: SortOrder
    goalId?: SortOrder
    content?: SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    goal?: GoalOrderByWithRelationInput
  }

  export type GoalUpdateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GoalUpdateWhereInput | GoalUpdateWhereInput[]
    OR?: GoalUpdateWhereInput[]
    NOT?: GoalUpdateWhereInput | GoalUpdateWhereInput[]
    goalId?: StringFilter<"GoalUpdate"> | string
    content?: StringFilter<"GoalUpdate"> | string
    value?: FloatNullableFilter<"GoalUpdate"> | number | null
    createdAt?: DateTimeFilter<"GoalUpdate"> | Date | string
    goal?: XOR<GoalRelationFilter, GoalWhereInput>
  }, "id">

  export type GoalUpdateOrderByWithAggregationInput = {
    id?: SortOrder
    goalId?: SortOrder
    content?: SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GoalUpdateCountOrderByAggregateInput
    _avg?: GoalUpdateAvgOrderByAggregateInput
    _max?: GoalUpdateMaxOrderByAggregateInput
    _min?: GoalUpdateMinOrderByAggregateInput
    _sum?: GoalUpdateSumOrderByAggregateInput
  }

  export type GoalUpdateScalarWhereWithAggregatesInput = {
    AND?: GoalUpdateScalarWhereWithAggregatesInput | GoalUpdateScalarWhereWithAggregatesInput[]
    OR?: GoalUpdateScalarWhereWithAggregatesInput[]
    NOT?: GoalUpdateScalarWhereWithAggregatesInput | GoalUpdateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GoalUpdate"> | string
    goalId?: StringWithAggregatesFilter<"GoalUpdate"> | string
    content?: StringWithAggregatesFilter<"GoalUpdate"> | string
    value?: FloatNullableWithAggregatesFilter<"GoalUpdate"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"GoalUpdate"> | Date | string
  }

  export type MeditationSessionWhereInput = {
    AND?: MeditationSessionWhereInput | MeditationSessionWhereInput[]
    OR?: MeditationSessionWhereInput[]
    NOT?: MeditationSessionWhereInput | MeditationSessionWhereInput[]
    id?: StringFilter<"MeditationSession"> | string
    profileId?: StringFilter<"MeditationSession"> | string
    duration?: IntFilter<"MeditationSession"> | number
    technique?: StringNullableFilter<"MeditationSession"> | string | null
    guidedSession?: BoolFilter<"MeditationSession"> | boolean
    guideUrl?: StringNullableFilter<"MeditationSession"> | string | null
    rating?: IntNullableFilter<"MeditationSession"> | number | null
    notes?: StringNullableFilter<"MeditationSession"> | string | null
    mood?: StringNullableFilter<"MeditationSession"> | string | null
    location?: StringNullableFilter<"MeditationSession"> | string | null
    distractions?: StringNullableFilter<"MeditationSession"> | string | null
    createdAt?: DateTimeFilter<"MeditationSession"> | Date | string
    profile?: XOR<LifeOSProfileRelationFilter, LifeOSProfileWhereInput>
  }

  export type MeditationSessionOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    duration?: SortOrder
    technique?: SortOrderInput | SortOrder
    guidedSession?: SortOrder
    guideUrl?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    mood?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    distractions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    profile?: LifeOSProfileOrderByWithRelationInput
  }

  export type MeditationSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MeditationSessionWhereInput | MeditationSessionWhereInput[]
    OR?: MeditationSessionWhereInput[]
    NOT?: MeditationSessionWhereInput | MeditationSessionWhereInput[]
    profileId?: StringFilter<"MeditationSession"> | string
    duration?: IntFilter<"MeditationSession"> | number
    technique?: StringNullableFilter<"MeditationSession"> | string | null
    guidedSession?: BoolFilter<"MeditationSession"> | boolean
    guideUrl?: StringNullableFilter<"MeditationSession"> | string | null
    rating?: IntNullableFilter<"MeditationSession"> | number | null
    notes?: StringNullableFilter<"MeditationSession"> | string | null
    mood?: StringNullableFilter<"MeditationSession"> | string | null
    location?: StringNullableFilter<"MeditationSession"> | string | null
    distractions?: StringNullableFilter<"MeditationSession"> | string | null
    createdAt?: DateTimeFilter<"MeditationSession"> | Date | string
    profile?: XOR<LifeOSProfileRelationFilter, LifeOSProfileWhereInput>
  }, "id">

  export type MeditationSessionOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    duration?: SortOrder
    technique?: SortOrderInput | SortOrder
    guidedSession?: SortOrder
    guideUrl?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    mood?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    distractions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MeditationSessionCountOrderByAggregateInput
    _avg?: MeditationSessionAvgOrderByAggregateInput
    _max?: MeditationSessionMaxOrderByAggregateInput
    _min?: MeditationSessionMinOrderByAggregateInput
    _sum?: MeditationSessionSumOrderByAggregateInput
  }

  export type MeditationSessionScalarWhereWithAggregatesInput = {
    AND?: MeditationSessionScalarWhereWithAggregatesInput | MeditationSessionScalarWhereWithAggregatesInput[]
    OR?: MeditationSessionScalarWhereWithAggregatesInput[]
    NOT?: MeditationSessionScalarWhereWithAggregatesInput | MeditationSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MeditationSession"> | string
    profileId?: StringWithAggregatesFilter<"MeditationSession"> | string
    duration?: IntWithAggregatesFilter<"MeditationSession"> | number
    technique?: StringNullableWithAggregatesFilter<"MeditationSession"> | string | null
    guidedSession?: BoolWithAggregatesFilter<"MeditationSession"> | boolean
    guideUrl?: StringNullableWithAggregatesFilter<"MeditationSession"> | string | null
    rating?: IntNullableWithAggregatesFilter<"MeditationSession"> | number | null
    notes?: StringNullableWithAggregatesFilter<"MeditationSession"> | string | null
    mood?: StringNullableWithAggregatesFilter<"MeditationSession"> | string | null
    location?: StringNullableWithAggregatesFilter<"MeditationSession"> | string | null
    distractions?: StringNullableWithAggregatesFilter<"MeditationSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MeditationSession"> | Date | string
  }

  export type MoodEntryWhereInput = {
    AND?: MoodEntryWhereInput | MoodEntryWhereInput[]
    OR?: MoodEntryWhereInput[]
    NOT?: MoodEntryWhereInput | MoodEntryWhereInput[]
    id?: StringFilter<"MoodEntry"> | string
    profileId?: StringFilter<"MoodEntry"> | string
    mood?: StringFilter<"MoodEntry"> | string
    intensity?: IntFilter<"MoodEntry"> | number
    emotions?: StringNullableListFilter<"MoodEntry">
    activities?: StringNullableListFilter<"MoodEntry">
    location?: StringNullableFilter<"MoodEntry"> | string | null
    weather?: StringNullableFilter<"MoodEntry"> | string | null
    notes?: StringNullableFilter<"MoodEntry"> | string | null
    triggers?: StringNullableFilter<"MoodEntry"> | string | null
    gratitude?: StringNullableFilter<"MoodEntry"> | string | null
    recordedAt?: DateTimeFilter<"MoodEntry"> | Date | string
    createdAt?: DateTimeFilter<"MoodEntry"> | Date | string
    profile?: XOR<LifeOSProfileRelationFilter, LifeOSProfileWhereInput>
  }

  export type MoodEntryOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    mood?: SortOrder
    intensity?: SortOrder
    emotions?: SortOrder
    activities?: SortOrder
    location?: SortOrderInput | SortOrder
    weather?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    triggers?: SortOrderInput | SortOrder
    gratitude?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    createdAt?: SortOrder
    profile?: LifeOSProfileOrderByWithRelationInput
  }

  export type MoodEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MoodEntryWhereInput | MoodEntryWhereInput[]
    OR?: MoodEntryWhereInput[]
    NOT?: MoodEntryWhereInput | MoodEntryWhereInput[]
    profileId?: StringFilter<"MoodEntry"> | string
    mood?: StringFilter<"MoodEntry"> | string
    intensity?: IntFilter<"MoodEntry"> | number
    emotions?: StringNullableListFilter<"MoodEntry">
    activities?: StringNullableListFilter<"MoodEntry">
    location?: StringNullableFilter<"MoodEntry"> | string | null
    weather?: StringNullableFilter<"MoodEntry"> | string | null
    notes?: StringNullableFilter<"MoodEntry"> | string | null
    triggers?: StringNullableFilter<"MoodEntry"> | string | null
    gratitude?: StringNullableFilter<"MoodEntry"> | string | null
    recordedAt?: DateTimeFilter<"MoodEntry"> | Date | string
    createdAt?: DateTimeFilter<"MoodEntry"> | Date | string
    profile?: XOR<LifeOSProfileRelationFilter, LifeOSProfileWhereInput>
  }, "id">

  export type MoodEntryOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    mood?: SortOrder
    intensity?: SortOrder
    emotions?: SortOrder
    activities?: SortOrder
    location?: SortOrderInput | SortOrder
    weather?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    triggers?: SortOrderInput | SortOrder
    gratitude?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    createdAt?: SortOrder
    _count?: MoodEntryCountOrderByAggregateInput
    _avg?: MoodEntryAvgOrderByAggregateInput
    _max?: MoodEntryMaxOrderByAggregateInput
    _min?: MoodEntryMinOrderByAggregateInput
    _sum?: MoodEntrySumOrderByAggregateInput
  }

  export type MoodEntryScalarWhereWithAggregatesInput = {
    AND?: MoodEntryScalarWhereWithAggregatesInput | MoodEntryScalarWhereWithAggregatesInput[]
    OR?: MoodEntryScalarWhereWithAggregatesInput[]
    NOT?: MoodEntryScalarWhereWithAggregatesInput | MoodEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MoodEntry"> | string
    profileId?: StringWithAggregatesFilter<"MoodEntry"> | string
    mood?: StringWithAggregatesFilter<"MoodEntry"> | string
    intensity?: IntWithAggregatesFilter<"MoodEntry"> | number
    emotions?: StringNullableListFilter<"MoodEntry">
    activities?: StringNullableListFilter<"MoodEntry">
    location?: StringNullableWithAggregatesFilter<"MoodEntry"> | string | null
    weather?: StringNullableWithAggregatesFilter<"MoodEntry"> | string | null
    notes?: StringNullableWithAggregatesFilter<"MoodEntry"> | string | null
    triggers?: StringNullableWithAggregatesFilter<"MoodEntry"> | string | null
    gratitude?: StringNullableWithAggregatesFilter<"MoodEntry"> | string | null
    recordedAt?: DateTimeWithAggregatesFilter<"MoodEntry"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"MoodEntry"> | Date | string
  }

  export type JournalWhereInput = {
    AND?: JournalWhereInput | JournalWhereInput[]
    OR?: JournalWhereInput[]
    NOT?: JournalWhereInput | JournalWhereInput[]
    id?: StringFilter<"Journal"> | string
    profileId?: StringFilter<"Journal"> | string
    title?: StringNullableFilter<"Journal"> | string | null
    content?: StringFilter<"Journal"> | string
    mood?: StringNullableFilter<"Journal"> | string | null
    tags?: StringNullableListFilter<"Journal">
    isPrivate?: BoolFilter<"Journal"> | boolean
    template?: StringNullableFilter<"Journal"> | string | null
    prompts?: JsonNullableFilter<"Journal">
    createdAt?: DateTimeFilter<"Journal"> | Date | string
    updatedAt?: DateTimeFilter<"Journal"> | Date | string
    profile?: XOR<LifeOSProfileRelationFilter, LifeOSProfileWhereInput>
  }

  export type JournalOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    mood?: SortOrderInput | SortOrder
    tags?: SortOrder
    isPrivate?: SortOrder
    template?: SortOrderInput | SortOrder
    prompts?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: LifeOSProfileOrderByWithRelationInput
  }

  export type JournalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalWhereInput | JournalWhereInput[]
    OR?: JournalWhereInput[]
    NOT?: JournalWhereInput | JournalWhereInput[]
    profileId?: StringFilter<"Journal"> | string
    title?: StringNullableFilter<"Journal"> | string | null
    content?: StringFilter<"Journal"> | string
    mood?: StringNullableFilter<"Journal"> | string | null
    tags?: StringNullableListFilter<"Journal">
    isPrivate?: BoolFilter<"Journal"> | boolean
    template?: StringNullableFilter<"Journal"> | string | null
    prompts?: JsonNullableFilter<"Journal">
    createdAt?: DateTimeFilter<"Journal"> | Date | string
    updatedAt?: DateTimeFilter<"Journal"> | Date | string
    profile?: XOR<LifeOSProfileRelationFilter, LifeOSProfileWhereInput>
  }, "id">

  export type JournalOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    mood?: SortOrderInput | SortOrder
    tags?: SortOrder
    isPrivate?: SortOrder
    template?: SortOrderInput | SortOrder
    prompts?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JournalCountOrderByAggregateInput
    _max?: JournalMaxOrderByAggregateInput
    _min?: JournalMinOrderByAggregateInput
  }

  export type JournalScalarWhereWithAggregatesInput = {
    AND?: JournalScalarWhereWithAggregatesInput | JournalScalarWhereWithAggregatesInput[]
    OR?: JournalScalarWhereWithAggregatesInput[]
    NOT?: JournalScalarWhereWithAggregatesInput | JournalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Journal"> | string
    profileId?: StringWithAggregatesFilter<"Journal"> | string
    title?: StringNullableWithAggregatesFilter<"Journal"> | string | null
    content?: StringWithAggregatesFilter<"Journal"> | string
    mood?: StringNullableWithAggregatesFilter<"Journal"> | string | null
    tags?: StringNullableListFilter<"Journal">
    isPrivate?: BoolWithAggregatesFilter<"Journal"> | boolean
    template?: StringNullableWithAggregatesFilter<"Journal"> | string | null
    prompts?: JsonNullableWithAggregatesFilter<"Journal">
    createdAt?: DateTimeWithAggregatesFilter<"Journal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Journal"> | Date | string
  }

  export type CalendarEventWhereInput = {
    AND?: CalendarEventWhereInput | CalendarEventWhereInput[]
    OR?: CalendarEventWhereInput[]
    NOT?: CalendarEventWhereInput | CalendarEventWhereInput[]
    id?: StringFilter<"CalendarEvent"> | string
    userId?: StringFilter<"CalendarEvent"> | string
    title?: StringFilter<"CalendarEvent"> | string
    description?: StringNullableFilter<"CalendarEvent"> | string | null
    startTime?: DateTimeFilter<"CalendarEvent"> | Date | string
    endTime?: DateTimeNullableFilter<"CalendarEvent"> | Date | string | null
    isAllDay?: BoolFilter<"CalendarEvent"> | boolean
    location?: StringNullableFilter<"CalendarEvent"> | string | null
    url?: StringNullableFilter<"CalendarEvent"> | string | null
    category?: StringNullableFilter<"CalendarEvent"> | string | null
    color?: StringNullableFilter<"CalendarEvent"> | string | null
    isRecurring?: BoolFilter<"CalendarEvent"> | boolean
    recurrenceRule?: StringNullableFilter<"CalendarEvent"> | string | null
    parentEventId?: StringNullableFilter<"CalendarEvent"> | string | null
    eventType?: EnumEventTypeFilter<"CalendarEvent"> | $Enums.EventType
    visibility?: EnumVisibilityFilter<"CalendarEvent"> | $Enums.Visibility
    projectId?: StringNullableFilter<"CalendarEvent"> | string | null
    communityEvent?: BoolFilter<"CalendarEvent"> | boolean
    reminders?: JsonFilter<"CalendarEvent">
    createdAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    attendees?: EventAttendeeListRelationFilter
  }

  export type CalendarEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    isAllDay?: SortOrder
    location?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    recurrenceRule?: SortOrderInput | SortOrder
    parentEventId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    visibility?: SortOrder
    projectId?: SortOrderInput | SortOrder
    communityEvent?: SortOrder
    reminders?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    attendees?: EventAttendeeOrderByRelationAggregateInput
  }

  export type CalendarEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CalendarEventWhereInput | CalendarEventWhereInput[]
    OR?: CalendarEventWhereInput[]
    NOT?: CalendarEventWhereInput | CalendarEventWhereInput[]
    userId?: StringFilter<"CalendarEvent"> | string
    title?: StringFilter<"CalendarEvent"> | string
    description?: StringNullableFilter<"CalendarEvent"> | string | null
    startTime?: DateTimeFilter<"CalendarEvent"> | Date | string
    endTime?: DateTimeNullableFilter<"CalendarEvent"> | Date | string | null
    isAllDay?: BoolFilter<"CalendarEvent"> | boolean
    location?: StringNullableFilter<"CalendarEvent"> | string | null
    url?: StringNullableFilter<"CalendarEvent"> | string | null
    category?: StringNullableFilter<"CalendarEvent"> | string | null
    color?: StringNullableFilter<"CalendarEvent"> | string | null
    isRecurring?: BoolFilter<"CalendarEvent"> | boolean
    recurrenceRule?: StringNullableFilter<"CalendarEvent"> | string | null
    parentEventId?: StringNullableFilter<"CalendarEvent"> | string | null
    eventType?: EnumEventTypeFilter<"CalendarEvent"> | $Enums.EventType
    visibility?: EnumVisibilityFilter<"CalendarEvent"> | $Enums.Visibility
    projectId?: StringNullableFilter<"CalendarEvent"> | string | null
    communityEvent?: BoolFilter<"CalendarEvent"> | boolean
    reminders?: JsonFilter<"CalendarEvent">
    createdAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    attendees?: EventAttendeeListRelationFilter
  }, "id">

  export type CalendarEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    isAllDay?: SortOrder
    location?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    recurrenceRule?: SortOrderInput | SortOrder
    parentEventId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    visibility?: SortOrder
    projectId?: SortOrderInput | SortOrder
    communityEvent?: SortOrder
    reminders?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CalendarEventCountOrderByAggregateInput
    _max?: CalendarEventMaxOrderByAggregateInput
    _min?: CalendarEventMinOrderByAggregateInput
  }

  export type CalendarEventScalarWhereWithAggregatesInput = {
    AND?: CalendarEventScalarWhereWithAggregatesInput | CalendarEventScalarWhereWithAggregatesInput[]
    OR?: CalendarEventScalarWhereWithAggregatesInput[]
    NOT?: CalendarEventScalarWhereWithAggregatesInput | CalendarEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CalendarEvent"> | string
    userId?: StringWithAggregatesFilter<"CalendarEvent"> | string
    title?: StringWithAggregatesFilter<"CalendarEvent"> | string
    description?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"CalendarEvent"> | Date | string | null
    isAllDay?: BoolWithAggregatesFilter<"CalendarEvent"> | boolean
    location?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    url?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    category?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    color?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    isRecurring?: BoolWithAggregatesFilter<"CalendarEvent"> | boolean
    recurrenceRule?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    parentEventId?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    eventType?: EnumEventTypeWithAggregatesFilter<"CalendarEvent"> | $Enums.EventType
    visibility?: EnumVisibilityWithAggregatesFilter<"CalendarEvent"> | $Enums.Visibility
    projectId?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    communityEvent?: BoolWithAggregatesFilter<"CalendarEvent"> | boolean
    reminders?: JsonWithAggregatesFilter<"CalendarEvent">
    createdAt?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
  }

  export type EventAttendeeWhereInput = {
    AND?: EventAttendeeWhereInput | EventAttendeeWhereInput[]
    OR?: EventAttendeeWhereInput[]
    NOT?: EventAttendeeWhereInput | EventAttendeeWhereInput[]
    id?: StringFilter<"EventAttendee"> | string
    eventId?: StringFilter<"EventAttendee"> | string
    userId?: StringFilter<"EventAttendee"> | string
    status?: EnumAttendeeStatusFilter<"EventAttendee"> | $Enums.AttendeeStatus
    response?: StringNullableFilter<"EventAttendee"> | string | null
    createdAt?: DateTimeFilter<"EventAttendee"> | Date | string
    updatedAt?: DateTimeFilter<"EventAttendee"> | Date | string
    event?: XOR<CalendarEventRelationFilter, CalendarEventWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EventAttendeeOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    response?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    event?: CalendarEventOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type EventAttendeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_userId?: EventAttendeeEventIdUserIdCompoundUniqueInput
    AND?: EventAttendeeWhereInput | EventAttendeeWhereInput[]
    OR?: EventAttendeeWhereInput[]
    NOT?: EventAttendeeWhereInput | EventAttendeeWhereInput[]
    eventId?: StringFilter<"EventAttendee"> | string
    userId?: StringFilter<"EventAttendee"> | string
    status?: EnumAttendeeStatusFilter<"EventAttendee"> | $Enums.AttendeeStatus
    response?: StringNullableFilter<"EventAttendee"> | string | null
    createdAt?: DateTimeFilter<"EventAttendee"> | Date | string
    updatedAt?: DateTimeFilter<"EventAttendee"> | Date | string
    event?: XOR<CalendarEventRelationFilter, CalendarEventWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "eventId_userId">

  export type EventAttendeeOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    response?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventAttendeeCountOrderByAggregateInput
    _max?: EventAttendeeMaxOrderByAggregateInput
    _min?: EventAttendeeMinOrderByAggregateInput
  }

  export type EventAttendeeScalarWhereWithAggregatesInput = {
    AND?: EventAttendeeScalarWhereWithAggregatesInput | EventAttendeeScalarWhereWithAggregatesInput[]
    OR?: EventAttendeeScalarWhereWithAggregatesInput[]
    NOT?: EventAttendeeScalarWhereWithAggregatesInput | EventAttendeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventAttendee"> | string
    eventId?: StringWithAggregatesFilter<"EventAttendee"> | string
    userId?: StringWithAggregatesFilter<"EventAttendee"> | string
    status?: EnumAttendeeStatusWithAggregatesFilter<"EventAttendee"> | $Enums.AttendeeStatus
    response?: StringNullableWithAggregatesFilter<"EventAttendee"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EventAttendee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EventAttendee"> | Date | string
  }

  export type FinancialTransactionWhereInput = {
    AND?: FinancialTransactionWhereInput | FinancialTransactionWhereInput[]
    OR?: FinancialTransactionWhereInput[]
    NOT?: FinancialTransactionWhereInput | FinancialTransactionWhereInput[]
    id?: StringFilter<"FinancialTransaction"> | string
    profileId?: StringFilter<"FinancialTransaction"> | string
    amount?: FloatFilter<"FinancialTransaction"> | number
    currency?: StringFilter<"FinancialTransaction"> | string
    description?: StringFilter<"FinancialTransaction"> | string
    notes?: StringNullableFilter<"FinancialTransaction"> | string | null
    type?: EnumTransactionTypeFilter<"FinancialTransaction"> | $Enums.TransactionType
    category?: StringFilter<"FinancialTransaction"> | string
    subcategory?: StringNullableFilter<"FinancialTransaction"> | string | null
    merchant?: StringNullableFilter<"FinancialTransaction"> | string | null
    location?: StringNullableFilter<"FinancialTransaction"> | string | null
    paymentMethod?: StringNullableFilter<"FinancialTransaction"> | string | null
    budgetId?: StringNullableFilter<"FinancialTransaction"> | string | null
    tags?: StringNullableListFilter<"FinancialTransaction">
    gstAmount?: FloatNullableFilter<"FinancialTransaction"> | number | null
    taxCategory?: StringNullableFilter<"FinancialTransaction"> | string | null
    transactionDate?: DateTimeFilter<"FinancialTransaction"> | Date | string
    createdAt?: DateTimeFilter<"FinancialTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"FinancialTransaction"> | Date | string
    profile?: XOR<LifeOSProfileRelationFilter, LifeOSProfileWhereInput>
    budget?: XOR<BudgetNullableRelationFilter, BudgetWhereInput> | null
  }

  export type FinancialTransactionOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    notes?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    subcategory?: SortOrderInput | SortOrder
    merchant?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    budgetId?: SortOrderInput | SortOrder
    tags?: SortOrder
    gstAmount?: SortOrderInput | SortOrder
    taxCategory?: SortOrderInput | SortOrder
    transactionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: LifeOSProfileOrderByWithRelationInput
    budget?: BudgetOrderByWithRelationInput
  }

  export type FinancialTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FinancialTransactionWhereInput | FinancialTransactionWhereInput[]
    OR?: FinancialTransactionWhereInput[]
    NOT?: FinancialTransactionWhereInput | FinancialTransactionWhereInput[]
    profileId?: StringFilter<"FinancialTransaction"> | string
    amount?: FloatFilter<"FinancialTransaction"> | number
    currency?: StringFilter<"FinancialTransaction"> | string
    description?: StringFilter<"FinancialTransaction"> | string
    notes?: StringNullableFilter<"FinancialTransaction"> | string | null
    type?: EnumTransactionTypeFilter<"FinancialTransaction"> | $Enums.TransactionType
    category?: StringFilter<"FinancialTransaction"> | string
    subcategory?: StringNullableFilter<"FinancialTransaction"> | string | null
    merchant?: StringNullableFilter<"FinancialTransaction"> | string | null
    location?: StringNullableFilter<"FinancialTransaction"> | string | null
    paymentMethod?: StringNullableFilter<"FinancialTransaction"> | string | null
    budgetId?: StringNullableFilter<"FinancialTransaction"> | string | null
    tags?: StringNullableListFilter<"FinancialTransaction">
    gstAmount?: FloatNullableFilter<"FinancialTransaction"> | number | null
    taxCategory?: StringNullableFilter<"FinancialTransaction"> | string | null
    transactionDate?: DateTimeFilter<"FinancialTransaction"> | Date | string
    createdAt?: DateTimeFilter<"FinancialTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"FinancialTransaction"> | Date | string
    profile?: XOR<LifeOSProfileRelationFilter, LifeOSProfileWhereInput>
    budget?: XOR<BudgetNullableRelationFilter, BudgetWhereInput> | null
  }, "id">

  export type FinancialTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    notes?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    subcategory?: SortOrderInput | SortOrder
    merchant?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    budgetId?: SortOrderInput | SortOrder
    tags?: SortOrder
    gstAmount?: SortOrderInput | SortOrder
    taxCategory?: SortOrderInput | SortOrder
    transactionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FinancialTransactionCountOrderByAggregateInput
    _avg?: FinancialTransactionAvgOrderByAggregateInput
    _max?: FinancialTransactionMaxOrderByAggregateInput
    _min?: FinancialTransactionMinOrderByAggregateInput
    _sum?: FinancialTransactionSumOrderByAggregateInput
  }

  export type FinancialTransactionScalarWhereWithAggregatesInput = {
    AND?: FinancialTransactionScalarWhereWithAggregatesInput | FinancialTransactionScalarWhereWithAggregatesInput[]
    OR?: FinancialTransactionScalarWhereWithAggregatesInput[]
    NOT?: FinancialTransactionScalarWhereWithAggregatesInput | FinancialTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FinancialTransaction"> | string
    profileId?: StringWithAggregatesFilter<"FinancialTransaction"> | string
    amount?: FloatWithAggregatesFilter<"FinancialTransaction"> | number
    currency?: StringWithAggregatesFilter<"FinancialTransaction"> | string
    description?: StringWithAggregatesFilter<"FinancialTransaction"> | string
    notes?: StringNullableWithAggregatesFilter<"FinancialTransaction"> | string | null
    type?: EnumTransactionTypeWithAggregatesFilter<"FinancialTransaction"> | $Enums.TransactionType
    category?: StringWithAggregatesFilter<"FinancialTransaction"> | string
    subcategory?: StringNullableWithAggregatesFilter<"FinancialTransaction"> | string | null
    merchant?: StringNullableWithAggregatesFilter<"FinancialTransaction"> | string | null
    location?: StringNullableWithAggregatesFilter<"FinancialTransaction"> | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"FinancialTransaction"> | string | null
    budgetId?: StringNullableWithAggregatesFilter<"FinancialTransaction"> | string | null
    tags?: StringNullableListFilter<"FinancialTransaction">
    gstAmount?: FloatNullableWithAggregatesFilter<"FinancialTransaction"> | number | null
    taxCategory?: StringNullableWithAggregatesFilter<"FinancialTransaction"> | string | null
    transactionDate?: DateTimeWithAggregatesFilter<"FinancialTransaction"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"FinancialTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FinancialTransaction"> | Date | string
  }

  export type BudgetWhereInput = {
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    id?: StringFilter<"Budget"> | string
    profileId?: StringFilter<"Budget"> | string
    name?: StringFilter<"Budget"> | string
    description?: StringNullableFilter<"Budget"> | string | null
    totalAmount?: FloatFilter<"Budget"> | number
    spentAmount?: FloatFilter<"Budget"> | number
    period?: EnumBudgetPeriodFilter<"Budget"> | $Enums.BudgetPeriod
    startDate?: DateTimeFilter<"Budget"> | Date | string
    endDate?: DateTimeNullableFilter<"Budget"> | Date | string | null
    categories?: JsonFilter<"Budget">
    isActive?: BoolFilter<"Budget"> | boolean
    alertThreshold?: FloatFilter<"Budget"> | number
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    profile?: XOR<LifeOSProfileRelationFilter, LifeOSProfileWhereInput>
    transactions?: FinancialTransactionListRelationFilter
  }

  export type BudgetOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    spentAmount?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    categories?: SortOrder
    isActive?: SortOrder
    alertThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: LifeOSProfileOrderByWithRelationInput
    transactions?: FinancialTransactionOrderByRelationAggregateInput
  }

  export type BudgetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    profileId?: StringFilter<"Budget"> | string
    name?: StringFilter<"Budget"> | string
    description?: StringNullableFilter<"Budget"> | string | null
    totalAmount?: FloatFilter<"Budget"> | number
    spentAmount?: FloatFilter<"Budget"> | number
    period?: EnumBudgetPeriodFilter<"Budget"> | $Enums.BudgetPeriod
    startDate?: DateTimeFilter<"Budget"> | Date | string
    endDate?: DateTimeNullableFilter<"Budget"> | Date | string | null
    categories?: JsonFilter<"Budget">
    isActive?: BoolFilter<"Budget"> | boolean
    alertThreshold?: FloatFilter<"Budget"> | number
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    profile?: XOR<LifeOSProfileRelationFilter, LifeOSProfileWhereInput>
    transactions?: FinancialTransactionListRelationFilter
  }, "id">

  export type BudgetOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    spentAmount?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    categories?: SortOrder
    isActive?: SortOrder
    alertThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BudgetCountOrderByAggregateInput
    _avg?: BudgetAvgOrderByAggregateInput
    _max?: BudgetMaxOrderByAggregateInput
    _min?: BudgetMinOrderByAggregateInput
    _sum?: BudgetSumOrderByAggregateInput
  }

  export type BudgetScalarWhereWithAggregatesInput = {
    AND?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    OR?: BudgetScalarWhereWithAggregatesInput[]
    NOT?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Budget"> | string
    profileId?: StringWithAggregatesFilter<"Budget"> | string
    name?: StringWithAggregatesFilter<"Budget"> | string
    description?: StringNullableWithAggregatesFilter<"Budget"> | string | null
    totalAmount?: FloatWithAggregatesFilter<"Budget"> | number
    spentAmount?: FloatWithAggregatesFilter<"Budget"> | number
    period?: EnumBudgetPeriodWithAggregatesFilter<"Budget"> | $Enums.BudgetPeriod
    startDate?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Budget"> | Date | string | null
    categories?: JsonWithAggregatesFilter<"Budget">
    isActive?: BoolWithAggregatesFilter<"Budget"> | boolean
    alertThreshold?: FloatWithAggregatesFilter<"Budget"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    emailVerified?: Date | string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: UserCreateskillsInput | string[]
    interests?: UserCreateinterestsInput | string[]
    stories?: StoryCreateNestedManyWithoutAuthorInput
    projects?: ProjectMemberCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    opportunities?: OpportunityApplicationCreateNestedManyWithoutUserInput
    lifeOSProfile?: LifeOSProfileCreateNestedOneWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventAttendance?: EventAttendeeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    emailVerified?: Date | string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: UserCreateskillsInput | string[]
    interests?: UserCreateinterestsInput | string[]
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    projects?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    opportunities?: OpportunityApplicationUncheckedCreateNestedManyWithoutUserInput
    lifeOSProfile?: LifeOSProfileUncheckedCreateNestedOneWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventAttendance?: EventAttendeeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: UserUpdateskillsInput | string[]
    interests?: UserUpdateinterestsInput | string[]
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    projects?: ProjectMemberUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    opportunities?: OpportunityApplicationUpdateManyWithoutUserNestedInput
    lifeOSProfile?: LifeOSProfileUpdateOneWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventAttendance?: EventAttendeeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: UserUpdateskillsInput | string[]
    interests?: UserUpdateinterestsInput | string[]
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    projects?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    opportunities?: OpportunityApplicationUncheckedUpdateManyWithoutUserNestedInput
    lifeOSProfile?: LifeOSProfileUncheckedUpdateOneWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventAttendance?: EventAttendeeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    emailVerified?: Date | string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: UserCreateskillsInput | string[]
    interests?: UserCreateinterestsInput | string[]
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: UserUpdateskillsInput | string[]
    interests?: UserUpdateinterestsInput | string[]
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: UserUpdateskillsInput | string[]
    interests?: UserUpdateinterestsInput | string[]
  }

  export type ProjectCreateInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    status?: $Enums.ProjectStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: ProjectCreatetagsInput | string[]
    location?: string | null
    region?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: string | null
    images?: ProjectCreateimagesInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    stories?: StoryCreateNestedManyWithoutProjectInput
    opportunities?: OpportunityCreateNestedManyWithoutProjectInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    status?: $Enums.ProjectStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: ProjectCreatetagsInput | string[]
    location?: string | null
    region?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: string | null
    images?: ProjectCreateimagesInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    stories?: StoryUncheckedCreateNestedManyWithoutProjectInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutProjectInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProjectUpdatetagsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProjectUpdateimagesInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    stories?: StoryUpdateManyWithoutProjectNestedInput
    opportunities?: OpportunityUpdateManyWithoutProjectNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProjectUpdatetagsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProjectUpdateimagesInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    stories?: StoryUncheckedUpdateManyWithoutProjectNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutProjectNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    status?: $Enums.ProjectStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: ProjectCreatetagsInput | string[]
    location?: string | null
    region?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: string | null
    images?: ProjectCreateimagesInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProjectUpdatetagsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProjectUpdateimagesInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProjectUpdatetagsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProjectUpdateimagesInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectMemberCreateInput = {
    id?: string
    role?: $Enums.ProjectRole
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
    project: ProjectCreateNestedOneWithoutMembersInput
  }

  export type ProjectMemberUncheckedCreateInput = {
    id?: string
    userId: string
    projectId: string
    role?: $Enums.ProjectRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateManyInput = {
    id?: string
    userId: string
    projectId: string
    role?: $Enums.ProjectRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryCreateInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    status?: $Enums.StoryStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: StoryCreatetagsInput | string[]
    coverImage?: string | null
    images?: StoryCreateimagesInput | string[]
    slug: string
    metaTitle?: string | null
    metaDescription?: string | null
    viewCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    author: UserCreateNestedOneWithoutStoriesInput
    project?: ProjectCreateNestedOneWithoutStoriesInput
    comments?: CommentCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    status?: $Enums.StoryStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: StoryCreatetagsInput | string[]
    coverImage?: string | null
    images?: StoryCreateimagesInput | string[]
    slug: string
    metaTitle?: string | null
    metaDescription?: string | null
    viewCount?: number
    shareCount?: number
    authorId: string
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: StoryUpdateimagesInput | string[]
    slug?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: UserUpdateOneRequiredWithoutStoriesNestedInput
    project?: ProjectUpdateOneWithoutStoriesNestedInput
    comments?: CommentUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: StoryUpdateimagesInput | string[]
    slug?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryCreateManyInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    status?: $Enums.StoryStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: StoryCreatetagsInput | string[]
    coverImage?: string | null
    images?: StoryCreateimagesInput | string[]
    slug: string
    metaTitle?: string | null
    metaDescription?: string | null
    viewCount?: number
    shareCount?: number
    authorId: string
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type StoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: StoryUpdateimagesInput | string[]
    slug?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: StoryUpdateimagesInput | string[]
    slug?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
    story: StoryCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    authorId: string
    storyId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    story?: StoryUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    authorId?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    authorId: string
    storyId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    authorId?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityCreateInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    type: $Enums.OpportunityType
    status?: $Enums.OpportunityStatus
    category?: string | null
    tags?: OpportunityCreatetagsInput | string[]
    skills?: OpportunityCreateskillsInput | string[]
    timeCommitment?: string | null
    location?: string | null
    remote?: boolean
    isPaid?: boolean
    compensation?: string | null
    deadline?: Date | string | null
    startDate?: Date | string | null
    duration?: string | null
    coverImage?: string | null
    images?: OpportunityCreateimagesInput | string[]
    contactEmail?: string | null
    contactPhone?: string | null
    applicationUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutOpportunitiesInput
    applications?: OpportunityApplicationCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    type: $Enums.OpportunityType
    status?: $Enums.OpportunityStatus
    category?: string | null
    tags?: OpportunityCreatetagsInput | string[]
    skills?: OpportunityCreateskillsInput | string[]
    timeCommitment?: string | null
    location?: string | null
    remote?: boolean
    isPaid?: boolean
    compensation?: string | null
    deadline?: Date | string | null
    startDate?: Date | string | null
    duration?: string | null
    coverImage?: string | null
    images?: OpportunityCreateimagesInput | string[]
    projectId?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    applicationUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: OpportunityApplicationUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: OpportunityUpdatetagsInput | string[]
    skills?: OpportunityUpdateskillsInput | string[]
    timeCommitment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    remote?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    compensation?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: OpportunityUpdateimagesInput | string[]
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutOpportunitiesNestedInput
    applications?: OpportunityApplicationUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: OpportunityUpdatetagsInput | string[]
    skills?: OpportunityUpdateskillsInput | string[]
    timeCommitment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    remote?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    compensation?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: OpportunityUpdateimagesInput | string[]
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: OpportunityApplicationUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityCreateManyInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    type: $Enums.OpportunityType
    status?: $Enums.OpportunityStatus
    category?: string | null
    tags?: OpportunityCreatetagsInput | string[]
    skills?: OpportunityCreateskillsInput | string[]
    timeCommitment?: string | null
    location?: string | null
    remote?: boolean
    isPaid?: boolean
    compensation?: string | null
    deadline?: Date | string | null
    startDate?: Date | string | null
    duration?: string | null
    coverImage?: string | null
    images?: OpportunityCreateimagesInput | string[]
    projectId?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    applicationUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: OpportunityUpdatetagsInput | string[]
    skills?: OpportunityUpdateskillsInput | string[]
    timeCommitment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    remote?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    compensation?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: OpportunityUpdateimagesInput | string[]
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: OpportunityUpdatetagsInput | string[]
    skills?: OpportunityUpdateskillsInput | string[]
    timeCommitment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    remote?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    compensation?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: OpportunityUpdateimagesInput | string[]
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityApplicationCreateInput = {
    id?: string
    message: string
    resume?: string | null
    portfolio?: string | null
    status?: $Enums.ApplicationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOpportunitiesInput
    opportunity: OpportunityCreateNestedOneWithoutApplicationsInput
  }

  export type OpportunityApplicationUncheckedCreateInput = {
    id?: string
    message: string
    resume?: string | null
    portfolio?: string | null
    status?: $Enums.ApplicationStatus
    userId: string
    opportunityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOpportunitiesNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type OpportunityApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    userId?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityApplicationCreateManyInput = {
    id?: string
    message: string
    resume?: string | null
    portfolio?: string | null
    status?: $Enums.ApplicationStatus
    userId: string
    opportunityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    userId?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageViewCreateInput = {
    id?: string
    path: string
    userAgent?: string | null
    ipAddress?: string | null
    referer?: string | null
    sessionId?: string | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type PageViewUncheckedCreateInput = {
    id?: string
    path: string
    userAgent?: string | null
    ipAddress?: string | null
    referer?: string | null
    sessionId?: string | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type PageViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageViewCreateManyInput = {
    id?: string
    path: string
    userAgent?: string | null
    ipAddress?: string | null
    referer?: string | null
    sessionId?: string | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type PageViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    referer?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryCreateInput = {
    id?: string
    query: string
    results?: number
    userId?: string | null
    createdAt?: Date | string
  }

  export type SearchQueryUncheckedCreateInput = {
    id?: string
    query: string
    results?: number
    userId?: string | null
    createdAt?: Date | string
  }

  export type SearchQueryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    results?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    results?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryCreateManyInput = {
    id?: string
    query: string
    results?: number
    userId?: string | null
    createdAt?: Date | string
  }

  export type SearchQueryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    results?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    results?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateInput = {
    id: string
    value: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type SettingUncheckedCreateInput = {
    id: string
    value: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type SettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateManyInput = {
    id: string
    value: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type SettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    alt?: string | null
    caption?: string | null
    width?: number | null
    height?: number | null
    duration?: number | null
    uploadedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    alt?: string | null
    caption?: string | null
    width?: number | null
    height?: number | null
    duration?: number | null
    uploadedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateManyInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    alt?: string | null
    caption?: string | null
    width?: number | null
    height?: number | null
    duration?: number | null
    uploadedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LifeOSProfileCreateInput = {
    id?: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLifeOSProfileInput
    habits?: HabitCreateNestedManyWithoutProfileInput
    goals?: GoalCreateNestedManyWithoutProfileInput
    moodEntries?: MoodEntryCreateNestedManyWithoutProfileInput
    meditations?: MeditationSessionCreateNestedManyWithoutProfileInput
    journals?: JournalCreateNestedManyWithoutProfileInput
    transactions?: FinancialTransactionCreateNestedManyWithoutProfileInput
    budgets?: BudgetCreateNestedManyWithoutProfileInput
  }

  export type LifeOSProfileUncheckedCreateInput = {
    id?: string
    userId: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    habits?: HabitUncheckedCreateNestedManyWithoutProfileInput
    goals?: GoalUncheckedCreateNestedManyWithoutProfileInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutProfileInput
    meditations?: MeditationSessionUncheckedCreateNestedManyWithoutProfileInput
    journals?: JournalUncheckedCreateNestedManyWithoutProfileInput
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutProfileInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProfileInput
  }

  export type LifeOSProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLifeOSProfileNestedInput
    habits?: HabitUpdateManyWithoutProfileNestedInput
    goals?: GoalUpdateManyWithoutProfileNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutProfileNestedInput
    meditations?: MeditationSessionUpdateManyWithoutProfileNestedInput
    journals?: JournalUpdateManyWithoutProfileNestedInput
    transactions?: FinancialTransactionUpdateManyWithoutProfileNestedInput
    budgets?: BudgetUpdateManyWithoutProfileNestedInput
  }

  export type LifeOSProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habits?: HabitUncheckedUpdateManyWithoutProfileNestedInput
    goals?: GoalUncheckedUpdateManyWithoutProfileNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutProfileNestedInput
    meditations?: MeditationSessionUncheckedUpdateManyWithoutProfileNestedInput
    journals?: JournalUncheckedUpdateManyWithoutProfileNestedInput
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutProfileNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type LifeOSProfileCreateManyInput = {
    id?: string
    userId: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LifeOSProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LifeOSProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitCreateInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    frequency?: $Enums.HabitFrequency
    targetValue?: number
    unit?: string | null
    color?: string | null
    icon?: string | null
    reminder?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: LifeOSProfileCreateNestedOneWithoutHabitsInput
    completions?: HabitCompletionCreateNestedManyWithoutHabitInput
  }

  export type HabitUncheckedCreateInput = {
    id?: string
    profileId: string
    name: string
    description?: string | null
    category?: string | null
    frequency?: $Enums.HabitFrequency
    targetValue?: number
    unit?: string | null
    color?: string | null
    icon?: string | null
    reminder?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completions?: HabitCompletionUncheckedCreateNestedManyWithoutHabitInput
  }

  export type HabitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumHabitFrequencyFieldUpdateOperationsInput | $Enums.HabitFrequency
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    reminder?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: LifeOSProfileUpdateOneRequiredWithoutHabitsNestedInput
    completions?: HabitCompletionUpdateManyWithoutHabitNestedInput
  }

  export type HabitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumHabitFrequencyFieldUpdateOperationsInput | $Enums.HabitFrequency
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    reminder?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completions?: HabitCompletionUncheckedUpdateManyWithoutHabitNestedInput
  }

  export type HabitCreateManyInput = {
    id?: string
    profileId: string
    name: string
    description?: string | null
    category?: string | null
    frequency?: $Enums.HabitFrequency
    targetValue?: number
    unit?: string | null
    color?: string | null
    icon?: string | null
    reminder?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumHabitFrequencyFieldUpdateOperationsInput | $Enums.HabitFrequency
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    reminder?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumHabitFrequencyFieldUpdateOperationsInput | $Enums.HabitFrequency
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    reminder?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitCompletionCreateInput = {
    id?: string
    completedAt?: Date | string
    value?: number
    notes?: string | null
    satisfaction?: number | null
    difficulty?: number | null
    habit: HabitCreateNestedOneWithoutCompletionsInput
  }

  export type HabitCompletionUncheckedCreateInput = {
    id?: string
    habitId: string
    completedAt?: Date | string
    value?: number
    notes?: string | null
    satisfaction?: number | null
    difficulty?: number | null
  }

  export type HabitCompletionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    habit?: HabitUpdateOneRequiredWithoutCompletionsNestedInput
  }

  export type HabitCompletionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    habitId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HabitCompletionCreateManyInput = {
    id?: string
    habitId: string
    completedAt?: Date | string
    value?: number
    notes?: string | null
    satisfaction?: number | null
    difficulty?: number | null
  }

  export type HabitCompletionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HabitCompletionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    habitId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GoalCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    startDate?: Date | string
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.GoalStatus
    priority?: $Enums.Priority
    progress?: number
    motivation?: string | null
    visualisation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: LifeOSProfileCreateNestedOneWithoutGoalsInput
    milestones?: GoalMilestoneCreateNestedManyWithoutGoalInput
    updates?: GoalUpdateCreateNestedManyWithoutGoalInput
  }

  export type GoalUncheckedCreateInput = {
    id?: string
    profileId: string
    title: string
    description?: string | null
    category?: string | null
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    startDate?: Date | string
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.GoalStatus
    priority?: $Enums.Priority
    progress?: number
    motivation?: string | null
    visualisation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: GoalMilestoneUncheckedCreateNestedManyWithoutGoalInput
    updates?: GoalUpdateUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    progress?: FloatFieldUpdateOperationsInput | number
    motivation?: NullableStringFieldUpdateOperationsInput | string | null
    visualisation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: LifeOSProfileUpdateOneRequiredWithoutGoalsNestedInput
    milestones?: GoalMilestoneUpdateManyWithoutGoalNestedInput
    updates?: GoalUpdateUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    progress?: FloatFieldUpdateOperationsInput | number
    motivation?: NullableStringFieldUpdateOperationsInput | string | null
    visualisation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: GoalMilestoneUncheckedUpdateManyWithoutGoalNestedInput
    updates?: GoalUpdateUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type GoalCreateManyInput = {
    id?: string
    profileId: string
    title: string
    description?: string | null
    category?: string | null
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    startDate?: Date | string
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.GoalStatus
    priority?: $Enums.Priority
    progress?: number
    motivation?: string | null
    visualisation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    progress?: FloatFieldUpdateOperationsInput | number
    motivation?: NullableStringFieldUpdateOperationsInput | string | null
    visualisation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    progress?: FloatFieldUpdateOperationsInput | number
    motivation?: NullableStringFieldUpdateOperationsInput | string | null
    visualisation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalMilestoneCreateInput = {
    id?: string
    title: string
    description?: string | null
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    targetValue?: number | null
    currentValue?: number
    status?: $Enums.MilestoneStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    goal: GoalCreateNestedOneWithoutMilestonesInput
  }

  export type GoalMilestoneUncheckedCreateInput = {
    id?: string
    goalId: string
    title: string
    description?: string | null
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    targetValue?: number | null
    currentValue?: number
    status?: $Enums.MilestoneStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalMilestoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: GoalUpdateOneRequiredWithoutMilestonesNestedInput
  }

  export type GoalMilestoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalMilestoneCreateManyInput = {
    id?: string
    goalId: string
    title: string
    description?: string | null
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    targetValue?: number | null
    currentValue?: number
    status?: $Enums.MilestoneStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalMilestoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalMilestoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUpdateCreateInput = {
    id?: string
    content: string
    value?: number | null
    createdAt?: Date | string
    goal: GoalCreateNestedOneWithoutUpdatesInput
  }

  export type GoalUpdateUncheckedCreateInput = {
    id?: string
    goalId: string
    content: string
    value?: number | null
    createdAt?: Date | string
  }

  export type GoalUpdateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: GoalUpdateOneRequiredWithoutUpdatesNestedInput
  }

  export type GoalUpdateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUpdateCreateManyInput = {
    id?: string
    goalId: string
    content: string
    value?: number | null
    createdAt?: Date | string
  }

  export type GoalUpdateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUpdateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeditationSessionCreateInput = {
    id?: string
    duration: number
    technique?: string | null
    guidedSession?: boolean
    guideUrl?: string | null
    rating?: number | null
    notes?: string | null
    mood?: string | null
    location?: string | null
    distractions?: string | null
    createdAt?: Date | string
    profile: LifeOSProfileCreateNestedOneWithoutMeditationsInput
  }

  export type MeditationSessionUncheckedCreateInput = {
    id?: string
    profileId: string
    duration: number
    technique?: string | null
    guidedSession?: boolean
    guideUrl?: string | null
    rating?: number | null
    notes?: string | null
    mood?: string | null
    location?: string | null
    distractions?: string | null
    createdAt?: Date | string
  }

  export type MeditationSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    technique?: NullableStringFieldUpdateOperationsInput | string | null
    guidedSession?: BoolFieldUpdateOperationsInput | boolean
    guideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distractions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: LifeOSProfileUpdateOneRequiredWithoutMeditationsNestedInput
  }

  export type MeditationSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    technique?: NullableStringFieldUpdateOperationsInput | string | null
    guidedSession?: BoolFieldUpdateOperationsInput | boolean
    guideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distractions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeditationSessionCreateManyInput = {
    id?: string
    profileId: string
    duration: number
    technique?: string | null
    guidedSession?: boolean
    guideUrl?: string | null
    rating?: number | null
    notes?: string | null
    mood?: string | null
    location?: string | null
    distractions?: string | null
    createdAt?: Date | string
  }

  export type MeditationSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    technique?: NullableStringFieldUpdateOperationsInput | string | null
    guidedSession?: BoolFieldUpdateOperationsInput | boolean
    guideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distractions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeditationSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    technique?: NullableStringFieldUpdateOperationsInput | string | null
    guidedSession?: BoolFieldUpdateOperationsInput | boolean
    guideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distractions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodEntryCreateInput = {
    id?: string
    mood: string
    intensity: number
    emotions?: MoodEntryCreateemotionsInput | string[]
    activities?: MoodEntryCreateactivitiesInput | string[]
    location?: string | null
    weather?: string | null
    notes?: string | null
    triggers?: string | null
    gratitude?: string | null
    recordedAt?: Date | string
    createdAt?: Date | string
    profile: LifeOSProfileCreateNestedOneWithoutMoodEntriesInput
  }

  export type MoodEntryUncheckedCreateInput = {
    id?: string
    profileId: string
    mood: string
    intensity: number
    emotions?: MoodEntryCreateemotionsInput | string[]
    activities?: MoodEntryCreateactivitiesInput | string[]
    location?: string | null
    weather?: string | null
    notes?: string | null
    triggers?: string | null
    gratitude?: string | null
    recordedAt?: Date | string
    createdAt?: Date | string
  }

  export type MoodEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    intensity?: IntFieldUpdateOperationsInput | number
    emotions?: MoodEntryUpdateemotionsInput | string[]
    activities?: MoodEntryUpdateactivitiesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    triggers?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: LifeOSProfileUpdateOneRequiredWithoutMoodEntriesNestedInput
  }

  export type MoodEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    intensity?: IntFieldUpdateOperationsInput | number
    emotions?: MoodEntryUpdateemotionsInput | string[]
    activities?: MoodEntryUpdateactivitiesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    triggers?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodEntryCreateManyInput = {
    id?: string
    profileId: string
    mood: string
    intensity: number
    emotions?: MoodEntryCreateemotionsInput | string[]
    activities?: MoodEntryCreateactivitiesInput | string[]
    location?: string | null
    weather?: string | null
    notes?: string | null
    triggers?: string | null
    gratitude?: string | null
    recordedAt?: Date | string
    createdAt?: Date | string
  }

  export type MoodEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    intensity?: IntFieldUpdateOperationsInput | number
    emotions?: MoodEntryUpdateemotionsInput | string[]
    activities?: MoodEntryUpdateactivitiesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    triggers?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    intensity?: IntFieldUpdateOperationsInput | number
    emotions?: MoodEntryUpdateemotionsInput | string[]
    activities?: MoodEntryUpdateactivitiesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    triggers?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalCreateInput = {
    id?: string
    title?: string | null
    content: string
    mood?: string | null
    tags?: JournalCreatetagsInput | string[]
    isPrivate?: boolean
    template?: string | null
    prompts?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: LifeOSProfileCreateNestedOneWithoutJournalsInput
  }

  export type JournalUncheckedCreateInput = {
    id?: string
    profileId: string
    title?: string | null
    content: string
    mood?: string | null
    tags?: JournalCreatetagsInput | string[]
    isPrivate?: boolean
    template?: string | null
    prompts?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JournalUpdatetagsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    template?: NullableStringFieldUpdateOperationsInput | string | null
    prompts?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: LifeOSProfileUpdateOneRequiredWithoutJournalsNestedInput
  }

  export type JournalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JournalUpdatetagsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    template?: NullableStringFieldUpdateOperationsInput | string | null
    prompts?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalCreateManyInput = {
    id?: string
    profileId: string
    title?: string | null
    content: string
    mood?: string | null
    tags?: JournalCreatetagsInput | string[]
    isPrivate?: boolean
    template?: string | null
    prompts?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JournalUpdatetagsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    template?: NullableStringFieldUpdateOperationsInput | string | null
    prompts?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JournalUpdatetagsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    template?: NullableStringFieldUpdateOperationsInput | string | null
    prompts?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventCreateInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    isAllDay?: boolean
    location?: string | null
    url?: string | null
    category?: string | null
    color?: string | null
    isRecurring?: boolean
    recurrenceRule?: string | null
    parentEventId?: string | null
    eventType?: $Enums.EventType
    visibility?: $Enums.Visibility
    communityEvent?: boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCalendarEventsInput
    project?: ProjectCreateNestedOneWithoutCalendarEventsInput
    attendees?: EventAttendeeCreateNestedManyWithoutEventInput
  }

  export type CalendarEventUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    isAllDay?: boolean
    location?: string | null
    url?: string | null
    category?: string | null
    color?: string | null
    isRecurring?: boolean
    recurrenceRule?: string | null
    parentEventId?: string | null
    eventType?: $Enums.EventType
    visibility?: $Enums.Visibility
    projectId?: string | null
    communityEvent?: boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    attendees?: EventAttendeeUncheckedCreateNestedManyWithoutEventInput
  }

  export type CalendarEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    parentEventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    communityEvent?: BoolFieldUpdateOperationsInput | boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCalendarEventsNestedInput
    project?: ProjectUpdateOneWithoutCalendarEventsNestedInput
    attendees?: EventAttendeeUpdateManyWithoutEventNestedInput
  }

  export type CalendarEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    parentEventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    communityEvent?: BoolFieldUpdateOperationsInput | boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendees?: EventAttendeeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type CalendarEventCreateManyInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    isAllDay?: boolean
    location?: string | null
    url?: string | null
    category?: string | null
    color?: string | null
    isRecurring?: boolean
    recurrenceRule?: string | null
    parentEventId?: string | null
    eventType?: $Enums.EventType
    visibility?: $Enums.Visibility
    projectId?: string | null
    communityEvent?: boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    parentEventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    communityEvent?: BoolFieldUpdateOperationsInput | boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    parentEventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    communityEvent?: BoolFieldUpdateOperationsInput | boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventAttendeeCreateInput = {
    id?: string
    status?: $Enums.AttendeeStatus
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: CalendarEventCreateNestedOneWithoutAttendeesInput
    user: UserCreateNestedOneWithoutEventAttendanceInput
  }

  export type EventAttendeeUncheckedCreateInput = {
    id?: string
    eventId: string
    userId: string
    status?: $Enums.AttendeeStatus
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventAttendeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendeeStatusFieldUpdateOperationsInput | $Enums.AttendeeStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: CalendarEventUpdateOneRequiredWithoutAttendeesNestedInput
    user?: UserUpdateOneRequiredWithoutEventAttendanceNestedInput
  }

  export type EventAttendeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendeeStatusFieldUpdateOperationsInput | $Enums.AttendeeStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventAttendeeCreateManyInput = {
    id?: string
    eventId: string
    userId: string
    status?: $Enums.AttendeeStatus
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventAttendeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendeeStatusFieldUpdateOperationsInput | $Enums.AttendeeStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventAttendeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendeeStatusFieldUpdateOperationsInput | $Enums.AttendeeStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialTransactionCreateInput = {
    id?: string
    amount: number
    currency?: string
    description: string
    notes?: string | null
    type: $Enums.TransactionType
    category: string
    subcategory?: string | null
    merchant?: string | null
    location?: string | null
    paymentMethod?: string | null
    tags?: FinancialTransactionCreatetagsInput | string[]
    gstAmount?: number | null
    taxCategory?: string | null
    transactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: LifeOSProfileCreateNestedOneWithoutTransactionsInput
    budget?: BudgetCreateNestedOneWithoutTransactionsInput
  }

  export type FinancialTransactionUncheckedCreateInput = {
    id?: string
    profileId: string
    amount: number
    currency?: string
    description: string
    notes?: string | null
    type: $Enums.TransactionType
    category: string
    subcategory?: string | null
    merchant?: string | null
    location?: string | null
    paymentMethod?: string | null
    budgetId?: string | null
    tags?: FinancialTransactionCreatetagsInput | string[]
    gstAmount?: number | null
    taxCategory?: string | null
    transactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: FinancialTransactionUpdatetagsInput | string[]
    gstAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxCategory?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: LifeOSProfileUpdateOneRequiredWithoutTransactionsNestedInput
    budget?: BudgetUpdateOneWithoutTransactionsNestedInput
  }

  export type FinancialTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    budgetId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: FinancialTransactionUpdatetagsInput | string[]
    gstAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxCategory?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialTransactionCreateManyInput = {
    id?: string
    profileId: string
    amount: number
    currency?: string
    description: string
    notes?: string | null
    type: $Enums.TransactionType
    category: string
    subcategory?: string | null
    merchant?: string | null
    location?: string | null
    paymentMethod?: string | null
    budgetId?: string | null
    tags?: FinancialTransactionCreatetagsInput | string[]
    gstAmount?: number | null
    taxCategory?: string | null
    transactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: FinancialTransactionUpdatetagsInput | string[]
    gstAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxCategory?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    budgetId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: FinancialTransactionUpdatetagsInput | string[]
    gstAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxCategory?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCreateInput = {
    id?: string
    name: string
    description?: string | null
    totalAmount: number
    spentAmount?: number
    period?: $Enums.BudgetPeriod
    startDate?: Date | string
    endDate?: Date | string | null
    categories?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    alertThreshold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: LifeOSProfileCreateNestedOneWithoutBudgetsInput
    transactions?: FinancialTransactionCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateInput = {
    id?: string
    profileId: string
    name: string
    description?: string | null
    totalAmount: number
    spentAmount?: number
    period?: $Enums.BudgetPeriod
    startDate?: Date | string
    endDate?: Date | string | null
    categories?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    alertThreshold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: LifeOSProfileUpdateOneRequiredWithoutBudgetsNestedInput
    transactions?: FinancialTransactionUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetCreateManyInput = {
    id?: string
    profileId: string
    name: string
    description?: string | null
    totalAmount: number
    spentAmount?: number
    period?: $Enums.BudgetPeriod
    startDate?: Date | string
    endDate?: Date | string | null
    categories?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    alertThreshold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type StoryListRelationFilter = {
    every?: StoryWhereInput
    some?: StoryWhereInput
    none?: StoryWhereInput
  }

  export type ProjectMemberListRelationFilter = {
    every?: ProjectMemberWhereInput
    some?: ProjectMemberWhereInput
    none?: ProjectMemberWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type OpportunityApplicationListRelationFilter = {
    every?: OpportunityApplicationWhereInput
    some?: OpportunityApplicationWhereInput
    none?: OpportunityApplicationWhereInput
  }

  export type LifeOSProfileNullableRelationFilter = {
    is?: LifeOSProfileWhereInput | null
    isNot?: LifeOSProfileWhereInput | null
  }

  export type CalendarEventListRelationFilter = {
    every?: CalendarEventWhereInput
    some?: CalendarEventWhereInput
    none?: CalendarEventWhereInput
  }

  export type EventAttendeeListRelationFilter = {
    every?: EventAttendeeWhereInput
    some?: EventAttendeeWhereInput
    none?: EventAttendeeWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type StoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpportunityApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventAttendeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    website?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    skills?: SortOrder
    interests?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    website?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    website?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type EnumVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityFilter<$PrismaModel> | $Enums.Visibility
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type OpportunityListRelationFilter = {
    every?: OpportunityWhereInput
    some?: OpportunityWhereInput
    none?: OpportunityWhereInput
  }

  export type OpportunityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    location?: SortOrder
    region?: SortOrder
    coordinates?: SortOrder
    coverImage?: SortOrder
    images?: SortOrder
    documents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    category?: SortOrder
    location?: SortOrder
    region?: SortOrder
    coverImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    category?: SortOrder
    location?: SortOrder
    region?: SortOrder
    coverImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type EnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type EnumVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.Visibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisibilityFilter<$PrismaModel>
    _max?: NestedEnumVisibilityFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumProjectRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleFilter<$PrismaModel> | $Enums.ProjectRole
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectMemberUserIdProjectIdCompoundUniqueInput = {
    userId: string
    projectId: string
  }

  export type ProjectMemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    projectId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProjectRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleWithAggregatesFilter<$PrismaModel> | $Enums.ProjectRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectRoleFilter<$PrismaModel>
    _max?: NestedEnumProjectRoleFilter<$PrismaModel>
  }

  export type EnumStoryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryStatus | EnumStoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoryStatus[] | ListEnumStoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryStatus[] | ListEnumStoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryStatusFilter<$PrismaModel> | $Enums.StoryStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ProjectNullableRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type StoryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    coverImage?: SortOrder
    images?: SortOrder
    slug?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type StoryAvgOrderByAggregateInput = {
    viewCount?: SortOrder
    shareCount?: SortOrder
  }

  export type StoryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    category?: SortOrder
    coverImage?: SortOrder
    slug?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type StoryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    category?: SortOrder
    coverImage?: SortOrder
    slug?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    viewCount?: SortOrder
    shareCount?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type StorySumOrderByAggregateInput = {
    viewCount?: SortOrder
    shareCount?: SortOrder
  }

  export type EnumStoryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryStatus | EnumStoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoryStatus[] | ListEnumStoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryStatus[] | ListEnumStoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryStatusWithAggregatesFilter<$PrismaModel> | $Enums.StoryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoryStatusFilter<$PrismaModel>
    _max?: NestedEnumStoryStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumCommentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentStatus | EnumCommentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommentStatusFilter<$PrismaModel> | $Enums.CommentStatus
  }

  export type StoryRelationFilter = {
    is?: StoryWhereInput
    isNot?: StoryWhereInput
  }

  export type CommentNullableRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    storyId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    storyId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    storyId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCommentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentStatus | EnumCommentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommentStatusWithAggregatesFilter<$PrismaModel> | $Enums.CommentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommentStatusFilter<$PrismaModel>
    _max?: NestedEnumCommentStatusFilter<$PrismaModel>
  }

  export type EnumOpportunityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityType | EnumOpportunityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityType[] | ListEnumOpportunityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityType[] | ListEnumOpportunityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityTypeFilter<$PrismaModel> | $Enums.OpportunityType
  }

  export type EnumOpportunityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityStatus | EnumOpportunityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityStatusFilter<$PrismaModel> | $Enums.OpportunityStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type OpportunityCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    type?: SortOrder
    status?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    skills?: SortOrder
    timeCommitment?: SortOrder
    location?: SortOrder
    remote?: SortOrder
    isPaid?: SortOrder
    compensation?: SortOrder
    deadline?: SortOrder
    startDate?: SortOrder
    duration?: SortOrder
    coverImage?: SortOrder
    images?: SortOrder
    projectId?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    applicationUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpportunityMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    type?: SortOrder
    status?: SortOrder
    category?: SortOrder
    timeCommitment?: SortOrder
    location?: SortOrder
    remote?: SortOrder
    isPaid?: SortOrder
    compensation?: SortOrder
    deadline?: SortOrder
    startDate?: SortOrder
    duration?: SortOrder
    coverImage?: SortOrder
    projectId?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    applicationUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpportunityMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    type?: SortOrder
    status?: SortOrder
    category?: SortOrder
    timeCommitment?: SortOrder
    location?: SortOrder
    remote?: SortOrder
    isPaid?: SortOrder
    compensation?: SortOrder
    deadline?: SortOrder
    startDate?: SortOrder
    duration?: SortOrder
    coverImage?: SortOrder
    projectId?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    applicationUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOpportunityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityType | EnumOpportunityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityType[] | ListEnumOpportunityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityType[] | ListEnumOpportunityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityTypeWithAggregatesFilter<$PrismaModel> | $Enums.OpportunityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOpportunityTypeFilter<$PrismaModel>
    _max?: NestedEnumOpportunityTypeFilter<$PrismaModel>
  }

  export type EnumOpportunityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityStatus | EnumOpportunityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityStatusWithAggregatesFilter<$PrismaModel> | $Enums.OpportunityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOpportunityStatusFilter<$PrismaModel>
    _max?: NestedEnumOpportunityStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type OpportunityRelationFilter = {
    is?: OpportunityWhereInput
    isNot?: OpportunityWhereInput
  }

  export type OpportunityApplicationUserIdOpportunityIdCompoundUniqueInput = {
    userId: string
    opportunityId: string
  }

  export type OpportunityApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    resume?: SortOrder
    portfolio?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    opportunityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpportunityApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    resume?: SortOrder
    portfolio?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    opportunityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpportunityApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    resume?: SortOrder
    portfolio?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    opportunityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type PageViewCountOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    referer?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PageViewMaxOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    referer?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PageViewMinOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    referer?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchQueryCountOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    results?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchQueryAvgOrderByAggregateInput = {
    results?: SortOrder
  }

  export type SearchQueryMaxOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    results?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchQueryMinOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    results?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchQuerySumOrderByAggregateInput = {
    results?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    width?: SortOrder
    height?: SortOrder
    duration?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaAvgOrderByAggregateInput = {
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    duration?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    width?: SortOrder
    height?: SortOrder
    duration?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    width?: SortOrder
    height?: SortOrder
    duration?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaSumOrderByAggregateInput = {
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    duration?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type HabitListRelationFilter = {
    every?: HabitWhereInput
    some?: HabitWhereInput
    none?: HabitWhereInput
  }

  export type GoalListRelationFilter = {
    every?: GoalWhereInput
    some?: GoalWhereInput
    none?: GoalWhereInput
  }

  export type MoodEntryListRelationFilter = {
    every?: MoodEntryWhereInput
    some?: MoodEntryWhereInput
    none?: MoodEntryWhereInput
  }

  export type MeditationSessionListRelationFilter = {
    every?: MeditationSessionWhereInput
    some?: MeditationSessionWhereInput
    none?: MeditationSessionWhereInput
  }

  export type JournalListRelationFilter = {
    every?: JournalWhereInput
    some?: JournalWhereInput
    none?: JournalWhereInput
  }

  export type FinancialTransactionListRelationFilter = {
    every?: FinancialTransactionWhereInput
    some?: FinancialTransactionWhereInput
    none?: FinancialTransactionWhereInput
  }

  export type BudgetListRelationFilter = {
    every?: BudgetWhereInput
    some?: BudgetWhereInput
    none?: BudgetWhereInput
  }

  export type HabitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GoalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MoodEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeditationSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinancialTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LifeOSProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timezone?: SortOrder
    locale?: SortOrder
    currency?: SortOrder
    themePreference?: SortOrder
    notificationSettings?: SortOrder
    privacySettings?: SortOrder
    extractiveSystemsTargeting?: SortOrder
    communityControlEnabled?: SortOrder
    dataResidencyPreference?: SortOrder
    onboardingCompleted?: SortOrder
    lastActiveAt?: SortOrder
    activationDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LifeOSProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timezone?: SortOrder
    locale?: SortOrder
    currency?: SortOrder
    themePreference?: SortOrder
    extractiveSystemsTargeting?: SortOrder
    communityControlEnabled?: SortOrder
    dataResidencyPreference?: SortOrder
    onboardingCompleted?: SortOrder
    lastActiveAt?: SortOrder
    activationDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LifeOSProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timezone?: SortOrder
    locale?: SortOrder
    currency?: SortOrder
    themePreference?: SortOrder
    extractiveSystemsTargeting?: SortOrder
    communityControlEnabled?: SortOrder
    dataResidencyPreference?: SortOrder
    onboardingCompleted?: SortOrder
    lastActiveAt?: SortOrder
    activationDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumHabitFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.HabitFrequency | EnumHabitFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.HabitFrequency[] | ListEnumHabitFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.HabitFrequency[] | ListEnumHabitFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumHabitFrequencyFilter<$PrismaModel> | $Enums.HabitFrequency
  }

  export type LifeOSProfileRelationFilter = {
    is?: LifeOSProfileWhereInput
    isNot?: LifeOSProfileWhereInput
  }

  export type HabitCompletionListRelationFilter = {
    every?: HabitCompletionWhereInput
    some?: HabitCompletionWhereInput
    none?: HabitCompletionWhereInput
  }

  export type HabitCompletionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HabitCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    frequency?: SortOrder
    targetValue?: SortOrder
    unit?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    reminder?: SortOrder
    isActive?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastCompletedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HabitAvgOrderByAggregateInput = {
    targetValue?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
  }

  export type HabitMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    frequency?: SortOrder
    targetValue?: SortOrder
    unit?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastCompletedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HabitMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    frequency?: SortOrder
    targetValue?: SortOrder
    unit?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastCompletedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HabitSumOrderByAggregateInput = {
    targetValue?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
  }

  export type EnumHabitFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HabitFrequency | EnumHabitFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.HabitFrequency[] | ListEnumHabitFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.HabitFrequency[] | ListEnumHabitFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumHabitFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.HabitFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHabitFrequencyFilter<$PrismaModel>
    _max?: NestedEnumHabitFrequencyFilter<$PrismaModel>
  }

  export type HabitRelationFilter = {
    is?: HabitWhereInput
    isNot?: HabitWhereInput
  }

  export type HabitCompletionHabitIdCompletedAtCompoundUniqueInput = {
    habitId: string
    completedAt: Date | string
  }

  export type HabitCompletionCountOrderByAggregateInput = {
    id?: SortOrder
    habitId?: SortOrder
    completedAt?: SortOrder
    value?: SortOrder
    notes?: SortOrder
    satisfaction?: SortOrder
    difficulty?: SortOrder
  }

  export type HabitCompletionAvgOrderByAggregateInput = {
    value?: SortOrder
    satisfaction?: SortOrder
    difficulty?: SortOrder
  }

  export type HabitCompletionMaxOrderByAggregateInput = {
    id?: SortOrder
    habitId?: SortOrder
    completedAt?: SortOrder
    value?: SortOrder
    notes?: SortOrder
    satisfaction?: SortOrder
    difficulty?: SortOrder
  }

  export type HabitCompletionMinOrderByAggregateInput = {
    id?: SortOrder
    habitId?: SortOrder
    completedAt?: SortOrder
    value?: SortOrder
    notes?: SortOrder
    satisfaction?: SortOrder
    difficulty?: SortOrder
  }

  export type HabitCompletionSumOrderByAggregateInput = {
    value?: SortOrder
    satisfaction?: SortOrder
    difficulty?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumGoalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalStatus | EnumGoalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalStatusFilter<$PrismaModel> | $Enums.GoalStatus
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type GoalMilestoneListRelationFilter = {
    every?: GoalMilestoneWhereInput
    some?: GoalMilestoneWhereInput
    none?: GoalMilestoneWhereInput
  }

  export type GoalUpdateListRelationFilter = {
    every?: GoalUpdateWhereInput
    some?: GoalUpdateWhereInput
    none?: GoalUpdateWhereInput
  }

  export type GoalMilestoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GoalUpdateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GoalCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    unit?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    motivation?: SortOrder
    visualisation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalAvgOrderByAggregateInput = {
    targetValue?: SortOrder
    currentValue?: SortOrder
    progress?: SortOrder
  }

  export type GoalMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    unit?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    motivation?: SortOrder
    visualisation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    unit?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    motivation?: SortOrder
    visualisation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalSumOrderByAggregateInput = {
    targetValue?: SortOrder
    currentValue?: SortOrder
    progress?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumGoalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalStatus | EnumGoalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalStatusWithAggregatesFilter<$PrismaModel> | $Enums.GoalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGoalStatusFilter<$PrismaModel>
    _max?: NestedEnumGoalStatusFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type EnumMilestoneStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MilestoneStatus | EnumMilestoneStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMilestoneStatusFilter<$PrismaModel> | $Enums.MilestoneStatus
  }

  export type GoalRelationFilter = {
    is?: GoalWhereInput
    isNot?: GoalWhereInput
  }

  export type GoalMilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    targetDate?: SortOrder
    completedAt?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalMilestoneAvgOrderByAggregateInput = {
    targetValue?: SortOrder
    currentValue?: SortOrder
  }

  export type GoalMilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    targetDate?: SortOrder
    completedAt?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalMilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    targetDate?: SortOrder
    completedAt?: SortOrder
    targetValue?: SortOrder
    currentValue?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalMilestoneSumOrderByAggregateInput = {
    targetValue?: SortOrder
    currentValue?: SortOrder
  }

  export type EnumMilestoneStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MilestoneStatus | EnumMilestoneStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMilestoneStatusWithAggregatesFilter<$PrismaModel> | $Enums.MilestoneStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMilestoneStatusFilter<$PrismaModel>
    _max?: NestedEnumMilestoneStatusFilter<$PrismaModel>
  }

  export type GoalUpdateCountOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    content?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type GoalUpdateAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type GoalUpdateMaxOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    content?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type GoalUpdateMinOrderByAggregateInput = {
    id?: SortOrder
    goalId?: SortOrder
    content?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type GoalUpdateSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type MeditationSessionCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    duration?: SortOrder
    technique?: SortOrder
    guidedSession?: SortOrder
    guideUrl?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    mood?: SortOrder
    location?: SortOrder
    distractions?: SortOrder
    createdAt?: SortOrder
  }

  export type MeditationSessionAvgOrderByAggregateInput = {
    duration?: SortOrder
    rating?: SortOrder
  }

  export type MeditationSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    duration?: SortOrder
    technique?: SortOrder
    guidedSession?: SortOrder
    guideUrl?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    mood?: SortOrder
    location?: SortOrder
    distractions?: SortOrder
    createdAt?: SortOrder
  }

  export type MeditationSessionMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    duration?: SortOrder
    technique?: SortOrder
    guidedSession?: SortOrder
    guideUrl?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    mood?: SortOrder
    location?: SortOrder
    distractions?: SortOrder
    createdAt?: SortOrder
  }

  export type MeditationSessionSumOrderByAggregateInput = {
    duration?: SortOrder
    rating?: SortOrder
  }

  export type MoodEntryCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    mood?: SortOrder
    intensity?: SortOrder
    emotions?: SortOrder
    activities?: SortOrder
    location?: SortOrder
    weather?: SortOrder
    notes?: SortOrder
    triggers?: SortOrder
    gratitude?: SortOrder
    recordedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MoodEntryAvgOrderByAggregateInput = {
    intensity?: SortOrder
  }

  export type MoodEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    mood?: SortOrder
    intensity?: SortOrder
    location?: SortOrder
    weather?: SortOrder
    notes?: SortOrder
    triggers?: SortOrder
    gratitude?: SortOrder
    recordedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MoodEntryMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    mood?: SortOrder
    intensity?: SortOrder
    location?: SortOrder
    weather?: SortOrder
    notes?: SortOrder
    triggers?: SortOrder
    gratitude?: SortOrder
    recordedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MoodEntrySumOrderByAggregateInput = {
    intensity?: SortOrder
  }

  export type JournalCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    mood?: SortOrder
    tags?: SortOrder
    isPrivate?: SortOrder
    template?: SortOrder
    prompts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    mood?: SortOrder
    isPrivate?: SortOrder
    template?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    mood?: SortOrder
    isPrivate?: SortOrder
    template?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type CalendarEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAllDay?: SortOrder
    location?: SortOrder
    url?: SortOrder
    category?: SortOrder
    color?: SortOrder
    isRecurring?: SortOrder
    recurrenceRule?: SortOrder
    parentEventId?: SortOrder
    eventType?: SortOrder
    visibility?: SortOrder
    projectId?: SortOrder
    communityEvent?: SortOrder
    reminders?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAllDay?: SortOrder
    location?: SortOrder
    url?: SortOrder
    category?: SortOrder
    color?: SortOrder
    isRecurring?: SortOrder
    recurrenceRule?: SortOrder
    parentEventId?: SortOrder
    eventType?: SortOrder
    visibility?: SortOrder
    projectId?: SortOrder
    communityEvent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isAllDay?: SortOrder
    location?: SortOrder
    url?: SortOrder
    category?: SortOrder
    color?: SortOrder
    isRecurring?: SortOrder
    recurrenceRule?: SortOrder
    parentEventId?: SortOrder
    eventType?: SortOrder
    visibility?: SortOrder
    projectId?: SortOrder
    communityEvent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type EnumAttendeeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendeeStatus | EnumAttendeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendeeStatus[] | ListEnumAttendeeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendeeStatus[] | ListEnumAttendeeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendeeStatusFilter<$PrismaModel> | $Enums.AttendeeStatus
  }

  export type CalendarEventRelationFilter = {
    is?: CalendarEventWhereInput
    isNot?: CalendarEventWhereInput
  }

  export type EventAttendeeEventIdUserIdCompoundUniqueInput = {
    eventId: string
    userId: string
  }

  export type EventAttendeeCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventAttendeeMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventAttendeeMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAttendeeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendeeStatus | EnumAttendeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendeeStatus[] | ListEnumAttendeeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendeeStatus[] | ListEnumAttendeeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendeeStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendeeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendeeStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendeeStatusFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type BudgetNullableRelationFilter = {
    is?: BudgetWhereInput | null
    isNot?: BudgetWhereInput | null
  }

  export type FinancialTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    type?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    merchant?: SortOrder
    location?: SortOrder
    paymentMethod?: SortOrder
    budgetId?: SortOrder
    tags?: SortOrder
    gstAmount?: SortOrder
    taxCategory?: SortOrder
    transactionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancialTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    gstAmount?: SortOrder
  }

  export type FinancialTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    type?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    merchant?: SortOrder
    location?: SortOrder
    paymentMethod?: SortOrder
    budgetId?: SortOrder
    gstAmount?: SortOrder
    taxCategory?: SortOrder
    transactionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancialTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    type?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    merchant?: SortOrder
    location?: SortOrder
    paymentMethod?: SortOrder
    budgetId?: SortOrder
    gstAmount?: SortOrder
    taxCategory?: SortOrder
    transactionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancialTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    gstAmount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumBudgetPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetPeriod | EnumBudgetPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetPeriodFilter<$PrismaModel> | $Enums.BudgetPeriod
  }

  export type BudgetCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    totalAmount?: SortOrder
    spentAmount?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    categories?: SortOrder
    isActive?: SortOrder
    alertThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    spentAmount?: SortOrder
    alertThreshold?: SortOrder
  }

  export type BudgetMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    totalAmount?: SortOrder
    spentAmount?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    alertThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    totalAmount?: SortOrder
    spentAmount?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    alertThreshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    spentAmount?: SortOrder
    alertThreshold?: SortOrder
  }

  export type EnumBudgetPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetPeriod | EnumBudgetPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetPeriodWithAggregatesFilter<$PrismaModel> | $Enums.BudgetPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBudgetPeriodFilter<$PrismaModel>
    _max?: NestedEnumBudgetPeriodFilter<$PrismaModel>
  }

  export type UserCreateskillsInput = {
    set: string[]
  }

  export type UserCreateinterestsInput = {
    set: string[]
  }

  export type StoryCreateNestedManyWithoutAuthorInput = {
    create?: XOR<StoryCreateWithoutAuthorInput, StoryUncheckedCreateWithoutAuthorInput> | StoryCreateWithoutAuthorInput[] | StoryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutAuthorInput | StoryCreateOrConnectWithoutAuthorInput[]
    createMany?: StoryCreateManyAuthorInputEnvelope
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
  }

  export type ProjectMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type OpportunityApplicationCreateNestedManyWithoutUserInput = {
    create?: XOR<OpportunityApplicationCreateWithoutUserInput, OpportunityApplicationUncheckedCreateWithoutUserInput> | OpportunityApplicationCreateWithoutUserInput[] | OpportunityApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OpportunityApplicationCreateOrConnectWithoutUserInput | OpportunityApplicationCreateOrConnectWithoutUserInput[]
    createMany?: OpportunityApplicationCreateManyUserInputEnvelope
    connect?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
  }

  export type LifeOSProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<LifeOSProfileCreateWithoutUserInput, LifeOSProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: LifeOSProfileCreateOrConnectWithoutUserInput
    connect?: LifeOSProfileWhereUniqueInput
  }

  export type CalendarEventCreateNestedManyWithoutUserInput = {
    create?: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput> | CalendarEventCreateWithoutUserInput[] | CalendarEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutUserInput | CalendarEventCreateOrConnectWithoutUserInput[]
    createMany?: CalendarEventCreateManyUserInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type EventAttendeeCreateNestedManyWithoutUserInput = {
    create?: XOR<EventAttendeeCreateWithoutUserInput, EventAttendeeUncheckedCreateWithoutUserInput> | EventAttendeeCreateWithoutUserInput[] | EventAttendeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutUserInput | EventAttendeeCreateOrConnectWithoutUserInput[]
    createMany?: EventAttendeeCreateManyUserInputEnvelope
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
  }

  export type StoryUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<StoryCreateWithoutAuthorInput, StoryUncheckedCreateWithoutAuthorInput> | StoryCreateWithoutAuthorInput[] | StoryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutAuthorInput | StoryCreateOrConnectWithoutAuthorInput[]
    createMany?: StoryCreateManyAuthorInputEnvelope
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type OpportunityApplicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OpportunityApplicationCreateWithoutUserInput, OpportunityApplicationUncheckedCreateWithoutUserInput> | OpportunityApplicationCreateWithoutUserInput[] | OpportunityApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OpportunityApplicationCreateOrConnectWithoutUserInput | OpportunityApplicationCreateOrConnectWithoutUserInput[]
    createMany?: OpportunityApplicationCreateManyUserInputEnvelope
    connect?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
  }

  export type LifeOSProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<LifeOSProfileCreateWithoutUserInput, LifeOSProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: LifeOSProfileCreateOrConnectWithoutUserInput
    connect?: LifeOSProfileWhereUniqueInput
  }

  export type CalendarEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput> | CalendarEventCreateWithoutUserInput[] | CalendarEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutUserInput | CalendarEventCreateOrConnectWithoutUserInput[]
    createMany?: CalendarEventCreateManyUserInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type EventAttendeeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EventAttendeeCreateWithoutUserInput, EventAttendeeUncheckedCreateWithoutUserInput> | EventAttendeeCreateWithoutUserInput[] | EventAttendeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutUserInput | EventAttendeeCreateOrConnectWithoutUserInput[]
    createMany?: EventAttendeeCreateManyUserInputEnvelope
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateinterestsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type StoryUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<StoryCreateWithoutAuthorInput, StoryUncheckedCreateWithoutAuthorInput> | StoryCreateWithoutAuthorInput[] | StoryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutAuthorInput | StoryCreateOrConnectWithoutAuthorInput[]
    upsert?: StoryUpsertWithWhereUniqueWithoutAuthorInput | StoryUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: StoryCreateManyAuthorInputEnvelope
    set?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    disconnect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    delete?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    update?: StoryUpdateWithWhereUniqueWithoutAuthorInput | StoryUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: StoryUpdateManyWithWhereWithoutAuthorInput | StoryUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: StoryScalarWhereInput | StoryScalarWhereInput[]
  }

  export type ProjectMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type OpportunityApplicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<OpportunityApplicationCreateWithoutUserInput, OpportunityApplicationUncheckedCreateWithoutUserInput> | OpportunityApplicationCreateWithoutUserInput[] | OpportunityApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OpportunityApplicationCreateOrConnectWithoutUserInput | OpportunityApplicationCreateOrConnectWithoutUserInput[]
    upsert?: OpportunityApplicationUpsertWithWhereUniqueWithoutUserInput | OpportunityApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OpportunityApplicationCreateManyUserInputEnvelope
    set?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
    disconnect?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
    delete?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
    connect?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
    update?: OpportunityApplicationUpdateWithWhereUniqueWithoutUserInput | OpportunityApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OpportunityApplicationUpdateManyWithWhereWithoutUserInput | OpportunityApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OpportunityApplicationScalarWhereInput | OpportunityApplicationScalarWhereInput[]
  }

  export type LifeOSProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<LifeOSProfileCreateWithoutUserInput, LifeOSProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: LifeOSProfileCreateOrConnectWithoutUserInput
    upsert?: LifeOSProfileUpsertWithoutUserInput
    disconnect?: LifeOSProfileWhereInput | boolean
    delete?: LifeOSProfileWhereInput | boolean
    connect?: LifeOSProfileWhereUniqueInput
    update?: XOR<XOR<LifeOSProfileUpdateToOneWithWhereWithoutUserInput, LifeOSProfileUpdateWithoutUserInput>, LifeOSProfileUncheckedUpdateWithoutUserInput>
  }

  export type CalendarEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput> | CalendarEventCreateWithoutUserInput[] | CalendarEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutUserInput | CalendarEventCreateOrConnectWithoutUserInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutUserInput | CalendarEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CalendarEventCreateManyUserInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutUserInput | CalendarEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutUserInput | CalendarEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type EventAttendeeUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventAttendeeCreateWithoutUserInput, EventAttendeeUncheckedCreateWithoutUserInput> | EventAttendeeCreateWithoutUserInput[] | EventAttendeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutUserInput | EventAttendeeCreateOrConnectWithoutUserInput[]
    upsert?: EventAttendeeUpsertWithWhereUniqueWithoutUserInput | EventAttendeeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventAttendeeCreateManyUserInputEnvelope
    set?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    disconnect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    delete?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    update?: EventAttendeeUpdateWithWhereUniqueWithoutUserInput | EventAttendeeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventAttendeeUpdateManyWithWhereWithoutUserInput | EventAttendeeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventAttendeeScalarWhereInput | EventAttendeeScalarWhereInput[]
  }

  export type StoryUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<StoryCreateWithoutAuthorInput, StoryUncheckedCreateWithoutAuthorInput> | StoryCreateWithoutAuthorInput[] | StoryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutAuthorInput | StoryCreateOrConnectWithoutAuthorInput[]
    upsert?: StoryUpsertWithWhereUniqueWithoutAuthorInput | StoryUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: StoryCreateManyAuthorInputEnvelope
    set?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    disconnect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    delete?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    update?: StoryUpdateWithWhereUniqueWithoutAuthorInput | StoryUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: StoryUpdateManyWithWhereWithoutAuthorInput | StoryUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: StoryScalarWhereInput | StoryScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type OpportunityApplicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OpportunityApplicationCreateWithoutUserInput, OpportunityApplicationUncheckedCreateWithoutUserInput> | OpportunityApplicationCreateWithoutUserInput[] | OpportunityApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OpportunityApplicationCreateOrConnectWithoutUserInput | OpportunityApplicationCreateOrConnectWithoutUserInput[]
    upsert?: OpportunityApplicationUpsertWithWhereUniqueWithoutUserInput | OpportunityApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OpportunityApplicationCreateManyUserInputEnvelope
    set?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
    disconnect?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
    delete?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
    connect?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
    update?: OpportunityApplicationUpdateWithWhereUniqueWithoutUserInput | OpportunityApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OpportunityApplicationUpdateManyWithWhereWithoutUserInput | OpportunityApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OpportunityApplicationScalarWhereInput | OpportunityApplicationScalarWhereInput[]
  }

  export type LifeOSProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<LifeOSProfileCreateWithoutUserInput, LifeOSProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: LifeOSProfileCreateOrConnectWithoutUserInput
    upsert?: LifeOSProfileUpsertWithoutUserInput
    disconnect?: LifeOSProfileWhereInput | boolean
    delete?: LifeOSProfileWhereInput | boolean
    connect?: LifeOSProfileWhereUniqueInput
    update?: XOR<XOR<LifeOSProfileUpdateToOneWithWhereWithoutUserInput, LifeOSProfileUpdateWithoutUserInput>, LifeOSProfileUncheckedUpdateWithoutUserInput>
  }

  export type CalendarEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput> | CalendarEventCreateWithoutUserInput[] | CalendarEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutUserInput | CalendarEventCreateOrConnectWithoutUserInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutUserInput | CalendarEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CalendarEventCreateManyUserInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutUserInput | CalendarEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutUserInput | CalendarEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type EventAttendeeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventAttendeeCreateWithoutUserInput, EventAttendeeUncheckedCreateWithoutUserInput> | EventAttendeeCreateWithoutUserInput[] | EventAttendeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutUserInput | EventAttendeeCreateOrConnectWithoutUserInput[]
    upsert?: EventAttendeeUpsertWithWhereUniqueWithoutUserInput | EventAttendeeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventAttendeeCreateManyUserInputEnvelope
    set?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    disconnect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    delete?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    update?: EventAttendeeUpdateWithWhereUniqueWithoutUserInput | EventAttendeeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventAttendeeUpdateManyWithWhereWithoutUserInput | EventAttendeeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventAttendeeScalarWhereInput | EventAttendeeScalarWhereInput[]
  }

  export type ProjectCreatetagsInput = {
    set: string[]
  }

  export type ProjectCreateimagesInput = {
    set: string[]
  }

  export type ProjectCreatedocumentsInput = {
    set: string[]
  }

  export type ProjectMemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type StoryCreateNestedManyWithoutProjectInput = {
    create?: XOR<StoryCreateWithoutProjectInput, StoryUncheckedCreateWithoutProjectInput> | StoryCreateWithoutProjectInput[] | StoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutProjectInput | StoryCreateOrConnectWithoutProjectInput[]
    createMany?: StoryCreateManyProjectInputEnvelope
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
  }

  export type OpportunityCreateNestedManyWithoutProjectInput = {
    create?: XOR<OpportunityCreateWithoutProjectInput, OpportunityUncheckedCreateWithoutProjectInput> | OpportunityCreateWithoutProjectInput[] | OpportunityUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutProjectInput | OpportunityCreateOrConnectWithoutProjectInput[]
    createMany?: OpportunityCreateManyProjectInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type CalendarEventCreateNestedManyWithoutProjectInput = {
    create?: XOR<CalendarEventCreateWithoutProjectInput, CalendarEventUncheckedCreateWithoutProjectInput> | CalendarEventCreateWithoutProjectInput[] | CalendarEventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutProjectInput | CalendarEventCreateOrConnectWithoutProjectInput[]
    createMany?: CalendarEventCreateManyProjectInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type StoryUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<StoryCreateWithoutProjectInput, StoryUncheckedCreateWithoutProjectInput> | StoryCreateWithoutProjectInput[] | StoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutProjectInput | StoryCreateOrConnectWithoutProjectInput[]
    createMany?: StoryCreateManyProjectInputEnvelope
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
  }

  export type OpportunityUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<OpportunityCreateWithoutProjectInput, OpportunityUncheckedCreateWithoutProjectInput> | OpportunityCreateWithoutProjectInput[] | OpportunityUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutProjectInput | OpportunityCreateOrConnectWithoutProjectInput[]
    createMany?: OpportunityCreateManyProjectInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type CalendarEventUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CalendarEventCreateWithoutProjectInput, CalendarEventUncheckedCreateWithoutProjectInput> | CalendarEventCreateWithoutProjectInput[] | CalendarEventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutProjectInput | CalendarEventCreateOrConnectWithoutProjectInput[]
    createMany?: CalendarEventCreateManyProjectInputEnvelope
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
  }

  export type EnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus
  }

  export type EnumVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.Visibility
  }

  export type ProjectUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdatedocumentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectMemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type StoryUpdateManyWithoutProjectNestedInput = {
    create?: XOR<StoryCreateWithoutProjectInput, StoryUncheckedCreateWithoutProjectInput> | StoryCreateWithoutProjectInput[] | StoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutProjectInput | StoryCreateOrConnectWithoutProjectInput[]
    upsert?: StoryUpsertWithWhereUniqueWithoutProjectInput | StoryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: StoryCreateManyProjectInputEnvelope
    set?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    disconnect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    delete?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    update?: StoryUpdateWithWhereUniqueWithoutProjectInput | StoryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: StoryUpdateManyWithWhereWithoutProjectInput | StoryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: StoryScalarWhereInput | StoryScalarWhereInput[]
  }

  export type OpportunityUpdateManyWithoutProjectNestedInput = {
    create?: XOR<OpportunityCreateWithoutProjectInput, OpportunityUncheckedCreateWithoutProjectInput> | OpportunityCreateWithoutProjectInput[] | OpportunityUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutProjectInput | OpportunityCreateOrConnectWithoutProjectInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutProjectInput | OpportunityUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: OpportunityCreateManyProjectInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutProjectInput | OpportunityUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutProjectInput | OpportunityUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type CalendarEventUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CalendarEventCreateWithoutProjectInput, CalendarEventUncheckedCreateWithoutProjectInput> | CalendarEventCreateWithoutProjectInput[] | CalendarEventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutProjectInput | CalendarEventCreateOrConnectWithoutProjectInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutProjectInput | CalendarEventUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CalendarEventCreateManyProjectInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutProjectInput | CalendarEventUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutProjectInput | CalendarEventUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type StoryUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<StoryCreateWithoutProjectInput, StoryUncheckedCreateWithoutProjectInput> | StoryCreateWithoutProjectInput[] | StoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutProjectInput | StoryCreateOrConnectWithoutProjectInput[]
    upsert?: StoryUpsertWithWhereUniqueWithoutProjectInput | StoryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: StoryCreateManyProjectInputEnvelope
    set?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    disconnect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    delete?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    update?: StoryUpdateWithWhereUniqueWithoutProjectInput | StoryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: StoryUpdateManyWithWhereWithoutProjectInput | StoryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: StoryScalarWhereInput | StoryScalarWhereInput[]
  }

  export type OpportunityUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<OpportunityCreateWithoutProjectInput, OpportunityUncheckedCreateWithoutProjectInput> | OpportunityCreateWithoutProjectInput[] | OpportunityUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutProjectInput | OpportunityCreateOrConnectWithoutProjectInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutProjectInput | OpportunityUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: OpportunityCreateManyProjectInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutProjectInput | OpportunityUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutProjectInput | OpportunityUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type CalendarEventUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CalendarEventCreateWithoutProjectInput, CalendarEventUncheckedCreateWithoutProjectInput> | CalendarEventCreateWithoutProjectInput[] | CalendarEventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CalendarEventCreateOrConnectWithoutProjectInput | CalendarEventCreateOrConnectWithoutProjectInput[]
    upsert?: CalendarEventUpsertWithWhereUniqueWithoutProjectInput | CalendarEventUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CalendarEventCreateManyProjectInputEnvelope
    set?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    disconnect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    delete?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    connect?: CalendarEventWhereUniqueInput | CalendarEventWhereUniqueInput[]
    update?: CalendarEventUpdateWithWhereUniqueWithoutProjectInput | CalendarEventUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CalendarEventUpdateManyWithWhereWithoutProjectInput | CalendarEventUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutMembersInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    connect?: ProjectWhereUniqueInput
  }

  export type EnumProjectRoleFieldUpdateOperationsInput = {
    set?: $Enums.ProjectRole
  }

  export type UserUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    upsert?: UserUpsertWithoutProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsInput, UserUpdateWithoutProjectsInput>, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    upsert?: ProjectUpsertWithoutMembersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMembersInput, ProjectUpdateWithoutMembersInput>, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type StoryCreatetagsInput = {
    set: string[]
  }

  export type StoryCreateimagesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutStoriesInput = {
    create?: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoriesInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutStoriesInput = {
    create?: XOR<ProjectCreateWithoutStoriesInput, ProjectUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutStoriesInput
    connect?: ProjectWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutStoryInput = {
    create?: XOR<CommentCreateWithoutStoryInput, CommentUncheckedCreateWithoutStoryInput> | CommentCreateWithoutStoryInput[] | CommentUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutStoryInput | CommentCreateOrConnectWithoutStoryInput[]
    createMany?: CommentCreateManyStoryInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<CommentCreateWithoutStoryInput, CommentUncheckedCreateWithoutStoryInput> | CommentCreateWithoutStoryInput[] | CommentUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutStoryInput | CommentCreateOrConnectWithoutStoryInput[]
    createMany?: CommentCreateManyStoryInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EnumStoryStatusFieldUpdateOperationsInput = {
    set?: $Enums.StoryStatus
  }

  export type StoryUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type StoryUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutStoriesNestedInput = {
    create?: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoriesInput
    upsert?: UserUpsertWithoutStoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStoriesInput, UserUpdateWithoutStoriesInput>, UserUncheckedUpdateWithoutStoriesInput>
  }

  export type ProjectUpdateOneWithoutStoriesNestedInput = {
    create?: XOR<ProjectCreateWithoutStoriesInput, ProjectUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutStoriesInput
    upsert?: ProjectUpsertWithoutStoriesInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutStoriesInput, ProjectUpdateWithoutStoriesInput>, ProjectUncheckedUpdateWithoutStoriesInput>
  }

  export type CommentUpdateManyWithoutStoryNestedInput = {
    create?: XOR<CommentCreateWithoutStoryInput, CommentUncheckedCreateWithoutStoryInput> | CommentCreateWithoutStoryInput[] | CommentUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutStoryInput | CommentCreateOrConnectWithoutStoryInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutStoryInput | CommentUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: CommentCreateManyStoryInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutStoryInput | CommentUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutStoryInput | CommentUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<CommentCreateWithoutStoryInput, CommentUncheckedCreateWithoutStoryInput> | CommentCreateWithoutStoryInput[] | CommentUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutStoryInput | CommentCreateOrConnectWithoutStoryInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutStoryInput | CommentUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: CommentCreateManyStoryInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutStoryInput | CommentUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutStoryInput | CommentUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type StoryCreateNestedOneWithoutCommentsInput = {
    create?: XOR<StoryCreateWithoutCommentsInput, StoryUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: StoryCreateOrConnectWithoutCommentsInput
    connect?: StoryWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EnumCommentStatusFieldUpdateOperationsInput = {
    set?: $Enums.CommentStatus
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type StoryUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<StoryCreateWithoutCommentsInput, StoryUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: StoryCreateOrConnectWithoutCommentsInput
    upsert?: StoryUpsertWithoutCommentsInput
    connect?: StoryWhereUniqueInput
    update?: XOR<XOR<StoryUpdateToOneWithWhereWithoutCommentsInput, StoryUpdateWithoutCommentsInput>, StoryUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type OpportunityCreatetagsInput = {
    set: string[]
  }

  export type OpportunityCreateskillsInput = {
    set: string[]
  }

  export type OpportunityCreateimagesInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutOpportunitiesInput = {
    create?: XOR<ProjectCreateWithoutOpportunitiesInput, ProjectUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutOpportunitiesInput
    connect?: ProjectWhereUniqueInput
  }

  export type OpportunityApplicationCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<OpportunityApplicationCreateWithoutOpportunityInput, OpportunityApplicationUncheckedCreateWithoutOpportunityInput> | OpportunityApplicationCreateWithoutOpportunityInput[] | OpportunityApplicationUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OpportunityApplicationCreateOrConnectWithoutOpportunityInput | OpportunityApplicationCreateOrConnectWithoutOpportunityInput[]
    createMany?: OpportunityApplicationCreateManyOpportunityInputEnvelope
    connect?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
  }

  export type OpportunityApplicationUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<OpportunityApplicationCreateWithoutOpportunityInput, OpportunityApplicationUncheckedCreateWithoutOpportunityInput> | OpportunityApplicationCreateWithoutOpportunityInput[] | OpportunityApplicationUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OpportunityApplicationCreateOrConnectWithoutOpportunityInput | OpportunityApplicationCreateOrConnectWithoutOpportunityInput[]
    createMany?: OpportunityApplicationCreateManyOpportunityInputEnvelope
    connect?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
  }

  export type EnumOpportunityTypeFieldUpdateOperationsInput = {
    set?: $Enums.OpportunityType
  }

  export type EnumOpportunityStatusFieldUpdateOperationsInput = {
    set?: $Enums.OpportunityStatus
  }

  export type OpportunityUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OpportunityUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type OpportunityUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateOneWithoutOpportunitiesNestedInput = {
    create?: XOR<ProjectCreateWithoutOpportunitiesInput, ProjectUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutOpportunitiesInput
    upsert?: ProjectUpsertWithoutOpportunitiesInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutOpportunitiesInput, ProjectUpdateWithoutOpportunitiesInput>, ProjectUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type OpportunityApplicationUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<OpportunityApplicationCreateWithoutOpportunityInput, OpportunityApplicationUncheckedCreateWithoutOpportunityInput> | OpportunityApplicationCreateWithoutOpportunityInput[] | OpportunityApplicationUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OpportunityApplicationCreateOrConnectWithoutOpportunityInput | OpportunityApplicationCreateOrConnectWithoutOpportunityInput[]
    upsert?: OpportunityApplicationUpsertWithWhereUniqueWithoutOpportunityInput | OpportunityApplicationUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: OpportunityApplicationCreateManyOpportunityInputEnvelope
    set?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
    disconnect?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
    delete?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
    connect?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
    update?: OpportunityApplicationUpdateWithWhereUniqueWithoutOpportunityInput | OpportunityApplicationUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: OpportunityApplicationUpdateManyWithWhereWithoutOpportunityInput | OpportunityApplicationUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: OpportunityApplicationScalarWhereInput | OpportunityApplicationScalarWhereInput[]
  }

  export type OpportunityApplicationUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<OpportunityApplicationCreateWithoutOpportunityInput, OpportunityApplicationUncheckedCreateWithoutOpportunityInput> | OpportunityApplicationCreateWithoutOpportunityInput[] | OpportunityApplicationUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OpportunityApplicationCreateOrConnectWithoutOpportunityInput | OpportunityApplicationCreateOrConnectWithoutOpportunityInput[]
    upsert?: OpportunityApplicationUpsertWithWhereUniqueWithoutOpportunityInput | OpportunityApplicationUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: OpportunityApplicationCreateManyOpportunityInputEnvelope
    set?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
    disconnect?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
    delete?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
    connect?: OpportunityApplicationWhereUniqueInput | OpportunityApplicationWhereUniqueInput[]
    update?: OpportunityApplicationUpdateWithWhereUniqueWithoutOpportunityInput | OpportunityApplicationUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: OpportunityApplicationUpdateManyWithWhereWithoutOpportunityInput | OpportunityApplicationUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: OpportunityApplicationScalarWhereInput | OpportunityApplicationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOpportunitiesInput = {
    create?: XOR<UserCreateWithoutOpportunitiesInput, UserUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOpportunitiesInput
    connect?: UserWhereUniqueInput
  }

  export type OpportunityCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<OpportunityCreateWithoutApplicationsInput, OpportunityUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutApplicationsInput
    connect?: OpportunityWhereUniqueInput
  }

  export type EnumApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationStatus
  }

  export type UserUpdateOneRequiredWithoutOpportunitiesNestedInput = {
    create?: XOR<UserCreateWithoutOpportunitiesInput, UserUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOpportunitiesInput
    upsert?: UserUpsertWithoutOpportunitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOpportunitiesInput, UserUpdateWithoutOpportunitiesInput>, UserUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type OpportunityUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<OpportunityCreateWithoutApplicationsInput, OpportunityUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutApplicationsInput
    upsert?: OpportunityUpsertWithoutApplicationsInput
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutApplicationsInput, OpportunityUpdateWithoutApplicationsInput>, OpportunityUncheckedUpdateWithoutApplicationsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutLifeOSProfileInput = {
    create?: XOR<UserCreateWithoutLifeOSProfileInput, UserUncheckedCreateWithoutLifeOSProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutLifeOSProfileInput
    connect?: UserWhereUniqueInput
  }

  export type HabitCreateNestedManyWithoutProfileInput = {
    create?: XOR<HabitCreateWithoutProfileInput, HabitUncheckedCreateWithoutProfileInput> | HabitCreateWithoutProfileInput[] | HabitUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: HabitCreateOrConnectWithoutProfileInput | HabitCreateOrConnectWithoutProfileInput[]
    createMany?: HabitCreateManyProfileInputEnvelope
    connect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
  }

  export type GoalCreateNestedManyWithoutProfileInput = {
    create?: XOR<GoalCreateWithoutProfileInput, GoalUncheckedCreateWithoutProfileInput> | GoalCreateWithoutProfileInput[] | GoalUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutProfileInput | GoalCreateOrConnectWithoutProfileInput[]
    createMany?: GoalCreateManyProfileInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type MoodEntryCreateNestedManyWithoutProfileInput = {
    create?: XOR<MoodEntryCreateWithoutProfileInput, MoodEntryUncheckedCreateWithoutProfileInput> | MoodEntryCreateWithoutProfileInput[] | MoodEntryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: MoodEntryCreateOrConnectWithoutProfileInput | MoodEntryCreateOrConnectWithoutProfileInput[]
    createMany?: MoodEntryCreateManyProfileInputEnvelope
    connect?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
  }

  export type MeditationSessionCreateNestedManyWithoutProfileInput = {
    create?: XOR<MeditationSessionCreateWithoutProfileInput, MeditationSessionUncheckedCreateWithoutProfileInput> | MeditationSessionCreateWithoutProfileInput[] | MeditationSessionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: MeditationSessionCreateOrConnectWithoutProfileInput | MeditationSessionCreateOrConnectWithoutProfileInput[]
    createMany?: MeditationSessionCreateManyProfileInputEnvelope
    connect?: MeditationSessionWhereUniqueInput | MeditationSessionWhereUniqueInput[]
  }

  export type JournalCreateNestedManyWithoutProfileInput = {
    create?: XOR<JournalCreateWithoutProfileInput, JournalUncheckedCreateWithoutProfileInput> | JournalCreateWithoutProfileInput[] | JournalUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutProfileInput | JournalCreateOrConnectWithoutProfileInput[]
    createMany?: JournalCreateManyProfileInputEnvelope
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
  }

  export type FinancialTransactionCreateNestedManyWithoutProfileInput = {
    create?: XOR<FinancialTransactionCreateWithoutProfileInput, FinancialTransactionUncheckedCreateWithoutProfileInput> | FinancialTransactionCreateWithoutProfileInput[] | FinancialTransactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: FinancialTransactionCreateOrConnectWithoutProfileInput | FinancialTransactionCreateOrConnectWithoutProfileInput[]
    createMany?: FinancialTransactionCreateManyProfileInputEnvelope
    connect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
  }

  export type BudgetCreateNestedManyWithoutProfileInput = {
    create?: XOR<BudgetCreateWithoutProfileInput, BudgetUncheckedCreateWithoutProfileInput> | BudgetCreateWithoutProfileInput[] | BudgetUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutProfileInput | BudgetCreateOrConnectWithoutProfileInput[]
    createMany?: BudgetCreateManyProfileInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type HabitUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<HabitCreateWithoutProfileInput, HabitUncheckedCreateWithoutProfileInput> | HabitCreateWithoutProfileInput[] | HabitUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: HabitCreateOrConnectWithoutProfileInput | HabitCreateOrConnectWithoutProfileInput[]
    createMany?: HabitCreateManyProfileInputEnvelope
    connect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
  }

  export type GoalUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<GoalCreateWithoutProfileInput, GoalUncheckedCreateWithoutProfileInput> | GoalCreateWithoutProfileInput[] | GoalUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutProfileInput | GoalCreateOrConnectWithoutProfileInput[]
    createMany?: GoalCreateManyProfileInputEnvelope
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
  }

  export type MoodEntryUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<MoodEntryCreateWithoutProfileInput, MoodEntryUncheckedCreateWithoutProfileInput> | MoodEntryCreateWithoutProfileInput[] | MoodEntryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: MoodEntryCreateOrConnectWithoutProfileInput | MoodEntryCreateOrConnectWithoutProfileInput[]
    createMany?: MoodEntryCreateManyProfileInputEnvelope
    connect?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
  }

  export type MeditationSessionUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<MeditationSessionCreateWithoutProfileInput, MeditationSessionUncheckedCreateWithoutProfileInput> | MeditationSessionCreateWithoutProfileInput[] | MeditationSessionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: MeditationSessionCreateOrConnectWithoutProfileInput | MeditationSessionCreateOrConnectWithoutProfileInput[]
    createMany?: MeditationSessionCreateManyProfileInputEnvelope
    connect?: MeditationSessionWhereUniqueInput | MeditationSessionWhereUniqueInput[]
  }

  export type JournalUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<JournalCreateWithoutProfileInput, JournalUncheckedCreateWithoutProfileInput> | JournalCreateWithoutProfileInput[] | JournalUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutProfileInput | JournalCreateOrConnectWithoutProfileInput[]
    createMany?: JournalCreateManyProfileInputEnvelope
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
  }

  export type FinancialTransactionUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<FinancialTransactionCreateWithoutProfileInput, FinancialTransactionUncheckedCreateWithoutProfileInput> | FinancialTransactionCreateWithoutProfileInput[] | FinancialTransactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: FinancialTransactionCreateOrConnectWithoutProfileInput | FinancialTransactionCreateOrConnectWithoutProfileInput[]
    createMany?: FinancialTransactionCreateManyProfileInputEnvelope
    connect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
  }

  export type BudgetUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<BudgetCreateWithoutProfileInput, BudgetUncheckedCreateWithoutProfileInput> | BudgetCreateWithoutProfileInput[] | BudgetUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutProfileInput | BudgetCreateOrConnectWithoutProfileInput[]
    createMany?: BudgetCreateManyProfileInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutLifeOSProfileNestedInput = {
    create?: XOR<UserCreateWithoutLifeOSProfileInput, UserUncheckedCreateWithoutLifeOSProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutLifeOSProfileInput
    upsert?: UserUpsertWithoutLifeOSProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLifeOSProfileInput, UserUpdateWithoutLifeOSProfileInput>, UserUncheckedUpdateWithoutLifeOSProfileInput>
  }

  export type HabitUpdateManyWithoutProfileNestedInput = {
    create?: XOR<HabitCreateWithoutProfileInput, HabitUncheckedCreateWithoutProfileInput> | HabitCreateWithoutProfileInput[] | HabitUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: HabitCreateOrConnectWithoutProfileInput | HabitCreateOrConnectWithoutProfileInput[]
    upsert?: HabitUpsertWithWhereUniqueWithoutProfileInput | HabitUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: HabitCreateManyProfileInputEnvelope
    set?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    disconnect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    delete?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    connect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    update?: HabitUpdateWithWhereUniqueWithoutProfileInput | HabitUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: HabitUpdateManyWithWhereWithoutProfileInput | HabitUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: HabitScalarWhereInput | HabitScalarWhereInput[]
  }

  export type GoalUpdateManyWithoutProfileNestedInput = {
    create?: XOR<GoalCreateWithoutProfileInput, GoalUncheckedCreateWithoutProfileInput> | GoalCreateWithoutProfileInput[] | GoalUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutProfileInput | GoalCreateOrConnectWithoutProfileInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutProfileInput | GoalUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: GoalCreateManyProfileInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutProfileInput | GoalUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutProfileInput | GoalUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type MoodEntryUpdateManyWithoutProfileNestedInput = {
    create?: XOR<MoodEntryCreateWithoutProfileInput, MoodEntryUncheckedCreateWithoutProfileInput> | MoodEntryCreateWithoutProfileInput[] | MoodEntryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: MoodEntryCreateOrConnectWithoutProfileInput | MoodEntryCreateOrConnectWithoutProfileInput[]
    upsert?: MoodEntryUpsertWithWhereUniqueWithoutProfileInput | MoodEntryUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: MoodEntryCreateManyProfileInputEnvelope
    set?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    disconnect?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    delete?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    connect?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    update?: MoodEntryUpdateWithWhereUniqueWithoutProfileInput | MoodEntryUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: MoodEntryUpdateManyWithWhereWithoutProfileInput | MoodEntryUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: MoodEntryScalarWhereInput | MoodEntryScalarWhereInput[]
  }

  export type MeditationSessionUpdateManyWithoutProfileNestedInput = {
    create?: XOR<MeditationSessionCreateWithoutProfileInput, MeditationSessionUncheckedCreateWithoutProfileInput> | MeditationSessionCreateWithoutProfileInput[] | MeditationSessionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: MeditationSessionCreateOrConnectWithoutProfileInput | MeditationSessionCreateOrConnectWithoutProfileInput[]
    upsert?: MeditationSessionUpsertWithWhereUniqueWithoutProfileInput | MeditationSessionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: MeditationSessionCreateManyProfileInputEnvelope
    set?: MeditationSessionWhereUniqueInput | MeditationSessionWhereUniqueInput[]
    disconnect?: MeditationSessionWhereUniqueInput | MeditationSessionWhereUniqueInput[]
    delete?: MeditationSessionWhereUniqueInput | MeditationSessionWhereUniqueInput[]
    connect?: MeditationSessionWhereUniqueInput | MeditationSessionWhereUniqueInput[]
    update?: MeditationSessionUpdateWithWhereUniqueWithoutProfileInput | MeditationSessionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: MeditationSessionUpdateManyWithWhereWithoutProfileInput | MeditationSessionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: MeditationSessionScalarWhereInput | MeditationSessionScalarWhereInput[]
  }

  export type JournalUpdateManyWithoutProfileNestedInput = {
    create?: XOR<JournalCreateWithoutProfileInput, JournalUncheckedCreateWithoutProfileInput> | JournalCreateWithoutProfileInput[] | JournalUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutProfileInput | JournalCreateOrConnectWithoutProfileInput[]
    upsert?: JournalUpsertWithWhereUniqueWithoutProfileInput | JournalUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: JournalCreateManyProfileInputEnvelope
    set?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    disconnect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    delete?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    update?: JournalUpdateWithWhereUniqueWithoutProfileInput | JournalUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: JournalUpdateManyWithWhereWithoutProfileInput | JournalUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: JournalScalarWhereInput | JournalScalarWhereInput[]
  }

  export type FinancialTransactionUpdateManyWithoutProfileNestedInput = {
    create?: XOR<FinancialTransactionCreateWithoutProfileInput, FinancialTransactionUncheckedCreateWithoutProfileInput> | FinancialTransactionCreateWithoutProfileInput[] | FinancialTransactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: FinancialTransactionCreateOrConnectWithoutProfileInput | FinancialTransactionCreateOrConnectWithoutProfileInput[]
    upsert?: FinancialTransactionUpsertWithWhereUniqueWithoutProfileInput | FinancialTransactionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: FinancialTransactionCreateManyProfileInputEnvelope
    set?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    disconnect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    delete?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    connect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    update?: FinancialTransactionUpdateWithWhereUniqueWithoutProfileInput | FinancialTransactionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: FinancialTransactionUpdateManyWithWhereWithoutProfileInput | FinancialTransactionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: FinancialTransactionScalarWhereInput | FinancialTransactionScalarWhereInput[]
  }

  export type BudgetUpdateManyWithoutProfileNestedInput = {
    create?: XOR<BudgetCreateWithoutProfileInput, BudgetUncheckedCreateWithoutProfileInput> | BudgetCreateWithoutProfileInput[] | BudgetUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutProfileInput | BudgetCreateOrConnectWithoutProfileInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutProfileInput | BudgetUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: BudgetCreateManyProfileInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutProfileInput | BudgetUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutProfileInput | BudgetUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type HabitUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<HabitCreateWithoutProfileInput, HabitUncheckedCreateWithoutProfileInput> | HabitCreateWithoutProfileInput[] | HabitUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: HabitCreateOrConnectWithoutProfileInput | HabitCreateOrConnectWithoutProfileInput[]
    upsert?: HabitUpsertWithWhereUniqueWithoutProfileInput | HabitUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: HabitCreateManyProfileInputEnvelope
    set?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    disconnect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    delete?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    connect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    update?: HabitUpdateWithWhereUniqueWithoutProfileInput | HabitUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: HabitUpdateManyWithWhereWithoutProfileInput | HabitUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: HabitScalarWhereInput | HabitScalarWhereInput[]
  }

  export type GoalUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<GoalCreateWithoutProfileInput, GoalUncheckedCreateWithoutProfileInput> | GoalCreateWithoutProfileInput[] | GoalUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: GoalCreateOrConnectWithoutProfileInput | GoalCreateOrConnectWithoutProfileInput[]
    upsert?: GoalUpsertWithWhereUniqueWithoutProfileInput | GoalUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: GoalCreateManyProfileInputEnvelope
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[]
    update?: GoalUpdateWithWhereUniqueWithoutProfileInput | GoalUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: GoalUpdateManyWithWhereWithoutProfileInput | GoalUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[]
  }

  export type MoodEntryUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<MoodEntryCreateWithoutProfileInput, MoodEntryUncheckedCreateWithoutProfileInput> | MoodEntryCreateWithoutProfileInput[] | MoodEntryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: MoodEntryCreateOrConnectWithoutProfileInput | MoodEntryCreateOrConnectWithoutProfileInput[]
    upsert?: MoodEntryUpsertWithWhereUniqueWithoutProfileInput | MoodEntryUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: MoodEntryCreateManyProfileInputEnvelope
    set?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    disconnect?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    delete?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    connect?: MoodEntryWhereUniqueInput | MoodEntryWhereUniqueInput[]
    update?: MoodEntryUpdateWithWhereUniqueWithoutProfileInput | MoodEntryUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: MoodEntryUpdateManyWithWhereWithoutProfileInput | MoodEntryUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: MoodEntryScalarWhereInput | MoodEntryScalarWhereInput[]
  }

  export type MeditationSessionUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<MeditationSessionCreateWithoutProfileInput, MeditationSessionUncheckedCreateWithoutProfileInput> | MeditationSessionCreateWithoutProfileInput[] | MeditationSessionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: MeditationSessionCreateOrConnectWithoutProfileInput | MeditationSessionCreateOrConnectWithoutProfileInput[]
    upsert?: MeditationSessionUpsertWithWhereUniqueWithoutProfileInput | MeditationSessionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: MeditationSessionCreateManyProfileInputEnvelope
    set?: MeditationSessionWhereUniqueInput | MeditationSessionWhereUniqueInput[]
    disconnect?: MeditationSessionWhereUniqueInput | MeditationSessionWhereUniqueInput[]
    delete?: MeditationSessionWhereUniqueInput | MeditationSessionWhereUniqueInput[]
    connect?: MeditationSessionWhereUniqueInput | MeditationSessionWhereUniqueInput[]
    update?: MeditationSessionUpdateWithWhereUniqueWithoutProfileInput | MeditationSessionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: MeditationSessionUpdateManyWithWhereWithoutProfileInput | MeditationSessionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: MeditationSessionScalarWhereInput | MeditationSessionScalarWhereInput[]
  }

  export type JournalUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<JournalCreateWithoutProfileInput, JournalUncheckedCreateWithoutProfileInput> | JournalCreateWithoutProfileInput[] | JournalUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutProfileInput | JournalCreateOrConnectWithoutProfileInput[]
    upsert?: JournalUpsertWithWhereUniqueWithoutProfileInput | JournalUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: JournalCreateManyProfileInputEnvelope
    set?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    disconnect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    delete?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    update?: JournalUpdateWithWhereUniqueWithoutProfileInput | JournalUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: JournalUpdateManyWithWhereWithoutProfileInput | JournalUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: JournalScalarWhereInput | JournalScalarWhereInput[]
  }

  export type FinancialTransactionUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<FinancialTransactionCreateWithoutProfileInput, FinancialTransactionUncheckedCreateWithoutProfileInput> | FinancialTransactionCreateWithoutProfileInput[] | FinancialTransactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: FinancialTransactionCreateOrConnectWithoutProfileInput | FinancialTransactionCreateOrConnectWithoutProfileInput[]
    upsert?: FinancialTransactionUpsertWithWhereUniqueWithoutProfileInput | FinancialTransactionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: FinancialTransactionCreateManyProfileInputEnvelope
    set?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    disconnect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    delete?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    connect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    update?: FinancialTransactionUpdateWithWhereUniqueWithoutProfileInput | FinancialTransactionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: FinancialTransactionUpdateManyWithWhereWithoutProfileInput | FinancialTransactionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: FinancialTransactionScalarWhereInput | FinancialTransactionScalarWhereInput[]
  }

  export type BudgetUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<BudgetCreateWithoutProfileInput, BudgetUncheckedCreateWithoutProfileInput> | BudgetCreateWithoutProfileInput[] | BudgetUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutProfileInput | BudgetCreateOrConnectWithoutProfileInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutProfileInput | BudgetUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: BudgetCreateManyProfileInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutProfileInput | BudgetUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutProfileInput | BudgetUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type LifeOSProfileCreateNestedOneWithoutHabitsInput = {
    create?: XOR<LifeOSProfileCreateWithoutHabitsInput, LifeOSProfileUncheckedCreateWithoutHabitsInput>
    connectOrCreate?: LifeOSProfileCreateOrConnectWithoutHabitsInput
    connect?: LifeOSProfileWhereUniqueInput
  }

  export type HabitCompletionCreateNestedManyWithoutHabitInput = {
    create?: XOR<HabitCompletionCreateWithoutHabitInput, HabitCompletionUncheckedCreateWithoutHabitInput> | HabitCompletionCreateWithoutHabitInput[] | HabitCompletionUncheckedCreateWithoutHabitInput[]
    connectOrCreate?: HabitCompletionCreateOrConnectWithoutHabitInput | HabitCompletionCreateOrConnectWithoutHabitInput[]
    createMany?: HabitCompletionCreateManyHabitInputEnvelope
    connect?: HabitCompletionWhereUniqueInput | HabitCompletionWhereUniqueInput[]
  }

  export type HabitCompletionUncheckedCreateNestedManyWithoutHabitInput = {
    create?: XOR<HabitCompletionCreateWithoutHabitInput, HabitCompletionUncheckedCreateWithoutHabitInput> | HabitCompletionCreateWithoutHabitInput[] | HabitCompletionUncheckedCreateWithoutHabitInput[]
    connectOrCreate?: HabitCompletionCreateOrConnectWithoutHabitInput | HabitCompletionCreateOrConnectWithoutHabitInput[]
    createMany?: HabitCompletionCreateManyHabitInputEnvelope
    connect?: HabitCompletionWhereUniqueInput | HabitCompletionWhereUniqueInput[]
  }

  export type EnumHabitFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.HabitFrequency
  }

  export type LifeOSProfileUpdateOneRequiredWithoutHabitsNestedInput = {
    create?: XOR<LifeOSProfileCreateWithoutHabitsInput, LifeOSProfileUncheckedCreateWithoutHabitsInput>
    connectOrCreate?: LifeOSProfileCreateOrConnectWithoutHabitsInput
    upsert?: LifeOSProfileUpsertWithoutHabitsInput
    connect?: LifeOSProfileWhereUniqueInput
    update?: XOR<XOR<LifeOSProfileUpdateToOneWithWhereWithoutHabitsInput, LifeOSProfileUpdateWithoutHabitsInput>, LifeOSProfileUncheckedUpdateWithoutHabitsInput>
  }

  export type HabitCompletionUpdateManyWithoutHabitNestedInput = {
    create?: XOR<HabitCompletionCreateWithoutHabitInput, HabitCompletionUncheckedCreateWithoutHabitInput> | HabitCompletionCreateWithoutHabitInput[] | HabitCompletionUncheckedCreateWithoutHabitInput[]
    connectOrCreate?: HabitCompletionCreateOrConnectWithoutHabitInput | HabitCompletionCreateOrConnectWithoutHabitInput[]
    upsert?: HabitCompletionUpsertWithWhereUniqueWithoutHabitInput | HabitCompletionUpsertWithWhereUniqueWithoutHabitInput[]
    createMany?: HabitCompletionCreateManyHabitInputEnvelope
    set?: HabitCompletionWhereUniqueInput | HabitCompletionWhereUniqueInput[]
    disconnect?: HabitCompletionWhereUniqueInput | HabitCompletionWhereUniqueInput[]
    delete?: HabitCompletionWhereUniqueInput | HabitCompletionWhereUniqueInput[]
    connect?: HabitCompletionWhereUniqueInput | HabitCompletionWhereUniqueInput[]
    update?: HabitCompletionUpdateWithWhereUniqueWithoutHabitInput | HabitCompletionUpdateWithWhereUniqueWithoutHabitInput[]
    updateMany?: HabitCompletionUpdateManyWithWhereWithoutHabitInput | HabitCompletionUpdateManyWithWhereWithoutHabitInput[]
    deleteMany?: HabitCompletionScalarWhereInput | HabitCompletionScalarWhereInput[]
  }

  export type HabitCompletionUncheckedUpdateManyWithoutHabitNestedInput = {
    create?: XOR<HabitCompletionCreateWithoutHabitInput, HabitCompletionUncheckedCreateWithoutHabitInput> | HabitCompletionCreateWithoutHabitInput[] | HabitCompletionUncheckedCreateWithoutHabitInput[]
    connectOrCreate?: HabitCompletionCreateOrConnectWithoutHabitInput | HabitCompletionCreateOrConnectWithoutHabitInput[]
    upsert?: HabitCompletionUpsertWithWhereUniqueWithoutHabitInput | HabitCompletionUpsertWithWhereUniqueWithoutHabitInput[]
    createMany?: HabitCompletionCreateManyHabitInputEnvelope
    set?: HabitCompletionWhereUniqueInput | HabitCompletionWhereUniqueInput[]
    disconnect?: HabitCompletionWhereUniqueInput | HabitCompletionWhereUniqueInput[]
    delete?: HabitCompletionWhereUniqueInput | HabitCompletionWhereUniqueInput[]
    connect?: HabitCompletionWhereUniqueInput | HabitCompletionWhereUniqueInput[]
    update?: HabitCompletionUpdateWithWhereUniqueWithoutHabitInput | HabitCompletionUpdateWithWhereUniqueWithoutHabitInput[]
    updateMany?: HabitCompletionUpdateManyWithWhereWithoutHabitInput | HabitCompletionUpdateManyWithWhereWithoutHabitInput[]
    deleteMany?: HabitCompletionScalarWhereInput | HabitCompletionScalarWhereInput[]
  }

  export type HabitCreateNestedOneWithoutCompletionsInput = {
    create?: XOR<HabitCreateWithoutCompletionsInput, HabitUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: HabitCreateOrConnectWithoutCompletionsInput
    connect?: HabitWhereUniqueInput
  }

  export type HabitUpdateOneRequiredWithoutCompletionsNestedInput = {
    create?: XOR<HabitCreateWithoutCompletionsInput, HabitUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: HabitCreateOrConnectWithoutCompletionsInput
    upsert?: HabitUpsertWithoutCompletionsInput
    connect?: HabitWhereUniqueInput
    update?: XOR<XOR<HabitUpdateToOneWithWhereWithoutCompletionsInput, HabitUpdateWithoutCompletionsInput>, HabitUncheckedUpdateWithoutCompletionsInput>
  }

  export type LifeOSProfileCreateNestedOneWithoutGoalsInput = {
    create?: XOR<LifeOSProfileCreateWithoutGoalsInput, LifeOSProfileUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: LifeOSProfileCreateOrConnectWithoutGoalsInput
    connect?: LifeOSProfileWhereUniqueInput
  }

  export type GoalMilestoneCreateNestedManyWithoutGoalInput = {
    create?: XOR<GoalMilestoneCreateWithoutGoalInput, GoalMilestoneUncheckedCreateWithoutGoalInput> | GoalMilestoneCreateWithoutGoalInput[] | GoalMilestoneUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: GoalMilestoneCreateOrConnectWithoutGoalInput | GoalMilestoneCreateOrConnectWithoutGoalInput[]
    createMany?: GoalMilestoneCreateManyGoalInputEnvelope
    connect?: GoalMilestoneWhereUniqueInput | GoalMilestoneWhereUniqueInput[]
  }

  export type GoalUpdateCreateNestedManyWithoutGoalInput = {
    create?: XOR<GoalUpdateCreateWithoutGoalInput, GoalUpdateUncheckedCreateWithoutGoalInput> | GoalUpdateCreateWithoutGoalInput[] | GoalUpdateUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: GoalUpdateCreateOrConnectWithoutGoalInput | GoalUpdateCreateOrConnectWithoutGoalInput[]
    createMany?: GoalUpdateCreateManyGoalInputEnvelope
    connect?: GoalUpdateWhereUniqueInput | GoalUpdateWhereUniqueInput[]
  }

  export type GoalMilestoneUncheckedCreateNestedManyWithoutGoalInput = {
    create?: XOR<GoalMilestoneCreateWithoutGoalInput, GoalMilestoneUncheckedCreateWithoutGoalInput> | GoalMilestoneCreateWithoutGoalInput[] | GoalMilestoneUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: GoalMilestoneCreateOrConnectWithoutGoalInput | GoalMilestoneCreateOrConnectWithoutGoalInput[]
    createMany?: GoalMilestoneCreateManyGoalInputEnvelope
    connect?: GoalMilestoneWhereUniqueInput | GoalMilestoneWhereUniqueInput[]
  }

  export type GoalUpdateUncheckedCreateNestedManyWithoutGoalInput = {
    create?: XOR<GoalUpdateCreateWithoutGoalInput, GoalUpdateUncheckedCreateWithoutGoalInput> | GoalUpdateCreateWithoutGoalInput[] | GoalUpdateUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: GoalUpdateCreateOrConnectWithoutGoalInput | GoalUpdateCreateOrConnectWithoutGoalInput[]
    createMany?: GoalUpdateCreateManyGoalInputEnvelope
    connect?: GoalUpdateWhereUniqueInput | GoalUpdateWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumGoalStatusFieldUpdateOperationsInput = {
    set?: $Enums.GoalStatus
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type LifeOSProfileUpdateOneRequiredWithoutGoalsNestedInput = {
    create?: XOR<LifeOSProfileCreateWithoutGoalsInput, LifeOSProfileUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: LifeOSProfileCreateOrConnectWithoutGoalsInput
    upsert?: LifeOSProfileUpsertWithoutGoalsInput
    connect?: LifeOSProfileWhereUniqueInput
    update?: XOR<XOR<LifeOSProfileUpdateToOneWithWhereWithoutGoalsInput, LifeOSProfileUpdateWithoutGoalsInput>, LifeOSProfileUncheckedUpdateWithoutGoalsInput>
  }

  export type GoalMilestoneUpdateManyWithoutGoalNestedInput = {
    create?: XOR<GoalMilestoneCreateWithoutGoalInput, GoalMilestoneUncheckedCreateWithoutGoalInput> | GoalMilestoneCreateWithoutGoalInput[] | GoalMilestoneUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: GoalMilestoneCreateOrConnectWithoutGoalInput | GoalMilestoneCreateOrConnectWithoutGoalInput[]
    upsert?: GoalMilestoneUpsertWithWhereUniqueWithoutGoalInput | GoalMilestoneUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: GoalMilestoneCreateManyGoalInputEnvelope
    set?: GoalMilestoneWhereUniqueInput | GoalMilestoneWhereUniqueInput[]
    disconnect?: GoalMilestoneWhereUniqueInput | GoalMilestoneWhereUniqueInput[]
    delete?: GoalMilestoneWhereUniqueInput | GoalMilestoneWhereUniqueInput[]
    connect?: GoalMilestoneWhereUniqueInput | GoalMilestoneWhereUniqueInput[]
    update?: GoalMilestoneUpdateWithWhereUniqueWithoutGoalInput | GoalMilestoneUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: GoalMilestoneUpdateManyWithWhereWithoutGoalInput | GoalMilestoneUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: GoalMilestoneScalarWhereInput | GoalMilestoneScalarWhereInput[]
  }

  export type GoalUpdateUpdateManyWithoutGoalNestedInput = {
    create?: XOR<GoalUpdateCreateWithoutGoalInput, GoalUpdateUncheckedCreateWithoutGoalInput> | GoalUpdateCreateWithoutGoalInput[] | GoalUpdateUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: GoalUpdateCreateOrConnectWithoutGoalInput | GoalUpdateCreateOrConnectWithoutGoalInput[]
    upsert?: GoalUpdateUpsertWithWhereUniqueWithoutGoalInput | GoalUpdateUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: GoalUpdateCreateManyGoalInputEnvelope
    set?: GoalUpdateWhereUniqueInput | GoalUpdateWhereUniqueInput[]
    disconnect?: GoalUpdateWhereUniqueInput | GoalUpdateWhereUniqueInput[]
    delete?: GoalUpdateWhereUniqueInput | GoalUpdateWhereUniqueInput[]
    connect?: GoalUpdateWhereUniqueInput | GoalUpdateWhereUniqueInput[]
    update?: GoalUpdateUpdateWithWhereUniqueWithoutGoalInput | GoalUpdateUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: GoalUpdateUpdateManyWithWhereWithoutGoalInput | GoalUpdateUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: GoalUpdateScalarWhereInput | GoalUpdateScalarWhereInput[]
  }

  export type GoalMilestoneUncheckedUpdateManyWithoutGoalNestedInput = {
    create?: XOR<GoalMilestoneCreateWithoutGoalInput, GoalMilestoneUncheckedCreateWithoutGoalInput> | GoalMilestoneCreateWithoutGoalInput[] | GoalMilestoneUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: GoalMilestoneCreateOrConnectWithoutGoalInput | GoalMilestoneCreateOrConnectWithoutGoalInput[]
    upsert?: GoalMilestoneUpsertWithWhereUniqueWithoutGoalInput | GoalMilestoneUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: GoalMilestoneCreateManyGoalInputEnvelope
    set?: GoalMilestoneWhereUniqueInput | GoalMilestoneWhereUniqueInput[]
    disconnect?: GoalMilestoneWhereUniqueInput | GoalMilestoneWhereUniqueInput[]
    delete?: GoalMilestoneWhereUniqueInput | GoalMilestoneWhereUniqueInput[]
    connect?: GoalMilestoneWhereUniqueInput | GoalMilestoneWhereUniqueInput[]
    update?: GoalMilestoneUpdateWithWhereUniqueWithoutGoalInput | GoalMilestoneUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: GoalMilestoneUpdateManyWithWhereWithoutGoalInput | GoalMilestoneUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: GoalMilestoneScalarWhereInput | GoalMilestoneScalarWhereInput[]
  }

  export type GoalUpdateUncheckedUpdateManyWithoutGoalNestedInput = {
    create?: XOR<GoalUpdateCreateWithoutGoalInput, GoalUpdateUncheckedCreateWithoutGoalInput> | GoalUpdateCreateWithoutGoalInput[] | GoalUpdateUncheckedCreateWithoutGoalInput[]
    connectOrCreate?: GoalUpdateCreateOrConnectWithoutGoalInput | GoalUpdateCreateOrConnectWithoutGoalInput[]
    upsert?: GoalUpdateUpsertWithWhereUniqueWithoutGoalInput | GoalUpdateUpsertWithWhereUniqueWithoutGoalInput[]
    createMany?: GoalUpdateCreateManyGoalInputEnvelope
    set?: GoalUpdateWhereUniqueInput | GoalUpdateWhereUniqueInput[]
    disconnect?: GoalUpdateWhereUniqueInput | GoalUpdateWhereUniqueInput[]
    delete?: GoalUpdateWhereUniqueInput | GoalUpdateWhereUniqueInput[]
    connect?: GoalUpdateWhereUniqueInput | GoalUpdateWhereUniqueInput[]
    update?: GoalUpdateUpdateWithWhereUniqueWithoutGoalInput | GoalUpdateUpdateWithWhereUniqueWithoutGoalInput[]
    updateMany?: GoalUpdateUpdateManyWithWhereWithoutGoalInput | GoalUpdateUpdateManyWithWhereWithoutGoalInput[]
    deleteMany?: GoalUpdateScalarWhereInput | GoalUpdateScalarWhereInput[]
  }

  export type GoalCreateNestedOneWithoutMilestonesInput = {
    create?: XOR<GoalCreateWithoutMilestonesInput, GoalUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: GoalCreateOrConnectWithoutMilestonesInput
    connect?: GoalWhereUniqueInput
  }

  export type EnumMilestoneStatusFieldUpdateOperationsInput = {
    set?: $Enums.MilestoneStatus
  }

  export type GoalUpdateOneRequiredWithoutMilestonesNestedInput = {
    create?: XOR<GoalCreateWithoutMilestonesInput, GoalUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: GoalCreateOrConnectWithoutMilestonesInput
    upsert?: GoalUpsertWithoutMilestonesInput
    connect?: GoalWhereUniqueInput
    update?: XOR<XOR<GoalUpdateToOneWithWhereWithoutMilestonesInput, GoalUpdateWithoutMilestonesInput>, GoalUncheckedUpdateWithoutMilestonesInput>
  }

  export type GoalCreateNestedOneWithoutUpdatesInput = {
    create?: XOR<GoalCreateWithoutUpdatesInput, GoalUncheckedCreateWithoutUpdatesInput>
    connectOrCreate?: GoalCreateOrConnectWithoutUpdatesInput
    connect?: GoalWhereUniqueInput
  }

  export type GoalUpdateOneRequiredWithoutUpdatesNestedInput = {
    create?: XOR<GoalCreateWithoutUpdatesInput, GoalUncheckedCreateWithoutUpdatesInput>
    connectOrCreate?: GoalCreateOrConnectWithoutUpdatesInput
    upsert?: GoalUpsertWithoutUpdatesInput
    connect?: GoalWhereUniqueInput
    update?: XOR<XOR<GoalUpdateToOneWithWhereWithoutUpdatesInput, GoalUpdateWithoutUpdatesInput>, GoalUncheckedUpdateWithoutUpdatesInput>
  }

  export type LifeOSProfileCreateNestedOneWithoutMeditationsInput = {
    create?: XOR<LifeOSProfileCreateWithoutMeditationsInput, LifeOSProfileUncheckedCreateWithoutMeditationsInput>
    connectOrCreate?: LifeOSProfileCreateOrConnectWithoutMeditationsInput
    connect?: LifeOSProfileWhereUniqueInput
  }

  export type LifeOSProfileUpdateOneRequiredWithoutMeditationsNestedInput = {
    create?: XOR<LifeOSProfileCreateWithoutMeditationsInput, LifeOSProfileUncheckedCreateWithoutMeditationsInput>
    connectOrCreate?: LifeOSProfileCreateOrConnectWithoutMeditationsInput
    upsert?: LifeOSProfileUpsertWithoutMeditationsInput
    connect?: LifeOSProfileWhereUniqueInput
    update?: XOR<XOR<LifeOSProfileUpdateToOneWithWhereWithoutMeditationsInput, LifeOSProfileUpdateWithoutMeditationsInput>, LifeOSProfileUncheckedUpdateWithoutMeditationsInput>
  }

  export type MoodEntryCreateemotionsInput = {
    set: string[]
  }

  export type MoodEntryCreateactivitiesInput = {
    set: string[]
  }

  export type LifeOSProfileCreateNestedOneWithoutMoodEntriesInput = {
    create?: XOR<LifeOSProfileCreateWithoutMoodEntriesInput, LifeOSProfileUncheckedCreateWithoutMoodEntriesInput>
    connectOrCreate?: LifeOSProfileCreateOrConnectWithoutMoodEntriesInput
    connect?: LifeOSProfileWhereUniqueInput
  }

  export type MoodEntryUpdateemotionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MoodEntryUpdateactivitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LifeOSProfileUpdateOneRequiredWithoutMoodEntriesNestedInput = {
    create?: XOR<LifeOSProfileCreateWithoutMoodEntriesInput, LifeOSProfileUncheckedCreateWithoutMoodEntriesInput>
    connectOrCreate?: LifeOSProfileCreateOrConnectWithoutMoodEntriesInput
    upsert?: LifeOSProfileUpsertWithoutMoodEntriesInput
    connect?: LifeOSProfileWhereUniqueInput
    update?: XOR<XOR<LifeOSProfileUpdateToOneWithWhereWithoutMoodEntriesInput, LifeOSProfileUpdateWithoutMoodEntriesInput>, LifeOSProfileUncheckedUpdateWithoutMoodEntriesInput>
  }

  export type JournalCreatetagsInput = {
    set: string[]
  }

  export type LifeOSProfileCreateNestedOneWithoutJournalsInput = {
    create?: XOR<LifeOSProfileCreateWithoutJournalsInput, LifeOSProfileUncheckedCreateWithoutJournalsInput>
    connectOrCreate?: LifeOSProfileCreateOrConnectWithoutJournalsInput
    connect?: LifeOSProfileWhereUniqueInput
  }

  export type JournalUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LifeOSProfileUpdateOneRequiredWithoutJournalsNestedInput = {
    create?: XOR<LifeOSProfileCreateWithoutJournalsInput, LifeOSProfileUncheckedCreateWithoutJournalsInput>
    connectOrCreate?: LifeOSProfileCreateOrConnectWithoutJournalsInput
    upsert?: LifeOSProfileUpsertWithoutJournalsInput
    connect?: LifeOSProfileWhereUniqueInput
    update?: XOR<XOR<LifeOSProfileUpdateToOneWithWhereWithoutJournalsInput, LifeOSProfileUpdateWithoutJournalsInput>, LifeOSProfileUncheckedUpdateWithoutJournalsInput>
  }

  export type UserCreateNestedOneWithoutCalendarEventsInput = {
    create?: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCalendarEventsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutCalendarEventsInput = {
    create?: XOR<ProjectCreateWithoutCalendarEventsInput, ProjectUncheckedCreateWithoutCalendarEventsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCalendarEventsInput
    connect?: ProjectWhereUniqueInput
  }

  export type EventAttendeeCreateNestedManyWithoutEventInput = {
    create?: XOR<EventAttendeeCreateWithoutEventInput, EventAttendeeUncheckedCreateWithoutEventInput> | EventAttendeeCreateWithoutEventInput[] | EventAttendeeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutEventInput | EventAttendeeCreateOrConnectWithoutEventInput[]
    createMany?: EventAttendeeCreateManyEventInputEnvelope
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
  }

  export type EventAttendeeUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventAttendeeCreateWithoutEventInput, EventAttendeeUncheckedCreateWithoutEventInput> | EventAttendeeCreateWithoutEventInput[] | EventAttendeeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutEventInput | EventAttendeeCreateOrConnectWithoutEventInput[]
    createMany?: EventAttendeeCreateManyEventInputEnvelope
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
  }

  export type EnumEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.EventType
  }

  export type UserUpdateOneRequiredWithoutCalendarEventsNestedInput = {
    create?: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCalendarEventsInput
    upsert?: UserUpsertWithoutCalendarEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCalendarEventsInput, UserUpdateWithoutCalendarEventsInput>, UserUncheckedUpdateWithoutCalendarEventsInput>
  }

  export type ProjectUpdateOneWithoutCalendarEventsNestedInput = {
    create?: XOR<ProjectCreateWithoutCalendarEventsInput, ProjectUncheckedCreateWithoutCalendarEventsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCalendarEventsInput
    upsert?: ProjectUpsertWithoutCalendarEventsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCalendarEventsInput, ProjectUpdateWithoutCalendarEventsInput>, ProjectUncheckedUpdateWithoutCalendarEventsInput>
  }

  export type EventAttendeeUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventAttendeeCreateWithoutEventInput, EventAttendeeUncheckedCreateWithoutEventInput> | EventAttendeeCreateWithoutEventInput[] | EventAttendeeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutEventInput | EventAttendeeCreateOrConnectWithoutEventInput[]
    upsert?: EventAttendeeUpsertWithWhereUniqueWithoutEventInput | EventAttendeeUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventAttendeeCreateManyEventInputEnvelope
    set?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    disconnect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    delete?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    update?: EventAttendeeUpdateWithWhereUniqueWithoutEventInput | EventAttendeeUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventAttendeeUpdateManyWithWhereWithoutEventInput | EventAttendeeUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventAttendeeScalarWhereInput | EventAttendeeScalarWhereInput[]
  }

  export type EventAttendeeUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventAttendeeCreateWithoutEventInput, EventAttendeeUncheckedCreateWithoutEventInput> | EventAttendeeCreateWithoutEventInput[] | EventAttendeeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventAttendeeCreateOrConnectWithoutEventInput | EventAttendeeCreateOrConnectWithoutEventInput[]
    upsert?: EventAttendeeUpsertWithWhereUniqueWithoutEventInput | EventAttendeeUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventAttendeeCreateManyEventInputEnvelope
    set?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    disconnect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    delete?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    connect?: EventAttendeeWhereUniqueInput | EventAttendeeWhereUniqueInput[]
    update?: EventAttendeeUpdateWithWhereUniqueWithoutEventInput | EventAttendeeUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventAttendeeUpdateManyWithWhereWithoutEventInput | EventAttendeeUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventAttendeeScalarWhereInput | EventAttendeeScalarWhereInput[]
  }

  export type CalendarEventCreateNestedOneWithoutAttendeesInput = {
    create?: XOR<CalendarEventCreateWithoutAttendeesInput, CalendarEventUncheckedCreateWithoutAttendeesInput>
    connectOrCreate?: CalendarEventCreateOrConnectWithoutAttendeesInput
    connect?: CalendarEventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEventAttendanceInput = {
    create?: XOR<UserCreateWithoutEventAttendanceInput, UserUncheckedCreateWithoutEventAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventAttendanceInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAttendeeStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendeeStatus
  }

  export type CalendarEventUpdateOneRequiredWithoutAttendeesNestedInput = {
    create?: XOR<CalendarEventCreateWithoutAttendeesInput, CalendarEventUncheckedCreateWithoutAttendeesInput>
    connectOrCreate?: CalendarEventCreateOrConnectWithoutAttendeesInput
    upsert?: CalendarEventUpsertWithoutAttendeesInput
    connect?: CalendarEventWhereUniqueInput
    update?: XOR<XOR<CalendarEventUpdateToOneWithWhereWithoutAttendeesInput, CalendarEventUpdateWithoutAttendeesInput>, CalendarEventUncheckedUpdateWithoutAttendeesInput>
  }

  export type UserUpdateOneRequiredWithoutEventAttendanceNestedInput = {
    create?: XOR<UserCreateWithoutEventAttendanceInput, UserUncheckedCreateWithoutEventAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventAttendanceInput
    upsert?: UserUpsertWithoutEventAttendanceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventAttendanceInput, UserUpdateWithoutEventAttendanceInput>, UserUncheckedUpdateWithoutEventAttendanceInput>
  }

  export type FinancialTransactionCreatetagsInput = {
    set: string[]
  }

  export type LifeOSProfileCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<LifeOSProfileCreateWithoutTransactionsInput, LifeOSProfileUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LifeOSProfileCreateOrConnectWithoutTransactionsInput
    connect?: LifeOSProfileWhereUniqueInput
  }

  export type BudgetCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<BudgetCreateWithoutTransactionsInput, BudgetUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutTransactionsInput
    connect?: BudgetWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type FinancialTransactionUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LifeOSProfileUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<LifeOSProfileCreateWithoutTransactionsInput, LifeOSProfileUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LifeOSProfileCreateOrConnectWithoutTransactionsInput
    upsert?: LifeOSProfileUpsertWithoutTransactionsInput
    connect?: LifeOSProfileWhereUniqueInput
    update?: XOR<XOR<LifeOSProfileUpdateToOneWithWhereWithoutTransactionsInput, LifeOSProfileUpdateWithoutTransactionsInput>, LifeOSProfileUncheckedUpdateWithoutTransactionsInput>
  }

  export type BudgetUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<BudgetCreateWithoutTransactionsInput, BudgetUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutTransactionsInput
    upsert?: BudgetUpsertWithoutTransactionsInput
    disconnect?: BudgetWhereInput | boolean
    delete?: BudgetWhereInput | boolean
    connect?: BudgetWhereUniqueInput
    update?: XOR<XOR<BudgetUpdateToOneWithWhereWithoutTransactionsInput, BudgetUpdateWithoutTransactionsInput>, BudgetUncheckedUpdateWithoutTransactionsInput>
  }

  export type LifeOSProfileCreateNestedOneWithoutBudgetsInput = {
    create?: XOR<LifeOSProfileCreateWithoutBudgetsInput, LifeOSProfileUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: LifeOSProfileCreateOrConnectWithoutBudgetsInput
    connect?: LifeOSProfileWhereUniqueInput
  }

  export type FinancialTransactionCreateNestedManyWithoutBudgetInput = {
    create?: XOR<FinancialTransactionCreateWithoutBudgetInput, FinancialTransactionUncheckedCreateWithoutBudgetInput> | FinancialTransactionCreateWithoutBudgetInput[] | FinancialTransactionUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: FinancialTransactionCreateOrConnectWithoutBudgetInput | FinancialTransactionCreateOrConnectWithoutBudgetInput[]
    createMany?: FinancialTransactionCreateManyBudgetInputEnvelope
    connect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
  }

  export type FinancialTransactionUncheckedCreateNestedManyWithoutBudgetInput = {
    create?: XOR<FinancialTransactionCreateWithoutBudgetInput, FinancialTransactionUncheckedCreateWithoutBudgetInput> | FinancialTransactionCreateWithoutBudgetInput[] | FinancialTransactionUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: FinancialTransactionCreateOrConnectWithoutBudgetInput | FinancialTransactionCreateOrConnectWithoutBudgetInput[]
    createMany?: FinancialTransactionCreateManyBudgetInputEnvelope
    connect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
  }

  export type EnumBudgetPeriodFieldUpdateOperationsInput = {
    set?: $Enums.BudgetPeriod
  }

  export type LifeOSProfileUpdateOneRequiredWithoutBudgetsNestedInput = {
    create?: XOR<LifeOSProfileCreateWithoutBudgetsInput, LifeOSProfileUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: LifeOSProfileCreateOrConnectWithoutBudgetsInput
    upsert?: LifeOSProfileUpsertWithoutBudgetsInput
    connect?: LifeOSProfileWhereUniqueInput
    update?: XOR<XOR<LifeOSProfileUpdateToOneWithWhereWithoutBudgetsInput, LifeOSProfileUpdateWithoutBudgetsInput>, LifeOSProfileUncheckedUpdateWithoutBudgetsInput>
  }

  export type FinancialTransactionUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<FinancialTransactionCreateWithoutBudgetInput, FinancialTransactionUncheckedCreateWithoutBudgetInput> | FinancialTransactionCreateWithoutBudgetInput[] | FinancialTransactionUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: FinancialTransactionCreateOrConnectWithoutBudgetInput | FinancialTransactionCreateOrConnectWithoutBudgetInput[]
    upsert?: FinancialTransactionUpsertWithWhereUniqueWithoutBudgetInput | FinancialTransactionUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: FinancialTransactionCreateManyBudgetInputEnvelope
    set?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    disconnect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    delete?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    connect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    update?: FinancialTransactionUpdateWithWhereUniqueWithoutBudgetInput | FinancialTransactionUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: FinancialTransactionUpdateManyWithWhereWithoutBudgetInput | FinancialTransactionUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: FinancialTransactionScalarWhereInput | FinancialTransactionScalarWhereInput[]
  }

  export type FinancialTransactionUncheckedUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<FinancialTransactionCreateWithoutBudgetInput, FinancialTransactionUncheckedCreateWithoutBudgetInput> | FinancialTransactionCreateWithoutBudgetInput[] | FinancialTransactionUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: FinancialTransactionCreateOrConnectWithoutBudgetInput | FinancialTransactionCreateOrConnectWithoutBudgetInput[]
    upsert?: FinancialTransactionUpsertWithWhereUniqueWithoutBudgetInput | FinancialTransactionUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: FinancialTransactionCreateManyBudgetInputEnvelope
    set?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    disconnect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    delete?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    connect?: FinancialTransactionWhereUniqueInput | FinancialTransactionWhereUniqueInput[]
    update?: FinancialTransactionUpdateWithWhereUniqueWithoutBudgetInput | FinancialTransactionUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: FinancialTransactionUpdateManyWithWhereWithoutBudgetInput | FinancialTransactionUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: FinancialTransactionScalarWhereInput | FinancialTransactionScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type NestedEnumVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityFilter<$PrismaModel> | $Enums.Visibility
  }

  export type NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type NestedEnumVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.Visibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisibilityFilter<$PrismaModel>
    _max?: NestedEnumVisibilityFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumProjectRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleFilter<$PrismaModel> | $Enums.ProjectRole
  }

  export type NestedEnumProjectRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleWithAggregatesFilter<$PrismaModel> | $Enums.ProjectRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectRoleFilter<$PrismaModel>
    _max?: NestedEnumProjectRoleFilter<$PrismaModel>
  }

  export type NestedEnumStoryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryStatus | EnumStoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoryStatus[] | ListEnumStoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryStatus[] | ListEnumStoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryStatusFilter<$PrismaModel> | $Enums.StoryStatus
  }

  export type NestedEnumStoryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoryStatus | EnumStoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoryStatus[] | ListEnumStoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoryStatus[] | ListEnumStoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoryStatusWithAggregatesFilter<$PrismaModel> | $Enums.StoryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoryStatusFilter<$PrismaModel>
    _max?: NestedEnumStoryStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumCommentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentStatus | EnumCommentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommentStatusFilter<$PrismaModel> | $Enums.CommentStatus
  }

  export type NestedEnumCommentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentStatus | EnumCommentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommentStatusWithAggregatesFilter<$PrismaModel> | $Enums.CommentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommentStatusFilter<$PrismaModel>
    _max?: NestedEnumCommentStatusFilter<$PrismaModel>
  }

  export type NestedEnumOpportunityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityType | EnumOpportunityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityType[] | ListEnumOpportunityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityType[] | ListEnumOpportunityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityTypeFilter<$PrismaModel> | $Enums.OpportunityType
  }

  export type NestedEnumOpportunityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityStatus | EnumOpportunityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityStatusFilter<$PrismaModel> | $Enums.OpportunityStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumOpportunityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityType | EnumOpportunityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityType[] | ListEnumOpportunityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityType[] | ListEnumOpportunityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityTypeWithAggregatesFilter<$PrismaModel> | $Enums.OpportunityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOpportunityTypeFilter<$PrismaModel>
    _max?: NestedEnumOpportunityTypeFilter<$PrismaModel>
  }

  export type NestedEnumOpportunityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityStatus | EnumOpportunityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityStatusWithAggregatesFilter<$PrismaModel> | $Enums.OpportunityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOpportunityStatusFilter<$PrismaModel>
    _max?: NestedEnumOpportunityStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumHabitFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.HabitFrequency | EnumHabitFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.HabitFrequency[] | ListEnumHabitFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.HabitFrequency[] | ListEnumHabitFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumHabitFrequencyFilter<$PrismaModel> | $Enums.HabitFrequency
  }

  export type NestedEnumHabitFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HabitFrequency | EnumHabitFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.HabitFrequency[] | ListEnumHabitFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.HabitFrequency[] | ListEnumHabitFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumHabitFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.HabitFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHabitFrequencyFilter<$PrismaModel>
    _max?: NestedEnumHabitFrequencyFilter<$PrismaModel>
  }

  export type NestedEnumGoalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalStatus | EnumGoalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalStatusFilter<$PrismaModel> | $Enums.GoalStatus
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumGoalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalStatus | EnumGoalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalStatus[] | ListEnumGoalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalStatusWithAggregatesFilter<$PrismaModel> | $Enums.GoalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGoalStatusFilter<$PrismaModel>
    _max?: NestedEnumGoalStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumMilestoneStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MilestoneStatus | EnumMilestoneStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMilestoneStatusFilter<$PrismaModel> | $Enums.MilestoneStatus
  }

  export type NestedEnumMilestoneStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MilestoneStatus | EnumMilestoneStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMilestoneStatusWithAggregatesFilter<$PrismaModel> | $Enums.MilestoneStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMilestoneStatusFilter<$PrismaModel>
    _max?: NestedEnumMilestoneStatusFilter<$PrismaModel>
  }

  export type NestedEnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type NestedEnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumAttendeeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendeeStatus | EnumAttendeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendeeStatus[] | ListEnumAttendeeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendeeStatus[] | ListEnumAttendeeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendeeStatusFilter<$PrismaModel> | $Enums.AttendeeStatus
  }

  export type NestedEnumAttendeeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendeeStatus | EnumAttendeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendeeStatus[] | ListEnumAttendeeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendeeStatus[] | ListEnumAttendeeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendeeStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendeeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendeeStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendeeStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumBudgetPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetPeriod | EnumBudgetPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetPeriodFilter<$PrismaModel> | $Enums.BudgetPeriod
  }

  export type NestedEnumBudgetPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetPeriod | EnumBudgetPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetPeriod[] | ListEnumBudgetPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetPeriodWithAggregatesFilter<$PrismaModel> | $Enums.BudgetPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBudgetPeriodFilter<$PrismaModel>
    _max?: NestedEnumBudgetPeriodFilter<$PrismaModel>
  }

  export type StoryCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    status?: $Enums.StoryStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: StoryCreatetagsInput | string[]
    coverImage?: string | null
    images?: StoryCreateimagesInput | string[]
    slug: string
    metaTitle?: string | null
    metaDescription?: string | null
    viewCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    project?: ProjectCreateNestedOneWithoutStoriesInput
    comments?: CommentCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    status?: $Enums.StoryStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: StoryCreatetagsInput | string[]
    coverImage?: string | null
    images?: StoryCreateimagesInput | string[]
    slug: string
    metaTitle?: string | null
    metaDescription?: string | null
    viewCount?: number
    shareCount?: number
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryCreateOrConnectWithoutAuthorInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutAuthorInput, StoryUncheckedCreateWithoutAuthorInput>
  }

  export type StoryCreateManyAuthorInputEnvelope = {
    data: StoryCreateManyAuthorInput | StoryCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMemberCreateWithoutUserInput = {
    id?: string
    role?: $Enums.ProjectRole
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
  }

  export type ProjectMemberUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    role?: $Enums.ProjectRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMemberCreateOrConnectWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberCreateManyUserInputEnvelope = {
    data: ProjectMemberCreateManyUserInput | ProjectMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    story: StoryCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    storyId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityApplicationCreateWithoutUserInput = {
    id?: string
    message: string
    resume?: string | null
    portfolio?: string | null
    status?: $Enums.ApplicationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunity: OpportunityCreateNestedOneWithoutApplicationsInput
  }

  export type OpportunityApplicationUncheckedCreateWithoutUserInput = {
    id?: string
    message: string
    resume?: string | null
    portfolio?: string | null
    status?: $Enums.ApplicationStatus
    opportunityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityApplicationCreateOrConnectWithoutUserInput = {
    where: OpportunityApplicationWhereUniqueInput
    create: XOR<OpportunityApplicationCreateWithoutUserInput, OpportunityApplicationUncheckedCreateWithoutUserInput>
  }

  export type OpportunityApplicationCreateManyUserInputEnvelope = {
    data: OpportunityApplicationCreateManyUserInput | OpportunityApplicationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LifeOSProfileCreateWithoutUserInput = {
    id?: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    habits?: HabitCreateNestedManyWithoutProfileInput
    goals?: GoalCreateNestedManyWithoutProfileInput
    moodEntries?: MoodEntryCreateNestedManyWithoutProfileInput
    meditations?: MeditationSessionCreateNestedManyWithoutProfileInput
    journals?: JournalCreateNestedManyWithoutProfileInput
    transactions?: FinancialTransactionCreateNestedManyWithoutProfileInput
    budgets?: BudgetCreateNestedManyWithoutProfileInput
  }

  export type LifeOSProfileUncheckedCreateWithoutUserInput = {
    id?: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    habits?: HabitUncheckedCreateNestedManyWithoutProfileInput
    goals?: GoalUncheckedCreateNestedManyWithoutProfileInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutProfileInput
    meditations?: MeditationSessionUncheckedCreateNestedManyWithoutProfileInput
    journals?: JournalUncheckedCreateNestedManyWithoutProfileInput
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutProfileInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProfileInput
  }

  export type LifeOSProfileCreateOrConnectWithoutUserInput = {
    where: LifeOSProfileWhereUniqueInput
    create: XOR<LifeOSProfileCreateWithoutUserInput, LifeOSProfileUncheckedCreateWithoutUserInput>
  }

  export type CalendarEventCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    isAllDay?: boolean
    location?: string | null
    url?: string | null
    category?: string | null
    color?: string | null
    isRecurring?: boolean
    recurrenceRule?: string | null
    parentEventId?: string | null
    eventType?: $Enums.EventType
    visibility?: $Enums.Visibility
    communityEvent?: boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutCalendarEventsInput
    attendees?: EventAttendeeCreateNestedManyWithoutEventInput
  }

  export type CalendarEventUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    isAllDay?: boolean
    location?: string | null
    url?: string | null
    category?: string | null
    color?: string | null
    isRecurring?: boolean
    recurrenceRule?: string | null
    parentEventId?: string | null
    eventType?: $Enums.EventType
    visibility?: $Enums.Visibility
    projectId?: string | null
    communityEvent?: boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    attendees?: EventAttendeeUncheckedCreateNestedManyWithoutEventInput
  }

  export type CalendarEventCreateOrConnectWithoutUserInput = {
    where: CalendarEventWhereUniqueInput
    create: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput>
  }

  export type CalendarEventCreateManyUserInputEnvelope = {
    data: CalendarEventCreateManyUserInput | CalendarEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventAttendeeCreateWithoutUserInput = {
    id?: string
    status?: $Enums.AttendeeStatus
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: CalendarEventCreateNestedOneWithoutAttendeesInput
  }

  export type EventAttendeeUncheckedCreateWithoutUserInput = {
    id?: string
    eventId: string
    status?: $Enums.AttendeeStatus
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventAttendeeCreateOrConnectWithoutUserInput = {
    where: EventAttendeeWhereUniqueInput
    create: XOR<EventAttendeeCreateWithoutUserInput, EventAttendeeUncheckedCreateWithoutUserInput>
  }

  export type EventAttendeeCreateManyUserInputEnvelope = {
    data: EventAttendeeCreateManyUserInput | EventAttendeeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StoryUpsertWithWhereUniqueWithoutAuthorInput = {
    where: StoryWhereUniqueInput
    update: XOR<StoryUpdateWithoutAuthorInput, StoryUncheckedUpdateWithoutAuthorInput>
    create: XOR<StoryCreateWithoutAuthorInput, StoryUncheckedCreateWithoutAuthorInput>
  }

  export type StoryUpdateWithWhereUniqueWithoutAuthorInput = {
    where: StoryWhereUniqueInput
    data: XOR<StoryUpdateWithoutAuthorInput, StoryUncheckedUpdateWithoutAuthorInput>
  }

  export type StoryUpdateManyWithWhereWithoutAuthorInput = {
    where: StoryScalarWhereInput
    data: XOR<StoryUpdateManyMutationInput, StoryUncheckedUpdateManyWithoutAuthorInput>
  }

  export type StoryScalarWhereInput = {
    AND?: StoryScalarWhereInput | StoryScalarWhereInput[]
    OR?: StoryScalarWhereInput[]
    NOT?: StoryScalarWhereInput | StoryScalarWhereInput[]
    id?: StringFilter<"Story"> | string
    title?: StringFilter<"Story"> | string
    content?: StringFilter<"Story"> | string
    excerpt?: StringNullableFilter<"Story"> | string | null
    status?: EnumStoryStatusFilter<"Story"> | $Enums.StoryStatus
    visibility?: EnumVisibilityFilter<"Story"> | $Enums.Visibility
    category?: StringNullableFilter<"Story"> | string | null
    tags?: StringNullableListFilter<"Story">
    coverImage?: StringNullableFilter<"Story"> | string | null
    images?: StringNullableListFilter<"Story">
    slug?: StringFilter<"Story"> | string
    metaTitle?: StringNullableFilter<"Story"> | string | null
    metaDescription?: StringNullableFilter<"Story"> | string | null
    viewCount?: IntFilter<"Story"> | number
    shareCount?: IntFilter<"Story"> | number
    authorId?: StringFilter<"Story"> | string
    projectId?: StringNullableFilter<"Story"> | string | null
    createdAt?: DateTimeFilter<"Story"> | Date | string
    updatedAt?: DateTimeFilter<"Story"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Story"> | Date | string | null
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutUserInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectMemberScalarWhereInput = {
    AND?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    OR?: ProjectMemberScalarWhereInput[]
    NOT?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    id?: StringFilter<"ProjectMember"> | string
    userId?: StringFilter<"ProjectMember"> | string
    projectId?: StringFilter<"ProjectMember"> | string
    role?: EnumProjectRoleFilter<"ProjectMember"> | $Enums.ProjectRole
    createdAt?: DateTimeFilter<"ProjectMember"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMember"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    status?: EnumCommentStatusFilter<"Comment"> | $Enums.CommentStatus
    authorId?: StringFilter<"Comment"> | string
    storyId?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type OpportunityApplicationUpsertWithWhereUniqueWithoutUserInput = {
    where: OpportunityApplicationWhereUniqueInput
    update: XOR<OpportunityApplicationUpdateWithoutUserInput, OpportunityApplicationUncheckedUpdateWithoutUserInput>
    create: XOR<OpportunityApplicationCreateWithoutUserInput, OpportunityApplicationUncheckedCreateWithoutUserInput>
  }

  export type OpportunityApplicationUpdateWithWhereUniqueWithoutUserInput = {
    where: OpportunityApplicationWhereUniqueInput
    data: XOR<OpportunityApplicationUpdateWithoutUserInput, OpportunityApplicationUncheckedUpdateWithoutUserInput>
  }

  export type OpportunityApplicationUpdateManyWithWhereWithoutUserInput = {
    where: OpportunityApplicationScalarWhereInput
    data: XOR<OpportunityApplicationUpdateManyMutationInput, OpportunityApplicationUncheckedUpdateManyWithoutUserInput>
  }

  export type OpportunityApplicationScalarWhereInput = {
    AND?: OpportunityApplicationScalarWhereInput | OpportunityApplicationScalarWhereInput[]
    OR?: OpportunityApplicationScalarWhereInput[]
    NOT?: OpportunityApplicationScalarWhereInput | OpportunityApplicationScalarWhereInput[]
    id?: StringFilter<"OpportunityApplication"> | string
    message?: StringFilter<"OpportunityApplication"> | string
    resume?: StringNullableFilter<"OpportunityApplication"> | string | null
    portfolio?: StringNullableFilter<"OpportunityApplication"> | string | null
    status?: EnumApplicationStatusFilter<"OpportunityApplication"> | $Enums.ApplicationStatus
    userId?: StringFilter<"OpportunityApplication"> | string
    opportunityId?: StringFilter<"OpportunityApplication"> | string
    createdAt?: DateTimeFilter<"OpportunityApplication"> | Date | string
    updatedAt?: DateTimeFilter<"OpportunityApplication"> | Date | string
  }

  export type LifeOSProfileUpsertWithoutUserInput = {
    update: XOR<LifeOSProfileUpdateWithoutUserInput, LifeOSProfileUncheckedUpdateWithoutUserInput>
    create: XOR<LifeOSProfileCreateWithoutUserInput, LifeOSProfileUncheckedCreateWithoutUserInput>
    where?: LifeOSProfileWhereInput
  }

  export type LifeOSProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: LifeOSProfileWhereInput
    data: XOR<LifeOSProfileUpdateWithoutUserInput, LifeOSProfileUncheckedUpdateWithoutUserInput>
  }

  export type LifeOSProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habits?: HabitUpdateManyWithoutProfileNestedInput
    goals?: GoalUpdateManyWithoutProfileNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutProfileNestedInput
    meditations?: MeditationSessionUpdateManyWithoutProfileNestedInput
    journals?: JournalUpdateManyWithoutProfileNestedInput
    transactions?: FinancialTransactionUpdateManyWithoutProfileNestedInput
    budgets?: BudgetUpdateManyWithoutProfileNestedInput
  }

  export type LifeOSProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habits?: HabitUncheckedUpdateManyWithoutProfileNestedInput
    goals?: GoalUncheckedUpdateManyWithoutProfileNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutProfileNestedInput
    meditations?: MeditationSessionUncheckedUpdateManyWithoutProfileNestedInput
    journals?: JournalUncheckedUpdateManyWithoutProfileNestedInput
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutProfileNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type CalendarEventUpsertWithWhereUniqueWithoutUserInput = {
    where: CalendarEventWhereUniqueInput
    update: XOR<CalendarEventUpdateWithoutUserInput, CalendarEventUncheckedUpdateWithoutUserInput>
    create: XOR<CalendarEventCreateWithoutUserInput, CalendarEventUncheckedCreateWithoutUserInput>
  }

  export type CalendarEventUpdateWithWhereUniqueWithoutUserInput = {
    where: CalendarEventWhereUniqueInput
    data: XOR<CalendarEventUpdateWithoutUserInput, CalendarEventUncheckedUpdateWithoutUserInput>
  }

  export type CalendarEventUpdateManyWithWhereWithoutUserInput = {
    where: CalendarEventScalarWhereInput
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyWithoutUserInput>
  }

  export type CalendarEventScalarWhereInput = {
    AND?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
    OR?: CalendarEventScalarWhereInput[]
    NOT?: CalendarEventScalarWhereInput | CalendarEventScalarWhereInput[]
    id?: StringFilter<"CalendarEvent"> | string
    userId?: StringFilter<"CalendarEvent"> | string
    title?: StringFilter<"CalendarEvent"> | string
    description?: StringNullableFilter<"CalendarEvent"> | string | null
    startTime?: DateTimeFilter<"CalendarEvent"> | Date | string
    endTime?: DateTimeNullableFilter<"CalendarEvent"> | Date | string | null
    isAllDay?: BoolFilter<"CalendarEvent"> | boolean
    location?: StringNullableFilter<"CalendarEvent"> | string | null
    url?: StringNullableFilter<"CalendarEvent"> | string | null
    category?: StringNullableFilter<"CalendarEvent"> | string | null
    color?: StringNullableFilter<"CalendarEvent"> | string | null
    isRecurring?: BoolFilter<"CalendarEvent"> | boolean
    recurrenceRule?: StringNullableFilter<"CalendarEvent"> | string | null
    parentEventId?: StringNullableFilter<"CalendarEvent"> | string | null
    eventType?: EnumEventTypeFilter<"CalendarEvent"> | $Enums.EventType
    visibility?: EnumVisibilityFilter<"CalendarEvent"> | $Enums.Visibility
    projectId?: StringNullableFilter<"CalendarEvent"> | string | null
    communityEvent?: BoolFilter<"CalendarEvent"> | boolean
    reminders?: JsonFilter<"CalendarEvent">
    createdAt?: DateTimeFilter<"CalendarEvent"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarEvent"> | Date | string
  }

  export type EventAttendeeUpsertWithWhereUniqueWithoutUserInput = {
    where: EventAttendeeWhereUniqueInput
    update: XOR<EventAttendeeUpdateWithoutUserInput, EventAttendeeUncheckedUpdateWithoutUserInput>
    create: XOR<EventAttendeeCreateWithoutUserInput, EventAttendeeUncheckedCreateWithoutUserInput>
  }

  export type EventAttendeeUpdateWithWhereUniqueWithoutUserInput = {
    where: EventAttendeeWhereUniqueInput
    data: XOR<EventAttendeeUpdateWithoutUserInput, EventAttendeeUncheckedUpdateWithoutUserInput>
  }

  export type EventAttendeeUpdateManyWithWhereWithoutUserInput = {
    where: EventAttendeeScalarWhereInput
    data: XOR<EventAttendeeUpdateManyMutationInput, EventAttendeeUncheckedUpdateManyWithoutUserInput>
  }

  export type EventAttendeeScalarWhereInput = {
    AND?: EventAttendeeScalarWhereInput | EventAttendeeScalarWhereInput[]
    OR?: EventAttendeeScalarWhereInput[]
    NOT?: EventAttendeeScalarWhereInput | EventAttendeeScalarWhereInput[]
    id?: StringFilter<"EventAttendee"> | string
    eventId?: StringFilter<"EventAttendee"> | string
    userId?: StringFilter<"EventAttendee"> | string
    status?: EnumAttendeeStatusFilter<"EventAttendee"> | $Enums.AttendeeStatus
    response?: StringNullableFilter<"EventAttendee"> | string | null
    createdAt?: DateTimeFilter<"EventAttendee"> | Date | string
    updatedAt?: DateTimeFilter<"EventAttendee"> | Date | string
  }

  export type ProjectMemberCreateWithoutProjectInput = {
    id?: string
    role?: $Enums.ProjectRole
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectsInput
  }

  export type ProjectMemberUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    role?: $Enums.ProjectRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMemberCreateOrConnectWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberCreateManyProjectInputEnvelope = {
    data: ProjectMemberCreateManyProjectInput | ProjectMemberCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type StoryCreateWithoutProjectInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    status?: $Enums.StoryStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: StoryCreatetagsInput | string[]
    coverImage?: string | null
    images?: StoryCreateimagesInput | string[]
    slug: string
    metaTitle?: string | null
    metaDescription?: string | null
    viewCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    author: UserCreateNestedOneWithoutStoriesInput
    comments?: CommentCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    status?: $Enums.StoryStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: StoryCreatetagsInput | string[]
    coverImage?: string | null
    images?: StoryCreateimagesInput | string[]
    slug: string
    metaTitle?: string | null
    metaDescription?: string | null
    viewCount?: number
    shareCount?: number
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryCreateOrConnectWithoutProjectInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutProjectInput, StoryUncheckedCreateWithoutProjectInput>
  }

  export type StoryCreateManyProjectInputEnvelope = {
    data: StoryCreateManyProjectInput | StoryCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityCreateWithoutProjectInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    type: $Enums.OpportunityType
    status?: $Enums.OpportunityStatus
    category?: string | null
    tags?: OpportunityCreatetagsInput | string[]
    skills?: OpportunityCreateskillsInput | string[]
    timeCommitment?: string | null
    location?: string | null
    remote?: boolean
    isPaid?: boolean
    compensation?: string | null
    deadline?: Date | string | null
    startDate?: Date | string | null
    duration?: string | null
    coverImage?: string | null
    images?: OpportunityCreateimagesInput | string[]
    contactEmail?: string | null
    contactPhone?: string | null
    applicationUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: OpportunityApplicationCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    type: $Enums.OpportunityType
    status?: $Enums.OpportunityStatus
    category?: string | null
    tags?: OpportunityCreatetagsInput | string[]
    skills?: OpportunityCreateskillsInput | string[]
    timeCommitment?: string | null
    location?: string | null
    remote?: boolean
    isPaid?: boolean
    compensation?: string | null
    deadline?: Date | string | null
    startDate?: Date | string | null
    duration?: string | null
    coverImage?: string | null
    images?: OpportunityCreateimagesInput | string[]
    contactEmail?: string | null
    contactPhone?: string | null
    applicationUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: OpportunityApplicationUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutProjectInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutProjectInput, OpportunityUncheckedCreateWithoutProjectInput>
  }

  export type OpportunityCreateManyProjectInputEnvelope = {
    data: OpportunityCreateManyProjectInput | OpportunityCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CalendarEventCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    isAllDay?: boolean
    location?: string | null
    url?: string | null
    category?: string | null
    color?: string | null
    isRecurring?: boolean
    recurrenceRule?: string | null
    parentEventId?: string | null
    eventType?: $Enums.EventType
    visibility?: $Enums.Visibility
    communityEvent?: boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCalendarEventsInput
    attendees?: EventAttendeeCreateNestedManyWithoutEventInput
  }

  export type CalendarEventUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    isAllDay?: boolean
    location?: string | null
    url?: string | null
    category?: string | null
    color?: string | null
    isRecurring?: boolean
    recurrenceRule?: string | null
    parentEventId?: string | null
    eventType?: $Enums.EventType
    visibility?: $Enums.Visibility
    communityEvent?: boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    attendees?: EventAttendeeUncheckedCreateNestedManyWithoutEventInput
  }

  export type CalendarEventCreateOrConnectWithoutProjectInput = {
    where: CalendarEventWhereUniqueInput
    create: XOR<CalendarEventCreateWithoutProjectInput, CalendarEventUncheckedCreateWithoutProjectInput>
  }

  export type CalendarEventCreateManyProjectInputEnvelope = {
    data: CalendarEventCreateManyProjectInput | CalendarEventCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type StoryUpsertWithWhereUniqueWithoutProjectInput = {
    where: StoryWhereUniqueInput
    update: XOR<StoryUpdateWithoutProjectInput, StoryUncheckedUpdateWithoutProjectInput>
    create: XOR<StoryCreateWithoutProjectInput, StoryUncheckedCreateWithoutProjectInput>
  }

  export type StoryUpdateWithWhereUniqueWithoutProjectInput = {
    where: StoryWhereUniqueInput
    data: XOR<StoryUpdateWithoutProjectInput, StoryUncheckedUpdateWithoutProjectInput>
  }

  export type StoryUpdateManyWithWhereWithoutProjectInput = {
    where: StoryScalarWhereInput
    data: XOR<StoryUpdateManyMutationInput, StoryUncheckedUpdateManyWithoutProjectInput>
  }

  export type OpportunityUpsertWithWhereUniqueWithoutProjectInput = {
    where: OpportunityWhereUniqueInput
    update: XOR<OpportunityUpdateWithoutProjectInput, OpportunityUncheckedUpdateWithoutProjectInput>
    create: XOR<OpportunityCreateWithoutProjectInput, OpportunityUncheckedCreateWithoutProjectInput>
  }

  export type OpportunityUpdateWithWhereUniqueWithoutProjectInput = {
    where: OpportunityWhereUniqueInput
    data: XOR<OpportunityUpdateWithoutProjectInput, OpportunityUncheckedUpdateWithoutProjectInput>
  }

  export type OpportunityUpdateManyWithWhereWithoutProjectInput = {
    where: OpportunityScalarWhereInput
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyWithoutProjectInput>
  }

  export type OpportunityScalarWhereInput = {
    AND?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
    OR?: OpportunityScalarWhereInput[]
    NOT?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
    id?: StringFilter<"Opportunity"> | string
    title?: StringFilter<"Opportunity"> | string
    description?: StringFilter<"Opportunity"> | string
    content?: StringNullableFilter<"Opportunity"> | string | null
    type?: EnumOpportunityTypeFilter<"Opportunity"> | $Enums.OpportunityType
    status?: EnumOpportunityStatusFilter<"Opportunity"> | $Enums.OpportunityStatus
    category?: StringNullableFilter<"Opportunity"> | string | null
    tags?: StringNullableListFilter<"Opportunity">
    skills?: StringNullableListFilter<"Opportunity">
    timeCommitment?: StringNullableFilter<"Opportunity"> | string | null
    location?: StringNullableFilter<"Opportunity"> | string | null
    remote?: BoolFilter<"Opportunity"> | boolean
    isPaid?: BoolFilter<"Opportunity"> | boolean
    compensation?: StringNullableFilter<"Opportunity"> | string | null
    deadline?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    startDate?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    duration?: StringNullableFilter<"Opportunity"> | string | null
    coverImage?: StringNullableFilter<"Opportunity"> | string | null
    images?: StringNullableListFilter<"Opportunity">
    projectId?: StringNullableFilter<"Opportunity"> | string | null
    contactEmail?: StringNullableFilter<"Opportunity"> | string | null
    contactPhone?: StringNullableFilter<"Opportunity"> | string | null
    applicationUrl?: StringNullableFilter<"Opportunity"> | string | null
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeFilter<"Opportunity"> | Date | string
  }

  export type CalendarEventUpsertWithWhereUniqueWithoutProjectInput = {
    where: CalendarEventWhereUniqueInput
    update: XOR<CalendarEventUpdateWithoutProjectInput, CalendarEventUncheckedUpdateWithoutProjectInput>
    create: XOR<CalendarEventCreateWithoutProjectInput, CalendarEventUncheckedCreateWithoutProjectInput>
  }

  export type CalendarEventUpdateWithWhereUniqueWithoutProjectInput = {
    where: CalendarEventWhereUniqueInput
    data: XOR<CalendarEventUpdateWithoutProjectInput, CalendarEventUncheckedUpdateWithoutProjectInput>
  }

  export type CalendarEventUpdateManyWithWhereWithoutProjectInput = {
    where: CalendarEventScalarWhereInput
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyWithoutProjectInput>
  }

  export type UserCreateWithoutProjectsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    emailVerified?: Date | string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: UserCreateskillsInput | string[]
    interests?: UserCreateinterestsInput | string[]
    stories?: StoryCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    opportunities?: OpportunityApplicationCreateNestedManyWithoutUserInput
    lifeOSProfile?: LifeOSProfileCreateNestedOneWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventAttendance?: EventAttendeeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    emailVerified?: Date | string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: UserCreateskillsInput | string[]
    interests?: UserCreateinterestsInput | string[]
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    opportunities?: OpportunityApplicationUncheckedCreateNestedManyWithoutUserInput
    lifeOSProfile?: LifeOSProfileUncheckedCreateNestedOneWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventAttendance?: EventAttendeeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectCreateWithoutMembersInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    status?: $Enums.ProjectStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: ProjectCreatetagsInput | string[]
    location?: string | null
    region?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: string | null
    images?: ProjectCreateimagesInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    stories?: StoryCreateNestedManyWithoutProjectInput
    opportunities?: OpportunityCreateNestedManyWithoutProjectInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMembersInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    status?: $Enums.ProjectStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: ProjectCreatetagsInput | string[]
    location?: string | null
    region?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: string | null
    images?: ProjectCreateimagesInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    stories?: StoryUncheckedCreateNestedManyWithoutProjectInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutProjectInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
  }

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: UserUpdateskillsInput | string[]
    interests?: UserUpdateinterestsInput | string[]
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    opportunities?: OpportunityApplicationUpdateManyWithoutUserNestedInput
    lifeOSProfile?: LifeOSProfileUpdateOneWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventAttendance?: EventAttendeeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: UserUpdateskillsInput | string[]
    interests?: UserUpdateinterestsInput | string[]
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    opportunities?: OpportunityApplicationUncheckedUpdateManyWithoutUserNestedInput
    lifeOSProfile?: LifeOSProfileUncheckedUpdateOneWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventAttendance?: EventAttendeeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutMembersInput = {
    update: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMembersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProjectUpdatetagsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProjectUpdateimagesInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stories?: StoryUpdateManyWithoutProjectNestedInput
    opportunities?: OpportunityUpdateManyWithoutProjectNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProjectUpdatetagsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProjectUpdateimagesInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stories?: StoryUncheckedUpdateManyWithoutProjectNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutProjectNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserCreateWithoutStoriesInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    emailVerified?: Date | string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: UserCreateskillsInput | string[]
    interests?: UserCreateinterestsInput | string[]
    projects?: ProjectMemberCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    opportunities?: OpportunityApplicationCreateNestedManyWithoutUserInput
    lifeOSProfile?: LifeOSProfileCreateNestedOneWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventAttendance?: EventAttendeeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStoriesInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    emailVerified?: Date | string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: UserCreateskillsInput | string[]
    interests?: UserCreateinterestsInput | string[]
    projects?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    opportunities?: OpportunityApplicationUncheckedCreateNestedManyWithoutUserInput
    lifeOSProfile?: LifeOSProfileUncheckedCreateNestedOneWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventAttendance?: EventAttendeeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
  }

  export type ProjectCreateWithoutStoriesInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    status?: $Enums.ProjectStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: ProjectCreatetagsInput | string[]
    location?: string | null
    region?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: string | null
    images?: ProjectCreateimagesInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    opportunities?: OpportunityCreateNestedManyWithoutProjectInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutStoriesInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    status?: $Enums.ProjectStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: ProjectCreatetagsInput | string[]
    location?: string | null
    region?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: string | null
    images?: ProjectCreateimagesInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutProjectInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutStoriesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutStoriesInput, ProjectUncheckedCreateWithoutStoriesInput>
  }

  export type CommentCreateWithoutStoryInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutStoryInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    authorId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutStoryInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutStoryInput, CommentUncheckedCreateWithoutStoryInput>
  }

  export type CommentCreateManyStoryInputEnvelope = {
    data: CommentCreateManyStoryInput | CommentCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStoriesInput = {
    update: XOR<UserUpdateWithoutStoriesInput, UserUncheckedUpdateWithoutStoriesInput>
    create: XOR<UserCreateWithoutStoriesInput, UserUncheckedCreateWithoutStoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStoriesInput, UserUncheckedUpdateWithoutStoriesInput>
  }

  export type UserUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: UserUpdateskillsInput | string[]
    interests?: UserUpdateinterestsInput | string[]
    projects?: ProjectMemberUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    opportunities?: OpportunityApplicationUpdateManyWithoutUserNestedInput
    lifeOSProfile?: LifeOSProfileUpdateOneWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventAttendance?: EventAttendeeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: UserUpdateskillsInput | string[]
    interests?: UserUpdateinterestsInput | string[]
    projects?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    opportunities?: OpportunityApplicationUncheckedUpdateManyWithoutUserNestedInput
    lifeOSProfile?: LifeOSProfileUncheckedUpdateOneWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventAttendance?: EventAttendeeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutStoriesInput = {
    update: XOR<ProjectUpdateWithoutStoriesInput, ProjectUncheckedUpdateWithoutStoriesInput>
    create: XOR<ProjectCreateWithoutStoriesInput, ProjectUncheckedCreateWithoutStoriesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutStoriesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutStoriesInput, ProjectUncheckedUpdateWithoutStoriesInput>
  }

  export type ProjectUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProjectUpdatetagsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProjectUpdateimagesInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    opportunities?: OpportunityUpdateManyWithoutProjectNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProjectUpdatetagsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProjectUpdateimagesInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutProjectNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutStoryInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutStoryInput, CommentUncheckedUpdateWithoutStoryInput>
    create: XOR<CommentCreateWithoutStoryInput, CommentUncheckedCreateWithoutStoryInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutStoryInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutStoryInput, CommentUncheckedUpdateWithoutStoryInput>
  }

  export type CommentUpdateManyWithWhereWithoutStoryInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutStoryInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    emailVerified?: Date | string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: UserCreateskillsInput | string[]
    interests?: UserCreateinterestsInput | string[]
    stories?: StoryCreateNestedManyWithoutAuthorInput
    projects?: ProjectMemberCreateNestedManyWithoutUserInput
    opportunities?: OpportunityApplicationCreateNestedManyWithoutUserInput
    lifeOSProfile?: LifeOSProfileCreateNestedOneWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventAttendance?: EventAttendeeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    emailVerified?: Date | string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: UserCreateskillsInput | string[]
    interests?: UserCreateinterestsInput | string[]
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    projects?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    opportunities?: OpportunityApplicationUncheckedCreateNestedManyWithoutUserInput
    lifeOSProfile?: LifeOSProfileUncheckedCreateNestedOneWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventAttendance?: EventAttendeeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type StoryCreateWithoutCommentsInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    status?: $Enums.StoryStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: StoryCreatetagsInput | string[]
    coverImage?: string | null
    images?: StoryCreateimagesInput | string[]
    slug: string
    metaTitle?: string | null
    metaDescription?: string | null
    viewCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    author: UserCreateNestedOneWithoutStoriesInput
    project?: ProjectCreateNestedOneWithoutStoriesInput
  }

  export type StoryUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    status?: $Enums.StoryStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: StoryCreatetagsInput | string[]
    coverImage?: string | null
    images?: StoryCreateimagesInput | string[]
    slug: string
    metaTitle?: string | null
    metaDescription?: string | null
    viewCount?: number
    shareCount?: number
    authorId: string
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type StoryCreateOrConnectWithoutCommentsInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutCommentsInput, StoryUncheckedCreateWithoutCommentsInput>
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
    story: StoryCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    authorId: string
    storyId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutParentInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
    story: StoryCreateNestedOneWithoutCommentsInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    authorId: string
    storyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: UserUpdateskillsInput | string[]
    interests?: UserUpdateinterestsInput | string[]
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    projects?: ProjectMemberUpdateManyWithoutUserNestedInput
    opportunities?: OpportunityApplicationUpdateManyWithoutUserNestedInput
    lifeOSProfile?: LifeOSProfileUpdateOneWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventAttendance?: EventAttendeeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: UserUpdateskillsInput | string[]
    interests?: UserUpdateinterestsInput | string[]
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    projects?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    opportunities?: OpportunityApplicationUncheckedUpdateManyWithoutUserNestedInput
    lifeOSProfile?: LifeOSProfileUncheckedUpdateOneWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventAttendance?: EventAttendeeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StoryUpsertWithoutCommentsInput = {
    update: XOR<StoryUpdateWithoutCommentsInput, StoryUncheckedUpdateWithoutCommentsInput>
    create: XOR<StoryCreateWithoutCommentsInput, StoryUncheckedCreateWithoutCommentsInput>
    where?: StoryWhereInput
  }

  export type StoryUpdateToOneWithWhereWithoutCommentsInput = {
    where?: StoryWhereInput
    data: XOR<StoryUpdateWithoutCommentsInput, StoryUncheckedUpdateWithoutCommentsInput>
  }

  export type StoryUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: StoryUpdateimagesInput | string[]
    slug?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: UserUpdateOneRequiredWithoutStoriesNestedInput
    project?: ProjectUpdateOneWithoutStoriesNestedInput
  }

  export type StoryUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: StoryUpdateimagesInput | string[]
    slug?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    story?: StoryUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    authorId?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentInput>
  }

  export type ProjectCreateWithoutOpportunitiesInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    status?: $Enums.ProjectStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: ProjectCreatetagsInput | string[]
    location?: string | null
    region?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: string | null
    images?: ProjectCreateimagesInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    stories?: StoryCreateNestedManyWithoutProjectInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutOpportunitiesInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    status?: $Enums.ProjectStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: ProjectCreatetagsInput | string[]
    location?: string | null
    region?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: string | null
    images?: ProjectCreateimagesInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    stories?: StoryUncheckedCreateNestedManyWithoutProjectInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutOpportunitiesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutOpportunitiesInput, ProjectUncheckedCreateWithoutOpportunitiesInput>
  }

  export type OpportunityApplicationCreateWithoutOpportunityInput = {
    id?: string
    message: string
    resume?: string | null
    portfolio?: string | null
    status?: $Enums.ApplicationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOpportunitiesInput
  }

  export type OpportunityApplicationUncheckedCreateWithoutOpportunityInput = {
    id?: string
    message: string
    resume?: string | null
    portfolio?: string | null
    status?: $Enums.ApplicationStatus
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityApplicationCreateOrConnectWithoutOpportunityInput = {
    where: OpportunityApplicationWhereUniqueInput
    create: XOR<OpportunityApplicationCreateWithoutOpportunityInput, OpportunityApplicationUncheckedCreateWithoutOpportunityInput>
  }

  export type OpportunityApplicationCreateManyOpportunityInputEnvelope = {
    data: OpportunityApplicationCreateManyOpportunityInput | OpportunityApplicationCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutOpportunitiesInput = {
    update: XOR<ProjectUpdateWithoutOpportunitiesInput, ProjectUncheckedUpdateWithoutOpportunitiesInput>
    create: XOR<ProjectCreateWithoutOpportunitiesInput, ProjectUncheckedCreateWithoutOpportunitiesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutOpportunitiesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutOpportunitiesInput, ProjectUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type ProjectUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProjectUpdatetagsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProjectUpdateimagesInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    stories?: StoryUpdateManyWithoutProjectNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProjectUpdatetagsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProjectUpdateimagesInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    stories?: StoryUncheckedUpdateManyWithoutProjectNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type OpportunityApplicationUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: OpportunityApplicationWhereUniqueInput
    update: XOR<OpportunityApplicationUpdateWithoutOpportunityInput, OpportunityApplicationUncheckedUpdateWithoutOpportunityInput>
    create: XOR<OpportunityApplicationCreateWithoutOpportunityInput, OpportunityApplicationUncheckedCreateWithoutOpportunityInput>
  }

  export type OpportunityApplicationUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: OpportunityApplicationWhereUniqueInput
    data: XOR<OpportunityApplicationUpdateWithoutOpportunityInput, OpportunityApplicationUncheckedUpdateWithoutOpportunityInput>
  }

  export type OpportunityApplicationUpdateManyWithWhereWithoutOpportunityInput = {
    where: OpportunityApplicationScalarWhereInput
    data: XOR<OpportunityApplicationUpdateManyMutationInput, OpportunityApplicationUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type UserCreateWithoutOpportunitiesInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    emailVerified?: Date | string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: UserCreateskillsInput | string[]
    interests?: UserCreateinterestsInput | string[]
    stories?: StoryCreateNestedManyWithoutAuthorInput
    projects?: ProjectMemberCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    lifeOSProfile?: LifeOSProfileCreateNestedOneWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventAttendance?: EventAttendeeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOpportunitiesInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    emailVerified?: Date | string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: UserCreateskillsInput | string[]
    interests?: UserCreateinterestsInput | string[]
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    projects?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    lifeOSProfile?: LifeOSProfileUncheckedCreateNestedOneWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventAttendance?: EventAttendeeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOpportunitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOpportunitiesInput, UserUncheckedCreateWithoutOpportunitiesInput>
  }

  export type OpportunityCreateWithoutApplicationsInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    type: $Enums.OpportunityType
    status?: $Enums.OpportunityStatus
    category?: string | null
    tags?: OpportunityCreatetagsInput | string[]
    skills?: OpportunityCreateskillsInput | string[]
    timeCommitment?: string | null
    location?: string | null
    remote?: boolean
    isPaid?: boolean
    compensation?: string | null
    deadline?: Date | string | null
    startDate?: Date | string | null
    duration?: string | null
    coverImage?: string | null
    images?: OpportunityCreateimagesInput | string[]
    contactEmail?: string | null
    contactPhone?: string | null
    applicationUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutOpportunitiesInput
  }

  export type OpportunityUncheckedCreateWithoutApplicationsInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    type: $Enums.OpportunityType
    status?: $Enums.OpportunityStatus
    category?: string | null
    tags?: OpportunityCreatetagsInput | string[]
    skills?: OpportunityCreateskillsInput | string[]
    timeCommitment?: string | null
    location?: string | null
    remote?: boolean
    isPaid?: boolean
    compensation?: string | null
    deadline?: Date | string | null
    startDate?: Date | string | null
    duration?: string | null
    coverImage?: string | null
    images?: OpportunityCreateimagesInput | string[]
    projectId?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    applicationUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityCreateOrConnectWithoutApplicationsInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutApplicationsInput, OpportunityUncheckedCreateWithoutApplicationsInput>
  }

  export type UserUpsertWithoutOpportunitiesInput = {
    update: XOR<UserUpdateWithoutOpportunitiesInput, UserUncheckedUpdateWithoutOpportunitiesInput>
    create: XOR<UserCreateWithoutOpportunitiesInput, UserUncheckedCreateWithoutOpportunitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOpportunitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOpportunitiesInput, UserUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type UserUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: UserUpdateskillsInput | string[]
    interests?: UserUpdateinterestsInput | string[]
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    projects?: ProjectMemberUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    lifeOSProfile?: LifeOSProfileUpdateOneWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventAttendance?: EventAttendeeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: UserUpdateskillsInput | string[]
    interests?: UserUpdateinterestsInput | string[]
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    projects?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    lifeOSProfile?: LifeOSProfileUncheckedUpdateOneWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventAttendance?: EventAttendeeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OpportunityUpsertWithoutApplicationsInput = {
    update: XOR<OpportunityUpdateWithoutApplicationsInput, OpportunityUncheckedUpdateWithoutApplicationsInput>
    create: XOR<OpportunityCreateWithoutApplicationsInput, OpportunityUncheckedCreateWithoutApplicationsInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutApplicationsInput, OpportunityUncheckedUpdateWithoutApplicationsInput>
  }

  export type OpportunityUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: OpportunityUpdatetagsInput | string[]
    skills?: OpportunityUpdateskillsInput | string[]
    timeCommitment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    remote?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    compensation?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: OpportunityUpdateimagesInput | string[]
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutOpportunitiesNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: OpportunityUpdatetagsInput | string[]
    skills?: OpportunityUpdateskillsInput | string[]
    timeCommitment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    remote?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    compensation?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: OpportunityUpdateimagesInput | string[]
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutLifeOSProfileInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    emailVerified?: Date | string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: UserCreateskillsInput | string[]
    interests?: UserCreateinterestsInput | string[]
    stories?: StoryCreateNestedManyWithoutAuthorInput
    projects?: ProjectMemberCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    opportunities?: OpportunityApplicationCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
    eventAttendance?: EventAttendeeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLifeOSProfileInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    emailVerified?: Date | string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: UserCreateskillsInput | string[]
    interests?: UserCreateinterestsInput | string[]
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    projects?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    opportunities?: OpportunityApplicationUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
    eventAttendance?: EventAttendeeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLifeOSProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLifeOSProfileInput, UserUncheckedCreateWithoutLifeOSProfileInput>
  }

  export type HabitCreateWithoutProfileInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    frequency?: $Enums.HabitFrequency
    targetValue?: number
    unit?: string | null
    color?: string | null
    icon?: string | null
    reminder?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completions?: HabitCompletionCreateNestedManyWithoutHabitInput
  }

  export type HabitUncheckedCreateWithoutProfileInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    frequency?: $Enums.HabitFrequency
    targetValue?: number
    unit?: string | null
    color?: string | null
    icon?: string | null
    reminder?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completions?: HabitCompletionUncheckedCreateNestedManyWithoutHabitInput
  }

  export type HabitCreateOrConnectWithoutProfileInput = {
    where: HabitWhereUniqueInput
    create: XOR<HabitCreateWithoutProfileInput, HabitUncheckedCreateWithoutProfileInput>
  }

  export type HabitCreateManyProfileInputEnvelope = {
    data: HabitCreateManyProfileInput | HabitCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type GoalCreateWithoutProfileInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    startDate?: Date | string
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.GoalStatus
    priority?: $Enums.Priority
    progress?: number
    motivation?: string | null
    visualisation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: GoalMilestoneCreateNestedManyWithoutGoalInput
    updates?: GoalUpdateCreateNestedManyWithoutGoalInput
  }

  export type GoalUncheckedCreateWithoutProfileInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    startDate?: Date | string
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.GoalStatus
    priority?: $Enums.Priority
    progress?: number
    motivation?: string | null
    visualisation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: GoalMilestoneUncheckedCreateNestedManyWithoutGoalInput
    updates?: GoalUpdateUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalCreateOrConnectWithoutProfileInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutProfileInput, GoalUncheckedCreateWithoutProfileInput>
  }

  export type GoalCreateManyProfileInputEnvelope = {
    data: GoalCreateManyProfileInput | GoalCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type MoodEntryCreateWithoutProfileInput = {
    id?: string
    mood: string
    intensity: number
    emotions?: MoodEntryCreateemotionsInput | string[]
    activities?: MoodEntryCreateactivitiesInput | string[]
    location?: string | null
    weather?: string | null
    notes?: string | null
    triggers?: string | null
    gratitude?: string | null
    recordedAt?: Date | string
    createdAt?: Date | string
  }

  export type MoodEntryUncheckedCreateWithoutProfileInput = {
    id?: string
    mood: string
    intensity: number
    emotions?: MoodEntryCreateemotionsInput | string[]
    activities?: MoodEntryCreateactivitiesInput | string[]
    location?: string | null
    weather?: string | null
    notes?: string | null
    triggers?: string | null
    gratitude?: string | null
    recordedAt?: Date | string
    createdAt?: Date | string
  }

  export type MoodEntryCreateOrConnectWithoutProfileInput = {
    where: MoodEntryWhereUniqueInput
    create: XOR<MoodEntryCreateWithoutProfileInput, MoodEntryUncheckedCreateWithoutProfileInput>
  }

  export type MoodEntryCreateManyProfileInputEnvelope = {
    data: MoodEntryCreateManyProfileInput | MoodEntryCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type MeditationSessionCreateWithoutProfileInput = {
    id?: string
    duration: number
    technique?: string | null
    guidedSession?: boolean
    guideUrl?: string | null
    rating?: number | null
    notes?: string | null
    mood?: string | null
    location?: string | null
    distractions?: string | null
    createdAt?: Date | string
  }

  export type MeditationSessionUncheckedCreateWithoutProfileInput = {
    id?: string
    duration: number
    technique?: string | null
    guidedSession?: boolean
    guideUrl?: string | null
    rating?: number | null
    notes?: string | null
    mood?: string | null
    location?: string | null
    distractions?: string | null
    createdAt?: Date | string
  }

  export type MeditationSessionCreateOrConnectWithoutProfileInput = {
    where: MeditationSessionWhereUniqueInput
    create: XOR<MeditationSessionCreateWithoutProfileInput, MeditationSessionUncheckedCreateWithoutProfileInput>
  }

  export type MeditationSessionCreateManyProfileInputEnvelope = {
    data: MeditationSessionCreateManyProfileInput | MeditationSessionCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type JournalCreateWithoutProfileInput = {
    id?: string
    title?: string | null
    content: string
    mood?: string | null
    tags?: JournalCreatetagsInput | string[]
    isPrivate?: boolean
    template?: string | null
    prompts?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalUncheckedCreateWithoutProfileInput = {
    id?: string
    title?: string | null
    content: string
    mood?: string | null
    tags?: JournalCreatetagsInput | string[]
    isPrivate?: boolean
    template?: string | null
    prompts?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalCreateOrConnectWithoutProfileInput = {
    where: JournalWhereUniqueInput
    create: XOR<JournalCreateWithoutProfileInput, JournalUncheckedCreateWithoutProfileInput>
  }

  export type JournalCreateManyProfileInputEnvelope = {
    data: JournalCreateManyProfileInput | JournalCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type FinancialTransactionCreateWithoutProfileInput = {
    id?: string
    amount: number
    currency?: string
    description: string
    notes?: string | null
    type: $Enums.TransactionType
    category: string
    subcategory?: string | null
    merchant?: string | null
    location?: string | null
    paymentMethod?: string | null
    tags?: FinancialTransactionCreatetagsInput | string[]
    gstAmount?: number | null
    taxCategory?: string | null
    transactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    budget?: BudgetCreateNestedOneWithoutTransactionsInput
  }

  export type FinancialTransactionUncheckedCreateWithoutProfileInput = {
    id?: string
    amount: number
    currency?: string
    description: string
    notes?: string | null
    type: $Enums.TransactionType
    category: string
    subcategory?: string | null
    merchant?: string | null
    location?: string | null
    paymentMethod?: string | null
    budgetId?: string | null
    tags?: FinancialTransactionCreatetagsInput | string[]
    gstAmount?: number | null
    taxCategory?: string | null
    transactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialTransactionCreateOrConnectWithoutProfileInput = {
    where: FinancialTransactionWhereUniqueInput
    create: XOR<FinancialTransactionCreateWithoutProfileInput, FinancialTransactionUncheckedCreateWithoutProfileInput>
  }

  export type FinancialTransactionCreateManyProfileInputEnvelope = {
    data: FinancialTransactionCreateManyProfileInput | FinancialTransactionCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type BudgetCreateWithoutProfileInput = {
    id?: string
    name: string
    description?: string | null
    totalAmount: number
    spentAmount?: number
    period?: $Enums.BudgetPeriod
    startDate?: Date | string
    endDate?: Date | string | null
    categories?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    alertThreshold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: FinancialTransactionCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateWithoutProfileInput = {
    id?: string
    name: string
    description?: string | null
    totalAmount: number
    spentAmount?: number
    period?: $Enums.BudgetPeriod
    startDate?: Date | string
    endDate?: Date | string | null
    categories?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    alertThreshold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetCreateOrConnectWithoutProfileInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutProfileInput, BudgetUncheckedCreateWithoutProfileInput>
  }

  export type BudgetCreateManyProfileInputEnvelope = {
    data: BudgetCreateManyProfileInput | BudgetCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLifeOSProfileInput = {
    update: XOR<UserUpdateWithoutLifeOSProfileInput, UserUncheckedUpdateWithoutLifeOSProfileInput>
    create: XOR<UserCreateWithoutLifeOSProfileInput, UserUncheckedCreateWithoutLifeOSProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLifeOSProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLifeOSProfileInput, UserUncheckedUpdateWithoutLifeOSProfileInput>
  }

  export type UserUpdateWithoutLifeOSProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: UserUpdateskillsInput | string[]
    interests?: UserUpdateinterestsInput | string[]
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    projects?: ProjectMemberUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    opportunities?: OpportunityApplicationUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
    eventAttendance?: EventAttendeeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLifeOSProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: UserUpdateskillsInput | string[]
    interests?: UserUpdateinterestsInput | string[]
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    projects?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    opportunities?: OpportunityApplicationUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
    eventAttendance?: EventAttendeeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HabitUpsertWithWhereUniqueWithoutProfileInput = {
    where: HabitWhereUniqueInput
    update: XOR<HabitUpdateWithoutProfileInput, HabitUncheckedUpdateWithoutProfileInput>
    create: XOR<HabitCreateWithoutProfileInput, HabitUncheckedCreateWithoutProfileInput>
  }

  export type HabitUpdateWithWhereUniqueWithoutProfileInput = {
    where: HabitWhereUniqueInput
    data: XOR<HabitUpdateWithoutProfileInput, HabitUncheckedUpdateWithoutProfileInput>
  }

  export type HabitUpdateManyWithWhereWithoutProfileInput = {
    where: HabitScalarWhereInput
    data: XOR<HabitUpdateManyMutationInput, HabitUncheckedUpdateManyWithoutProfileInput>
  }

  export type HabitScalarWhereInput = {
    AND?: HabitScalarWhereInput | HabitScalarWhereInput[]
    OR?: HabitScalarWhereInput[]
    NOT?: HabitScalarWhereInput | HabitScalarWhereInput[]
    id?: StringFilter<"Habit"> | string
    profileId?: StringFilter<"Habit"> | string
    name?: StringFilter<"Habit"> | string
    description?: StringNullableFilter<"Habit"> | string | null
    category?: StringNullableFilter<"Habit"> | string | null
    frequency?: EnumHabitFrequencyFilter<"Habit"> | $Enums.HabitFrequency
    targetValue?: IntFilter<"Habit"> | number
    unit?: StringNullableFilter<"Habit"> | string | null
    color?: StringNullableFilter<"Habit"> | string | null
    icon?: StringNullableFilter<"Habit"> | string | null
    reminder?: JsonNullableFilter<"Habit">
    isActive?: BoolFilter<"Habit"> | boolean
    currentStreak?: IntFilter<"Habit"> | number
    longestStreak?: IntFilter<"Habit"> | number
    lastCompletedDate?: DateTimeNullableFilter<"Habit"> | Date | string | null
    createdAt?: DateTimeFilter<"Habit"> | Date | string
    updatedAt?: DateTimeFilter<"Habit"> | Date | string
  }

  export type GoalUpsertWithWhereUniqueWithoutProfileInput = {
    where: GoalWhereUniqueInput
    update: XOR<GoalUpdateWithoutProfileInput, GoalUncheckedUpdateWithoutProfileInput>
    create: XOR<GoalCreateWithoutProfileInput, GoalUncheckedCreateWithoutProfileInput>
  }

  export type GoalUpdateWithWhereUniqueWithoutProfileInput = {
    where: GoalWhereUniqueInput
    data: XOR<GoalUpdateWithoutProfileInput, GoalUncheckedUpdateWithoutProfileInput>
  }

  export type GoalUpdateManyWithWhereWithoutProfileInput = {
    where: GoalScalarWhereInput
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyWithoutProfileInput>
  }

  export type GoalScalarWhereInput = {
    AND?: GoalScalarWhereInput | GoalScalarWhereInput[]
    OR?: GoalScalarWhereInput[]
    NOT?: GoalScalarWhereInput | GoalScalarWhereInput[]
    id?: StringFilter<"Goal"> | string
    profileId?: StringFilter<"Goal"> | string
    title?: StringFilter<"Goal"> | string
    description?: StringNullableFilter<"Goal"> | string | null
    category?: StringNullableFilter<"Goal"> | string | null
    targetValue?: FloatNullableFilter<"Goal"> | number | null
    currentValue?: FloatFilter<"Goal"> | number
    unit?: StringNullableFilter<"Goal"> | string | null
    startDate?: DateTimeFilter<"Goal"> | Date | string
    targetDate?: DateTimeNullableFilter<"Goal"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Goal"> | Date | string | null
    status?: EnumGoalStatusFilter<"Goal"> | $Enums.GoalStatus
    priority?: EnumPriorityFilter<"Goal"> | $Enums.Priority
    progress?: FloatFilter<"Goal"> | number
    motivation?: StringNullableFilter<"Goal"> | string | null
    visualisation?: StringNullableFilter<"Goal"> | string | null
    createdAt?: DateTimeFilter<"Goal"> | Date | string
    updatedAt?: DateTimeFilter<"Goal"> | Date | string
  }

  export type MoodEntryUpsertWithWhereUniqueWithoutProfileInput = {
    where: MoodEntryWhereUniqueInput
    update: XOR<MoodEntryUpdateWithoutProfileInput, MoodEntryUncheckedUpdateWithoutProfileInput>
    create: XOR<MoodEntryCreateWithoutProfileInput, MoodEntryUncheckedCreateWithoutProfileInput>
  }

  export type MoodEntryUpdateWithWhereUniqueWithoutProfileInput = {
    where: MoodEntryWhereUniqueInput
    data: XOR<MoodEntryUpdateWithoutProfileInput, MoodEntryUncheckedUpdateWithoutProfileInput>
  }

  export type MoodEntryUpdateManyWithWhereWithoutProfileInput = {
    where: MoodEntryScalarWhereInput
    data: XOR<MoodEntryUpdateManyMutationInput, MoodEntryUncheckedUpdateManyWithoutProfileInput>
  }

  export type MoodEntryScalarWhereInput = {
    AND?: MoodEntryScalarWhereInput | MoodEntryScalarWhereInput[]
    OR?: MoodEntryScalarWhereInput[]
    NOT?: MoodEntryScalarWhereInput | MoodEntryScalarWhereInput[]
    id?: StringFilter<"MoodEntry"> | string
    profileId?: StringFilter<"MoodEntry"> | string
    mood?: StringFilter<"MoodEntry"> | string
    intensity?: IntFilter<"MoodEntry"> | number
    emotions?: StringNullableListFilter<"MoodEntry">
    activities?: StringNullableListFilter<"MoodEntry">
    location?: StringNullableFilter<"MoodEntry"> | string | null
    weather?: StringNullableFilter<"MoodEntry"> | string | null
    notes?: StringNullableFilter<"MoodEntry"> | string | null
    triggers?: StringNullableFilter<"MoodEntry"> | string | null
    gratitude?: StringNullableFilter<"MoodEntry"> | string | null
    recordedAt?: DateTimeFilter<"MoodEntry"> | Date | string
    createdAt?: DateTimeFilter<"MoodEntry"> | Date | string
  }

  export type MeditationSessionUpsertWithWhereUniqueWithoutProfileInput = {
    where: MeditationSessionWhereUniqueInput
    update: XOR<MeditationSessionUpdateWithoutProfileInput, MeditationSessionUncheckedUpdateWithoutProfileInput>
    create: XOR<MeditationSessionCreateWithoutProfileInput, MeditationSessionUncheckedCreateWithoutProfileInput>
  }

  export type MeditationSessionUpdateWithWhereUniqueWithoutProfileInput = {
    where: MeditationSessionWhereUniqueInput
    data: XOR<MeditationSessionUpdateWithoutProfileInput, MeditationSessionUncheckedUpdateWithoutProfileInput>
  }

  export type MeditationSessionUpdateManyWithWhereWithoutProfileInput = {
    where: MeditationSessionScalarWhereInput
    data: XOR<MeditationSessionUpdateManyMutationInput, MeditationSessionUncheckedUpdateManyWithoutProfileInput>
  }

  export type MeditationSessionScalarWhereInput = {
    AND?: MeditationSessionScalarWhereInput | MeditationSessionScalarWhereInput[]
    OR?: MeditationSessionScalarWhereInput[]
    NOT?: MeditationSessionScalarWhereInput | MeditationSessionScalarWhereInput[]
    id?: StringFilter<"MeditationSession"> | string
    profileId?: StringFilter<"MeditationSession"> | string
    duration?: IntFilter<"MeditationSession"> | number
    technique?: StringNullableFilter<"MeditationSession"> | string | null
    guidedSession?: BoolFilter<"MeditationSession"> | boolean
    guideUrl?: StringNullableFilter<"MeditationSession"> | string | null
    rating?: IntNullableFilter<"MeditationSession"> | number | null
    notes?: StringNullableFilter<"MeditationSession"> | string | null
    mood?: StringNullableFilter<"MeditationSession"> | string | null
    location?: StringNullableFilter<"MeditationSession"> | string | null
    distractions?: StringNullableFilter<"MeditationSession"> | string | null
    createdAt?: DateTimeFilter<"MeditationSession"> | Date | string
  }

  export type JournalUpsertWithWhereUniqueWithoutProfileInput = {
    where: JournalWhereUniqueInput
    update: XOR<JournalUpdateWithoutProfileInput, JournalUncheckedUpdateWithoutProfileInput>
    create: XOR<JournalCreateWithoutProfileInput, JournalUncheckedCreateWithoutProfileInput>
  }

  export type JournalUpdateWithWhereUniqueWithoutProfileInput = {
    where: JournalWhereUniqueInput
    data: XOR<JournalUpdateWithoutProfileInput, JournalUncheckedUpdateWithoutProfileInput>
  }

  export type JournalUpdateManyWithWhereWithoutProfileInput = {
    where: JournalScalarWhereInput
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyWithoutProfileInput>
  }

  export type JournalScalarWhereInput = {
    AND?: JournalScalarWhereInput | JournalScalarWhereInput[]
    OR?: JournalScalarWhereInput[]
    NOT?: JournalScalarWhereInput | JournalScalarWhereInput[]
    id?: StringFilter<"Journal"> | string
    profileId?: StringFilter<"Journal"> | string
    title?: StringNullableFilter<"Journal"> | string | null
    content?: StringFilter<"Journal"> | string
    mood?: StringNullableFilter<"Journal"> | string | null
    tags?: StringNullableListFilter<"Journal">
    isPrivate?: BoolFilter<"Journal"> | boolean
    template?: StringNullableFilter<"Journal"> | string | null
    prompts?: JsonNullableFilter<"Journal">
    createdAt?: DateTimeFilter<"Journal"> | Date | string
    updatedAt?: DateTimeFilter<"Journal"> | Date | string
  }

  export type FinancialTransactionUpsertWithWhereUniqueWithoutProfileInput = {
    where: FinancialTransactionWhereUniqueInput
    update: XOR<FinancialTransactionUpdateWithoutProfileInput, FinancialTransactionUncheckedUpdateWithoutProfileInput>
    create: XOR<FinancialTransactionCreateWithoutProfileInput, FinancialTransactionUncheckedCreateWithoutProfileInput>
  }

  export type FinancialTransactionUpdateWithWhereUniqueWithoutProfileInput = {
    where: FinancialTransactionWhereUniqueInput
    data: XOR<FinancialTransactionUpdateWithoutProfileInput, FinancialTransactionUncheckedUpdateWithoutProfileInput>
  }

  export type FinancialTransactionUpdateManyWithWhereWithoutProfileInput = {
    where: FinancialTransactionScalarWhereInput
    data: XOR<FinancialTransactionUpdateManyMutationInput, FinancialTransactionUncheckedUpdateManyWithoutProfileInput>
  }

  export type FinancialTransactionScalarWhereInput = {
    AND?: FinancialTransactionScalarWhereInput | FinancialTransactionScalarWhereInput[]
    OR?: FinancialTransactionScalarWhereInput[]
    NOT?: FinancialTransactionScalarWhereInput | FinancialTransactionScalarWhereInput[]
    id?: StringFilter<"FinancialTransaction"> | string
    profileId?: StringFilter<"FinancialTransaction"> | string
    amount?: FloatFilter<"FinancialTransaction"> | number
    currency?: StringFilter<"FinancialTransaction"> | string
    description?: StringFilter<"FinancialTransaction"> | string
    notes?: StringNullableFilter<"FinancialTransaction"> | string | null
    type?: EnumTransactionTypeFilter<"FinancialTransaction"> | $Enums.TransactionType
    category?: StringFilter<"FinancialTransaction"> | string
    subcategory?: StringNullableFilter<"FinancialTransaction"> | string | null
    merchant?: StringNullableFilter<"FinancialTransaction"> | string | null
    location?: StringNullableFilter<"FinancialTransaction"> | string | null
    paymentMethod?: StringNullableFilter<"FinancialTransaction"> | string | null
    budgetId?: StringNullableFilter<"FinancialTransaction"> | string | null
    tags?: StringNullableListFilter<"FinancialTransaction">
    gstAmount?: FloatNullableFilter<"FinancialTransaction"> | number | null
    taxCategory?: StringNullableFilter<"FinancialTransaction"> | string | null
    transactionDate?: DateTimeFilter<"FinancialTransaction"> | Date | string
    createdAt?: DateTimeFilter<"FinancialTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"FinancialTransaction"> | Date | string
  }

  export type BudgetUpsertWithWhereUniqueWithoutProfileInput = {
    where: BudgetWhereUniqueInput
    update: XOR<BudgetUpdateWithoutProfileInput, BudgetUncheckedUpdateWithoutProfileInput>
    create: XOR<BudgetCreateWithoutProfileInput, BudgetUncheckedCreateWithoutProfileInput>
  }

  export type BudgetUpdateWithWhereUniqueWithoutProfileInput = {
    where: BudgetWhereUniqueInput
    data: XOR<BudgetUpdateWithoutProfileInput, BudgetUncheckedUpdateWithoutProfileInput>
  }

  export type BudgetUpdateManyWithWhereWithoutProfileInput = {
    where: BudgetScalarWhereInput
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyWithoutProfileInput>
  }

  export type BudgetScalarWhereInput = {
    AND?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    OR?: BudgetScalarWhereInput[]
    NOT?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    id?: StringFilter<"Budget"> | string
    profileId?: StringFilter<"Budget"> | string
    name?: StringFilter<"Budget"> | string
    description?: StringNullableFilter<"Budget"> | string | null
    totalAmount?: FloatFilter<"Budget"> | number
    spentAmount?: FloatFilter<"Budget"> | number
    period?: EnumBudgetPeriodFilter<"Budget"> | $Enums.BudgetPeriod
    startDate?: DateTimeFilter<"Budget"> | Date | string
    endDate?: DateTimeNullableFilter<"Budget"> | Date | string | null
    categories?: JsonFilter<"Budget">
    isActive?: BoolFilter<"Budget"> | boolean
    alertThreshold?: FloatFilter<"Budget"> | number
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
  }

  export type LifeOSProfileCreateWithoutHabitsInput = {
    id?: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLifeOSProfileInput
    goals?: GoalCreateNestedManyWithoutProfileInput
    moodEntries?: MoodEntryCreateNestedManyWithoutProfileInput
    meditations?: MeditationSessionCreateNestedManyWithoutProfileInput
    journals?: JournalCreateNestedManyWithoutProfileInput
    transactions?: FinancialTransactionCreateNestedManyWithoutProfileInput
    budgets?: BudgetCreateNestedManyWithoutProfileInput
  }

  export type LifeOSProfileUncheckedCreateWithoutHabitsInput = {
    id?: string
    userId: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    goals?: GoalUncheckedCreateNestedManyWithoutProfileInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutProfileInput
    meditations?: MeditationSessionUncheckedCreateNestedManyWithoutProfileInput
    journals?: JournalUncheckedCreateNestedManyWithoutProfileInput
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutProfileInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProfileInput
  }

  export type LifeOSProfileCreateOrConnectWithoutHabitsInput = {
    where: LifeOSProfileWhereUniqueInput
    create: XOR<LifeOSProfileCreateWithoutHabitsInput, LifeOSProfileUncheckedCreateWithoutHabitsInput>
  }

  export type HabitCompletionCreateWithoutHabitInput = {
    id?: string
    completedAt?: Date | string
    value?: number
    notes?: string | null
    satisfaction?: number | null
    difficulty?: number | null
  }

  export type HabitCompletionUncheckedCreateWithoutHabitInput = {
    id?: string
    completedAt?: Date | string
    value?: number
    notes?: string | null
    satisfaction?: number | null
    difficulty?: number | null
  }

  export type HabitCompletionCreateOrConnectWithoutHabitInput = {
    where: HabitCompletionWhereUniqueInput
    create: XOR<HabitCompletionCreateWithoutHabitInput, HabitCompletionUncheckedCreateWithoutHabitInput>
  }

  export type HabitCompletionCreateManyHabitInputEnvelope = {
    data: HabitCompletionCreateManyHabitInput | HabitCompletionCreateManyHabitInput[]
    skipDuplicates?: boolean
  }

  export type LifeOSProfileUpsertWithoutHabitsInput = {
    update: XOR<LifeOSProfileUpdateWithoutHabitsInput, LifeOSProfileUncheckedUpdateWithoutHabitsInput>
    create: XOR<LifeOSProfileCreateWithoutHabitsInput, LifeOSProfileUncheckedCreateWithoutHabitsInput>
    where?: LifeOSProfileWhereInput
  }

  export type LifeOSProfileUpdateToOneWithWhereWithoutHabitsInput = {
    where?: LifeOSProfileWhereInput
    data: XOR<LifeOSProfileUpdateWithoutHabitsInput, LifeOSProfileUncheckedUpdateWithoutHabitsInput>
  }

  export type LifeOSProfileUpdateWithoutHabitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLifeOSProfileNestedInput
    goals?: GoalUpdateManyWithoutProfileNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutProfileNestedInput
    meditations?: MeditationSessionUpdateManyWithoutProfileNestedInput
    journals?: JournalUpdateManyWithoutProfileNestedInput
    transactions?: FinancialTransactionUpdateManyWithoutProfileNestedInput
    budgets?: BudgetUpdateManyWithoutProfileNestedInput
  }

  export type LifeOSProfileUncheckedUpdateWithoutHabitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goals?: GoalUncheckedUpdateManyWithoutProfileNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutProfileNestedInput
    meditations?: MeditationSessionUncheckedUpdateManyWithoutProfileNestedInput
    journals?: JournalUncheckedUpdateManyWithoutProfileNestedInput
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutProfileNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type HabitCompletionUpsertWithWhereUniqueWithoutHabitInput = {
    where: HabitCompletionWhereUniqueInput
    update: XOR<HabitCompletionUpdateWithoutHabitInput, HabitCompletionUncheckedUpdateWithoutHabitInput>
    create: XOR<HabitCompletionCreateWithoutHabitInput, HabitCompletionUncheckedCreateWithoutHabitInput>
  }

  export type HabitCompletionUpdateWithWhereUniqueWithoutHabitInput = {
    where: HabitCompletionWhereUniqueInput
    data: XOR<HabitCompletionUpdateWithoutHabitInput, HabitCompletionUncheckedUpdateWithoutHabitInput>
  }

  export type HabitCompletionUpdateManyWithWhereWithoutHabitInput = {
    where: HabitCompletionScalarWhereInput
    data: XOR<HabitCompletionUpdateManyMutationInput, HabitCompletionUncheckedUpdateManyWithoutHabitInput>
  }

  export type HabitCompletionScalarWhereInput = {
    AND?: HabitCompletionScalarWhereInput | HabitCompletionScalarWhereInput[]
    OR?: HabitCompletionScalarWhereInput[]
    NOT?: HabitCompletionScalarWhereInput | HabitCompletionScalarWhereInput[]
    id?: StringFilter<"HabitCompletion"> | string
    habitId?: StringFilter<"HabitCompletion"> | string
    completedAt?: DateTimeFilter<"HabitCompletion"> | Date | string
    value?: IntFilter<"HabitCompletion"> | number
    notes?: StringNullableFilter<"HabitCompletion"> | string | null
    satisfaction?: IntNullableFilter<"HabitCompletion"> | number | null
    difficulty?: IntNullableFilter<"HabitCompletion"> | number | null
  }

  export type HabitCreateWithoutCompletionsInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    frequency?: $Enums.HabitFrequency
    targetValue?: number
    unit?: string | null
    color?: string | null
    icon?: string | null
    reminder?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: LifeOSProfileCreateNestedOneWithoutHabitsInput
  }

  export type HabitUncheckedCreateWithoutCompletionsInput = {
    id?: string
    profileId: string
    name: string
    description?: string | null
    category?: string | null
    frequency?: $Enums.HabitFrequency
    targetValue?: number
    unit?: string | null
    color?: string | null
    icon?: string | null
    reminder?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitCreateOrConnectWithoutCompletionsInput = {
    where: HabitWhereUniqueInput
    create: XOR<HabitCreateWithoutCompletionsInput, HabitUncheckedCreateWithoutCompletionsInput>
  }

  export type HabitUpsertWithoutCompletionsInput = {
    update: XOR<HabitUpdateWithoutCompletionsInput, HabitUncheckedUpdateWithoutCompletionsInput>
    create: XOR<HabitCreateWithoutCompletionsInput, HabitUncheckedCreateWithoutCompletionsInput>
    where?: HabitWhereInput
  }

  export type HabitUpdateToOneWithWhereWithoutCompletionsInput = {
    where?: HabitWhereInput
    data: XOR<HabitUpdateWithoutCompletionsInput, HabitUncheckedUpdateWithoutCompletionsInput>
  }

  export type HabitUpdateWithoutCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumHabitFrequencyFieldUpdateOperationsInput | $Enums.HabitFrequency
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    reminder?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: LifeOSProfileUpdateOneRequiredWithoutHabitsNestedInput
  }

  export type HabitUncheckedUpdateWithoutCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumHabitFrequencyFieldUpdateOperationsInput | $Enums.HabitFrequency
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    reminder?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LifeOSProfileCreateWithoutGoalsInput = {
    id?: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLifeOSProfileInput
    habits?: HabitCreateNestedManyWithoutProfileInput
    moodEntries?: MoodEntryCreateNestedManyWithoutProfileInput
    meditations?: MeditationSessionCreateNestedManyWithoutProfileInput
    journals?: JournalCreateNestedManyWithoutProfileInput
    transactions?: FinancialTransactionCreateNestedManyWithoutProfileInput
    budgets?: BudgetCreateNestedManyWithoutProfileInput
  }

  export type LifeOSProfileUncheckedCreateWithoutGoalsInput = {
    id?: string
    userId: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    habits?: HabitUncheckedCreateNestedManyWithoutProfileInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutProfileInput
    meditations?: MeditationSessionUncheckedCreateNestedManyWithoutProfileInput
    journals?: JournalUncheckedCreateNestedManyWithoutProfileInput
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutProfileInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProfileInput
  }

  export type LifeOSProfileCreateOrConnectWithoutGoalsInput = {
    where: LifeOSProfileWhereUniqueInput
    create: XOR<LifeOSProfileCreateWithoutGoalsInput, LifeOSProfileUncheckedCreateWithoutGoalsInput>
  }

  export type GoalMilestoneCreateWithoutGoalInput = {
    id?: string
    title: string
    description?: string | null
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    targetValue?: number | null
    currentValue?: number
    status?: $Enums.MilestoneStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalMilestoneUncheckedCreateWithoutGoalInput = {
    id?: string
    title: string
    description?: string | null
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    targetValue?: number | null
    currentValue?: number
    status?: $Enums.MilestoneStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalMilestoneCreateOrConnectWithoutGoalInput = {
    where: GoalMilestoneWhereUniqueInput
    create: XOR<GoalMilestoneCreateWithoutGoalInput, GoalMilestoneUncheckedCreateWithoutGoalInput>
  }

  export type GoalMilestoneCreateManyGoalInputEnvelope = {
    data: GoalMilestoneCreateManyGoalInput | GoalMilestoneCreateManyGoalInput[]
    skipDuplicates?: boolean
  }

  export type GoalUpdateCreateWithoutGoalInput = {
    id?: string
    content: string
    value?: number | null
    createdAt?: Date | string
  }

  export type GoalUpdateUncheckedCreateWithoutGoalInput = {
    id?: string
    content: string
    value?: number | null
    createdAt?: Date | string
  }

  export type GoalUpdateCreateOrConnectWithoutGoalInput = {
    where: GoalUpdateWhereUniqueInput
    create: XOR<GoalUpdateCreateWithoutGoalInput, GoalUpdateUncheckedCreateWithoutGoalInput>
  }

  export type GoalUpdateCreateManyGoalInputEnvelope = {
    data: GoalUpdateCreateManyGoalInput | GoalUpdateCreateManyGoalInput[]
    skipDuplicates?: boolean
  }

  export type LifeOSProfileUpsertWithoutGoalsInput = {
    update: XOR<LifeOSProfileUpdateWithoutGoalsInput, LifeOSProfileUncheckedUpdateWithoutGoalsInput>
    create: XOR<LifeOSProfileCreateWithoutGoalsInput, LifeOSProfileUncheckedCreateWithoutGoalsInput>
    where?: LifeOSProfileWhereInput
  }

  export type LifeOSProfileUpdateToOneWithWhereWithoutGoalsInput = {
    where?: LifeOSProfileWhereInput
    data: XOR<LifeOSProfileUpdateWithoutGoalsInput, LifeOSProfileUncheckedUpdateWithoutGoalsInput>
  }

  export type LifeOSProfileUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLifeOSProfileNestedInput
    habits?: HabitUpdateManyWithoutProfileNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutProfileNestedInput
    meditations?: MeditationSessionUpdateManyWithoutProfileNestedInput
    journals?: JournalUpdateManyWithoutProfileNestedInput
    transactions?: FinancialTransactionUpdateManyWithoutProfileNestedInput
    budgets?: BudgetUpdateManyWithoutProfileNestedInput
  }

  export type LifeOSProfileUncheckedUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habits?: HabitUncheckedUpdateManyWithoutProfileNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutProfileNestedInput
    meditations?: MeditationSessionUncheckedUpdateManyWithoutProfileNestedInput
    journals?: JournalUncheckedUpdateManyWithoutProfileNestedInput
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutProfileNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type GoalMilestoneUpsertWithWhereUniqueWithoutGoalInput = {
    where: GoalMilestoneWhereUniqueInput
    update: XOR<GoalMilestoneUpdateWithoutGoalInput, GoalMilestoneUncheckedUpdateWithoutGoalInput>
    create: XOR<GoalMilestoneCreateWithoutGoalInput, GoalMilestoneUncheckedCreateWithoutGoalInput>
  }

  export type GoalMilestoneUpdateWithWhereUniqueWithoutGoalInput = {
    where: GoalMilestoneWhereUniqueInput
    data: XOR<GoalMilestoneUpdateWithoutGoalInput, GoalMilestoneUncheckedUpdateWithoutGoalInput>
  }

  export type GoalMilestoneUpdateManyWithWhereWithoutGoalInput = {
    where: GoalMilestoneScalarWhereInput
    data: XOR<GoalMilestoneUpdateManyMutationInput, GoalMilestoneUncheckedUpdateManyWithoutGoalInput>
  }

  export type GoalMilestoneScalarWhereInput = {
    AND?: GoalMilestoneScalarWhereInput | GoalMilestoneScalarWhereInput[]
    OR?: GoalMilestoneScalarWhereInput[]
    NOT?: GoalMilestoneScalarWhereInput | GoalMilestoneScalarWhereInput[]
    id?: StringFilter<"GoalMilestone"> | string
    goalId?: StringFilter<"GoalMilestone"> | string
    title?: StringFilter<"GoalMilestone"> | string
    description?: StringNullableFilter<"GoalMilestone"> | string | null
    targetDate?: DateTimeNullableFilter<"GoalMilestone"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"GoalMilestone"> | Date | string | null
    targetValue?: FloatNullableFilter<"GoalMilestone"> | number | null
    currentValue?: FloatFilter<"GoalMilestone"> | number
    status?: EnumMilestoneStatusFilter<"GoalMilestone"> | $Enums.MilestoneStatus
    createdAt?: DateTimeFilter<"GoalMilestone"> | Date | string
    updatedAt?: DateTimeFilter<"GoalMilestone"> | Date | string
  }

  export type GoalUpdateUpsertWithWhereUniqueWithoutGoalInput = {
    where: GoalUpdateWhereUniqueInput
    update: XOR<GoalUpdateUpdateWithoutGoalInput, GoalUpdateUncheckedUpdateWithoutGoalInput>
    create: XOR<GoalUpdateCreateWithoutGoalInput, GoalUpdateUncheckedCreateWithoutGoalInput>
  }

  export type GoalUpdateUpdateWithWhereUniqueWithoutGoalInput = {
    where: GoalUpdateWhereUniqueInput
    data: XOR<GoalUpdateUpdateWithoutGoalInput, GoalUpdateUncheckedUpdateWithoutGoalInput>
  }

  export type GoalUpdateUpdateManyWithWhereWithoutGoalInput = {
    where: GoalUpdateScalarWhereInput
    data: XOR<GoalUpdateUpdateManyMutationInput, GoalUpdateUncheckedUpdateManyWithoutGoalInput>
  }

  export type GoalUpdateScalarWhereInput = {
    AND?: GoalUpdateScalarWhereInput | GoalUpdateScalarWhereInput[]
    OR?: GoalUpdateScalarWhereInput[]
    NOT?: GoalUpdateScalarWhereInput | GoalUpdateScalarWhereInput[]
    id?: StringFilter<"GoalUpdate"> | string
    goalId?: StringFilter<"GoalUpdate"> | string
    content?: StringFilter<"GoalUpdate"> | string
    value?: FloatNullableFilter<"GoalUpdate"> | number | null
    createdAt?: DateTimeFilter<"GoalUpdate"> | Date | string
  }

  export type GoalCreateWithoutMilestonesInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    startDate?: Date | string
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.GoalStatus
    priority?: $Enums.Priority
    progress?: number
    motivation?: string | null
    visualisation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: LifeOSProfileCreateNestedOneWithoutGoalsInput
    updates?: GoalUpdateCreateNestedManyWithoutGoalInput
  }

  export type GoalUncheckedCreateWithoutMilestonesInput = {
    id?: string
    profileId: string
    title: string
    description?: string | null
    category?: string | null
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    startDate?: Date | string
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.GoalStatus
    priority?: $Enums.Priority
    progress?: number
    motivation?: string | null
    visualisation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updates?: GoalUpdateUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalCreateOrConnectWithoutMilestonesInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutMilestonesInput, GoalUncheckedCreateWithoutMilestonesInput>
  }

  export type GoalUpsertWithoutMilestonesInput = {
    update: XOR<GoalUpdateWithoutMilestonesInput, GoalUncheckedUpdateWithoutMilestonesInput>
    create: XOR<GoalCreateWithoutMilestonesInput, GoalUncheckedCreateWithoutMilestonesInput>
    where?: GoalWhereInput
  }

  export type GoalUpdateToOneWithWhereWithoutMilestonesInput = {
    where?: GoalWhereInput
    data: XOR<GoalUpdateWithoutMilestonesInput, GoalUncheckedUpdateWithoutMilestonesInput>
  }

  export type GoalUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    progress?: FloatFieldUpdateOperationsInput | number
    motivation?: NullableStringFieldUpdateOperationsInput | string | null
    visualisation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: LifeOSProfileUpdateOneRequiredWithoutGoalsNestedInput
    updates?: GoalUpdateUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    progress?: FloatFieldUpdateOperationsInput | number
    motivation?: NullableStringFieldUpdateOperationsInput | string | null
    visualisation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updates?: GoalUpdateUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type GoalCreateWithoutUpdatesInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    startDate?: Date | string
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.GoalStatus
    priority?: $Enums.Priority
    progress?: number
    motivation?: string | null
    visualisation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: LifeOSProfileCreateNestedOneWithoutGoalsInput
    milestones?: GoalMilestoneCreateNestedManyWithoutGoalInput
  }

  export type GoalUncheckedCreateWithoutUpdatesInput = {
    id?: string
    profileId: string
    title: string
    description?: string | null
    category?: string | null
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    startDate?: Date | string
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.GoalStatus
    priority?: $Enums.Priority
    progress?: number
    motivation?: string | null
    visualisation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: GoalMilestoneUncheckedCreateNestedManyWithoutGoalInput
  }

  export type GoalCreateOrConnectWithoutUpdatesInput = {
    where: GoalWhereUniqueInput
    create: XOR<GoalCreateWithoutUpdatesInput, GoalUncheckedCreateWithoutUpdatesInput>
  }

  export type GoalUpsertWithoutUpdatesInput = {
    update: XOR<GoalUpdateWithoutUpdatesInput, GoalUncheckedUpdateWithoutUpdatesInput>
    create: XOR<GoalCreateWithoutUpdatesInput, GoalUncheckedCreateWithoutUpdatesInput>
    where?: GoalWhereInput
  }

  export type GoalUpdateToOneWithWhereWithoutUpdatesInput = {
    where?: GoalWhereInput
    data: XOR<GoalUpdateWithoutUpdatesInput, GoalUncheckedUpdateWithoutUpdatesInput>
  }

  export type GoalUpdateWithoutUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    progress?: FloatFieldUpdateOperationsInput | number
    motivation?: NullableStringFieldUpdateOperationsInput | string | null
    visualisation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: LifeOSProfileUpdateOneRequiredWithoutGoalsNestedInput
    milestones?: GoalMilestoneUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateWithoutUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    progress?: FloatFieldUpdateOperationsInput | number
    motivation?: NullableStringFieldUpdateOperationsInput | string | null
    visualisation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: GoalMilestoneUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type LifeOSProfileCreateWithoutMeditationsInput = {
    id?: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLifeOSProfileInput
    habits?: HabitCreateNestedManyWithoutProfileInput
    goals?: GoalCreateNestedManyWithoutProfileInput
    moodEntries?: MoodEntryCreateNestedManyWithoutProfileInput
    journals?: JournalCreateNestedManyWithoutProfileInput
    transactions?: FinancialTransactionCreateNestedManyWithoutProfileInput
    budgets?: BudgetCreateNestedManyWithoutProfileInput
  }

  export type LifeOSProfileUncheckedCreateWithoutMeditationsInput = {
    id?: string
    userId: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    habits?: HabitUncheckedCreateNestedManyWithoutProfileInput
    goals?: GoalUncheckedCreateNestedManyWithoutProfileInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutProfileInput
    journals?: JournalUncheckedCreateNestedManyWithoutProfileInput
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutProfileInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProfileInput
  }

  export type LifeOSProfileCreateOrConnectWithoutMeditationsInput = {
    where: LifeOSProfileWhereUniqueInput
    create: XOR<LifeOSProfileCreateWithoutMeditationsInput, LifeOSProfileUncheckedCreateWithoutMeditationsInput>
  }

  export type LifeOSProfileUpsertWithoutMeditationsInput = {
    update: XOR<LifeOSProfileUpdateWithoutMeditationsInput, LifeOSProfileUncheckedUpdateWithoutMeditationsInput>
    create: XOR<LifeOSProfileCreateWithoutMeditationsInput, LifeOSProfileUncheckedCreateWithoutMeditationsInput>
    where?: LifeOSProfileWhereInput
  }

  export type LifeOSProfileUpdateToOneWithWhereWithoutMeditationsInput = {
    where?: LifeOSProfileWhereInput
    data: XOR<LifeOSProfileUpdateWithoutMeditationsInput, LifeOSProfileUncheckedUpdateWithoutMeditationsInput>
  }

  export type LifeOSProfileUpdateWithoutMeditationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLifeOSProfileNestedInput
    habits?: HabitUpdateManyWithoutProfileNestedInput
    goals?: GoalUpdateManyWithoutProfileNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutProfileNestedInput
    journals?: JournalUpdateManyWithoutProfileNestedInput
    transactions?: FinancialTransactionUpdateManyWithoutProfileNestedInput
    budgets?: BudgetUpdateManyWithoutProfileNestedInput
  }

  export type LifeOSProfileUncheckedUpdateWithoutMeditationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habits?: HabitUncheckedUpdateManyWithoutProfileNestedInput
    goals?: GoalUncheckedUpdateManyWithoutProfileNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutProfileNestedInput
    journals?: JournalUncheckedUpdateManyWithoutProfileNestedInput
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutProfileNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type LifeOSProfileCreateWithoutMoodEntriesInput = {
    id?: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLifeOSProfileInput
    habits?: HabitCreateNestedManyWithoutProfileInput
    goals?: GoalCreateNestedManyWithoutProfileInput
    meditations?: MeditationSessionCreateNestedManyWithoutProfileInput
    journals?: JournalCreateNestedManyWithoutProfileInput
    transactions?: FinancialTransactionCreateNestedManyWithoutProfileInput
    budgets?: BudgetCreateNestedManyWithoutProfileInput
  }

  export type LifeOSProfileUncheckedCreateWithoutMoodEntriesInput = {
    id?: string
    userId: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    habits?: HabitUncheckedCreateNestedManyWithoutProfileInput
    goals?: GoalUncheckedCreateNestedManyWithoutProfileInput
    meditations?: MeditationSessionUncheckedCreateNestedManyWithoutProfileInput
    journals?: JournalUncheckedCreateNestedManyWithoutProfileInput
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutProfileInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProfileInput
  }

  export type LifeOSProfileCreateOrConnectWithoutMoodEntriesInput = {
    where: LifeOSProfileWhereUniqueInput
    create: XOR<LifeOSProfileCreateWithoutMoodEntriesInput, LifeOSProfileUncheckedCreateWithoutMoodEntriesInput>
  }

  export type LifeOSProfileUpsertWithoutMoodEntriesInput = {
    update: XOR<LifeOSProfileUpdateWithoutMoodEntriesInput, LifeOSProfileUncheckedUpdateWithoutMoodEntriesInput>
    create: XOR<LifeOSProfileCreateWithoutMoodEntriesInput, LifeOSProfileUncheckedCreateWithoutMoodEntriesInput>
    where?: LifeOSProfileWhereInput
  }

  export type LifeOSProfileUpdateToOneWithWhereWithoutMoodEntriesInput = {
    where?: LifeOSProfileWhereInput
    data: XOR<LifeOSProfileUpdateWithoutMoodEntriesInput, LifeOSProfileUncheckedUpdateWithoutMoodEntriesInput>
  }

  export type LifeOSProfileUpdateWithoutMoodEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLifeOSProfileNestedInput
    habits?: HabitUpdateManyWithoutProfileNestedInput
    goals?: GoalUpdateManyWithoutProfileNestedInput
    meditations?: MeditationSessionUpdateManyWithoutProfileNestedInput
    journals?: JournalUpdateManyWithoutProfileNestedInput
    transactions?: FinancialTransactionUpdateManyWithoutProfileNestedInput
    budgets?: BudgetUpdateManyWithoutProfileNestedInput
  }

  export type LifeOSProfileUncheckedUpdateWithoutMoodEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habits?: HabitUncheckedUpdateManyWithoutProfileNestedInput
    goals?: GoalUncheckedUpdateManyWithoutProfileNestedInput
    meditations?: MeditationSessionUncheckedUpdateManyWithoutProfileNestedInput
    journals?: JournalUncheckedUpdateManyWithoutProfileNestedInput
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutProfileNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type LifeOSProfileCreateWithoutJournalsInput = {
    id?: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLifeOSProfileInput
    habits?: HabitCreateNestedManyWithoutProfileInput
    goals?: GoalCreateNestedManyWithoutProfileInput
    moodEntries?: MoodEntryCreateNestedManyWithoutProfileInput
    meditations?: MeditationSessionCreateNestedManyWithoutProfileInput
    transactions?: FinancialTransactionCreateNestedManyWithoutProfileInput
    budgets?: BudgetCreateNestedManyWithoutProfileInput
  }

  export type LifeOSProfileUncheckedCreateWithoutJournalsInput = {
    id?: string
    userId: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    habits?: HabitUncheckedCreateNestedManyWithoutProfileInput
    goals?: GoalUncheckedCreateNestedManyWithoutProfileInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutProfileInput
    meditations?: MeditationSessionUncheckedCreateNestedManyWithoutProfileInput
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutProfileInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProfileInput
  }

  export type LifeOSProfileCreateOrConnectWithoutJournalsInput = {
    where: LifeOSProfileWhereUniqueInput
    create: XOR<LifeOSProfileCreateWithoutJournalsInput, LifeOSProfileUncheckedCreateWithoutJournalsInput>
  }

  export type LifeOSProfileUpsertWithoutJournalsInput = {
    update: XOR<LifeOSProfileUpdateWithoutJournalsInput, LifeOSProfileUncheckedUpdateWithoutJournalsInput>
    create: XOR<LifeOSProfileCreateWithoutJournalsInput, LifeOSProfileUncheckedCreateWithoutJournalsInput>
    where?: LifeOSProfileWhereInput
  }

  export type LifeOSProfileUpdateToOneWithWhereWithoutJournalsInput = {
    where?: LifeOSProfileWhereInput
    data: XOR<LifeOSProfileUpdateWithoutJournalsInput, LifeOSProfileUncheckedUpdateWithoutJournalsInput>
  }

  export type LifeOSProfileUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLifeOSProfileNestedInput
    habits?: HabitUpdateManyWithoutProfileNestedInput
    goals?: GoalUpdateManyWithoutProfileNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutProfileNestedInput
    meditations?: MeditationSessionUpdateManyWithoutProfileNestedInput
    transactions?: FinancialTransactionUpdateManyWithoutProfileNestedInput
    budgets?: BudgetUpdateManyWithoutProfileNestedInput
  }

  export type LifeOSProfileUncheckedUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habits?: HabitUncheckedUpdateManyWithoutProfileNestedInput
    goals?: GoalUncheckedUpdateManyWithoutProfileNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutProfileNestedInput
    meditations?: MeditationSessionUncheckedUpdateManyWithoutProfileNestedInput
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutProfileNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type UserCreateWithoutCalendarEventsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    emailVerified?: Date | string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: UserCreateskillsInput | string[]
    interests?: UserCreateinterestsInput | string[]
    stories?: StoryCreateNestedManyWithoutAuthorInput
    projects?: ProjectMemberCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    opportunities?: OpportunityApplicationCreateNestedManyWithoutUserInput
    lifeOSProfile?: LifeOSProfileCreateNestedOneWithoutUserInput
    eventAttendance?: EventAttendeeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCalendarEventsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    emailVerified?: Date | string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: UserCreateskillsInput | string[]
    interests?: UserCreateinterestsInput | string[]
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    projects?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    opportunities?: OpportunityApplicationUncheckedCreateNestedManyWithoutUserInput
    lifeOSProfile?: LifeOSProfileUncheckedCreateNestedOneWithoutUserInput
    eventAttendance?: EventAttendeeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCalendarEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
  }

  export type ProjectCreateWithoutCalendarEventsInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    status?: $Enums.ProjectStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: ProjectCreatetagsInput | string[]
    location?: string | null
    region?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: string | null
    images?: ProjectCreateimagesInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    stories?: StoryCreateNestedManyWithoutProjectInput
    opportunities?: OpportunityCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCalendarEventsInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    status?: $Enums.ProjectStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: ProjectCreatetagsInput | string[]
    location?: string | null
    region?: string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: string | null
    images?: ProjectCreateimagesInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    stories?: StoryUncheckedCreateNestedManyWithoutProjectInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCalendarEventsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCalendarEventsInput, ProjectUncheckedCreateWithoutCalendarEventsInput>
  }

  export type EventAttendeeCreateWithoutEventInput = {
    id?: string
    status?: $Enums.AttendeeStatus
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEventAttendanceInput
  }

  export type EventAttendeeUncheckedCreateWithoutEventInput = {
    id?: string
    userId: string
    status?: $Enums.AttendeeStatus
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventAttendeeCreateOrConnectWithoutEventInput = {
    where: EventAttendeeWhereUniqueInput
    create: XOR<EventAttendeeCreateWithoutEventInput, EventAttendeeUncheckedCreateWithoutEventInput>
  }

  export type EventAttendeeCreateManyEventInputEnvelope = {
    data: EventAttendeeCreateManyEventInput | EventAttendeeCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCalendarEventsInput = {
    update: XOR<UserUpdateWithoutCalendarEventsInput, UserUncheckedUpdateWithoutCalendarEventsInput>
    create: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCalendarEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCalendarEventsInput, UserUncheckedUpdateWithoutCalendarEventsInput>
  }

  export type UserUpdateWithoutCalendarEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: UserUpdateskillsInput | string[]
    interests?: UserUpdateinterestsInput | string[]
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    projects?: ProjectMemberUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    opportunities?: OpportunityApplicationUpdateManyWithoutUserNestedInput
    lifeOSProfile?: LifeOSProfileUpdateOneWithoutUserNestedInput
    eventAttendance?: EventAttendeeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCalendarEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: UserUpdateskillsInput | string[]
    interests?: UserUpdateinterestsInput | string[]
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    projects?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    opportunities?: OpportunityApplicationUncheckedUpdateManyWithoutUserNestedInput
    lifeOSProfile?: LifeOSProfileUncheckedUpdateOneWithoutUserNestedInput
    eventAttendance?: EventAttendeeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutCalendarEventsInput = {
    update: XOR<ProjectUpdateWithoutCalendarEventsInput, ProjectUncheckedUpdateWithoutCalendarEventsInput>
    create: XOR<ProjectCreateWithoutCalendarEventsInput, ProjectUncheckedCreateWithoutCalendarEventsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCalendarEventsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCalendarEventsInput, ProjectUncheckedUpdateWithoutCalendarEventsInput>
  }

  export type ProjectUpdateWithoutCalendarEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProjectUpdatetagsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProjectUpdateimagesInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    stories?: StoryUpdateManyWithoutProjectNestedInput
    opportunities?: OpportunityUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCalendarEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProjectUpdatetagsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableJsonNullValueInput | InputJsonValue
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProjectUpdateimagesInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    stories?: StoryUncheckedUpdateManyWithoutProjectNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type EventAttendeeUpsertWithWhereUniqueWithoutEventInput = {
    where: EventAttendeeWhereUniqueInput
    update: XOR<EventAttendeeUpdateWithoutEventInput, EventAttendeeUncheckedUpdateWithoutEventInput>
    create: XOR<EventAttendeeCreateWithoutEventInput, EventAttendeeUncheckedCreateWithoutEventInput>
  }

  export type EventAttendeeUpdateWithWhereUniqueWithoutEventInput = {
    where: EventAttendeeWhereUniqueInput
    data: XOR<EventAttendeeUpdateWithoutEventInput, EventAttendeeUncheckedUpdateWithoutEventInput>
  }

  export type EventAttendeeUpdateManyWithWhereWithoutEventInput = {
    where: EventAttendeeScalarWhereInput
    data: XOR<EventAttendeeUpdateManyMutationInput, EventAttendeeUncheckedUpdateManyWithoutEventInput>
  }

  export type CalendarEventCreateWithoutAttendeesInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    isAllDay?: boolean
    location?: string | null
    url?: string | null
    category?: string | null
    color?: string | null
    isRecurring?: boolean
    recurrenceRule?: string | null
    parentEventId?: string | null
    eventType?: $Enums.EventType
    visibility?: $Enums.Visibility
    communityEvent?: boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCalendarEventsInput
    project?: ProjectCreateNestedOneWithoutCalendarEventsInput
  }

  export type CalendarEventUncheckedCreateWithoutAttendeesInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    isAllDay?: boolean
    location?: string | null
    url?: string | null
    category?: string | null
    color?: string | null
    isRecurring?: boolean
    recurrenceRule?: string | null
    parentEventId?: string | null
    eventType?: $Enums.EventType
    visibility?: $Enums.Visibility
    projectId?: string | null
    communityEvent?: boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarEventCreateOrConnectWithoutAttendeesInput = {
    where: CalendarEventWhereUniqueInput
    create: XOR<CalendarEventCreateWithoutAttendeesInput, CalendarEventUncheckedCreateWithoutAttendeesInput>
  }

  export type UserCreateWithoutEventAttendanceInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    emailVerified?: Date | string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: UserCreateskillsInput | string[]
    interests?: UserCreateinterestsInput | string[]
    stories?: StoryCreateNestedManyWithoutAuthorInput
    projects?: ProjectMemberCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    opportunities?: OpportunityApplicationCreateNestedManyWithoutUserInput
    lifeOSProfile?: LifeOSProfileCreateNestedOneWithoutUserInput
    calendarEvents?: CalendarEventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventAttendanceInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    emailVerified?: Date | string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: UserCreateskillsInput | string[]
    interests?: UserCreateinterestsInput | string[]
    stories?: StoryUncheckedCreateNestedManyWithoutAuthorInput
    projects?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    opportunities?: OpportunityApplicationUncheckedCreateNestedManyWithoutUserInput
    lifeOSProfile?: LifeOSProfileUncheckedCreateNestedOneWithoutUserInput
    calendarEvents?: CalendarEventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventAttendanceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventAttendanceInput, UserUncheckedCreateWithoutEventAttendanceInput>
  }

  export type CalendarEventUpsertWithoutAttendeesInput = {
    update: XOR<CalendarEventUpdateWithoutAttendeesInput, CalendarEventUncheckedUpdateWithoutAttendeesInput>
    create: XOR<CalendarEventCreateWithoutAttendeesInput, CalendarEventUncheckedCreateWithoutAttendeesInput>
    where?: CalendarEventWhereInput
  }

  export type CalendarEventUpdateToOneWithWhereWithoutAttendeesInput = {
    where?: CalendarEventWhereInput
    data: XOR<CalendarEventUpdateWithoutAttendeesInput, CalendarEventUncheckedUpdateWithoutAttendeesInput>
  }

  export type CalendarEventUpdateWithoutAttendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    parentEventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    communityEvent?: BoolFieldUpdateOperationsInput | boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCalendarEventsNestedInput
    project?: ProjectUpdateOneWithoutCalendarEventsNestedInput
  }

  export type CalendarEventUncheckedUpdateWithoutAttendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    parentEventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    communityEvent?: BoolFieldUpdateOperationsInput | boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutEventAttendanceInput = {
    update: XOR<UserUpdateWithoutEventAttendanceInput, UserUncheckedUpdateWithoutEventAttendanceInput>
    create: XOR<UserCreateWithoutEventAttendanceInput, UserUncheckedCreateWithoutEventAttendanceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventAttendanceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventAttendanceInput, UserUncheckedUpdateWithoutEventAttendanceInput>
  }

  export type UserUpdateWithoutEventAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: UserUpdateskillsInput | string[]
    interests?: UserUpdateinterestsInput | string[]
    stories?: StoryUpdateManyWithoutAuthorNestedInput
    projects?: ProjectMemberUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    opportunities?: OpportunityApplicationUpdateManyWithoutUserNestedInput
    lifeOSProfile?: LifeOSProfileUpdateOneWithoutUserNestedInput
    calendarEvents?: CalendarEventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: UserUpdateskillsInput | string[]
    interests?: UserUpdateinterestsInput | string[]
    stories?: StoryUncheckedUpdateManyWithoutAuthorNestedInput
    projects?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    opportunities?: OpportunityApplicationUncheckedUpdateManyWithoutUserNestedInput
    lifeOSProfile?: LifeOSProfileUncheckedUpdateOneWithoutUserNestedInput
    calendarEvents?: CalendarEventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LifeOSProfileCreateWithoutTransactionsInput = {
    id?: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLifeOSProfileInput
    habits?: HabitCreateNestedManyWithoutProfileInput
    goals?: GoalCreateNestedManyWithoutProfileInput
    moodEntries?: MoodEntryCreateNestedManyWithoutProfileInput
    meditations?: MeditationSessionCreateNestedManyWithoutProfileInput
    journals?: JournalCreateNestedManyWithoutProfileInput
    budgets?: BudgetCreateNestedManyWithoutProfileInput
  }

  export type LifeOSProfileUncheckedCreateWithoutTransactionsInput = {
    id?: string
    userId: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    habits?: HabitUncheckedCreateNestedManyWithoutProfileInput
    goals?: GoalUncheckedCreateNestedManyWithoutProfileInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutProfileInput
    meditations?: MeditationSessionUncheckedCreateNestedManyWithoutProfileInput
    journals?: JournalUncheckedCreateNestedManyWithoutProfileInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutProfileInput
  }

  export type LifeOSProfileCreateOrConnectWithoutTransactionsInput = {
    where: LifeOSProfileWhereUniqueInput
    create: XOR<LifeOSProfileCreateWithoutTransactionsInput, LifeOSProfileUncheckedCreateWithoutTransactionsInput>
  }

  export type BudgetCreateWithoutTransactionsInput = {
    id?: string
    name: string
    description?: string | null
    totalAmount: number
    spentAmount?: number
    period?: $Enums.BudgetPeriod
    startDate?: Date | string
    endDate?: Date | string | null
    categories?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    alertThreshold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: LifeOSProfileCreateNestedOneWithoutBudgetsInput
  }

  export type BudgetUncheckedCreateWithoutTransactionsInput = {
    id?: string
    profileId: string
    name: string
    description?: string | null
    totalAmount: number
    spentAmount?: number
    period?: $Enums.BudgetPeriod
    startDate?: Date | string
    endDate?: Date | string | null
    categories?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    alertThreshold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCreateOrConnectWithoutTransactionsInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutTransactionsInput, BudgetUncheckedCreateWithoutTransactionsInput>
  }

  export type LifeOSProfileUpsertWithoutTransactionsInput = {
    update: XOR<LifeOSProfileUpdateWithoutTransactionsInput, LifeOSProfileUncheckedUpdateWithoutTransactionsInput>
    create: XOR<LifeOSProfileCreateWithoutTransactionsInput, LifeOSProfileUncheckedCreateWithoutTransactionsInput>
    where?: LifeOSProfileWhereInput
  }

  export type LifeOSProfileUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: LifeOSProfileWhereInput
    data: XOR<LifeOSProfileUpdateWithoutTransactionsInput, LifeOSProfileUncheckedUpdateWithoutTransactionsInput>
  }

  export type LifeOSProfileUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLifeOSProfileNestedInput
    habits?: HabitUpdateManyWithoutProfileNestedInput
    goals?: GoalUpdateManyWithoutProfileNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutProfileNestedInput
    meditations?: MeditationSessionUpdateManyWithoutProfileNestedInput
    journals?: JournalUpdateManyWithoutProfileNestedInput
    budgets?: BudgetUpdateManyWithoutProfileNestedInput
  }

  export type LifeOSProfileUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habits?: HabitUncheckedUpdateManyWithoutProfileNestedInput
    goals?: GoalUncheckedUpdateManyWithoutProfileNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutProfileNestedInput
    meditations?: MeditationSessionUncheckedUpdateManyWithoutProfileNestedInput
    journals?: JournalUncheckedUpdateManyWithoutProfileNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type BudgetUpsertWithoutTransactionsInput = {
    update: XOR<BudgetUpdateWithoutTransactionsInput, BudgetUncheckedUpdateWithoutTransactionsInput>
    create: XOR<BudgetCreateWithoutTransactionsInput, BudgetUncheckedCreateWithoutTransactionsInput>
    where?: BudgetWhereInput
  }

  export type BudgetUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: BudgetWhereInput
    data: XOR<BudgetUpdateWithoutTransactionsInput, BudgetUncheckedUpdateWithoutTransactionsInput>
  }

  export type BudgetUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: LifeOSProfileUpdateOneRequiredWithoutBudgetsNestedInput
  }

  export type BudgetUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LifeOSProfileCreateWithoutBudgetsInput = {
    id?: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLifeOSProfileInput
    habits?: HabitCreateNestedManyWithoutProfileInput
    goals?: GoalCreateNestedManyWithoutProfileInput
    moodEntries?: MoodEntryCreateNestedManyWithoutProfileInput
    meditations?: MeditationSessionCreateNestedManyWithoutProfileInput
    journals?: JournalCreateNestedManyWithoutProfileInput
    transactions?: FinancialTransactionCreateNestedManyWithoutProfileInput
  }

  export type LifeOSProfileUncheckedCreateWithoutBudgetsInput = {
    id?: string
    userId: string
    timezone?: string
    locale?: string
    currency?: string
    themePreference?: string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: boolean
    communityControlEnabled?: boolean
    dataResidencyPreference?: string
    onboardingCompleted?: boolean
    lastActiveAt?: Date | string
    activationDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    habits?: HabitUncheckedCreateNestedManyWithoutProfileInput
    goals?: GoalUncheckedCreateNestedManyWithoutProfileInput
    moodEntries?: MoodEntryUncheckedCreateNestedManyWithoutProfileInput
    meditations?: MeditationSessionUncheckedCreateNestedManyWithoutProfileInput
    journals?: JournalUncheckedCreateNestedManyWithoutProfileInput
    transactions?: FinancialTransactionUncheckedCreateNestedManyWithoutProfileInput
  }

  export type LifeOSProfileCreateOrConnectWithoutBudgetsInput = {
    where: LifeOSProfileWhereUniqueInput
    create: XOR<LifeOSProfileCreateWithoutBudgetsInput, LifeOSProfileUncheckedCreateWithoutBudgetsInput>
  }

  export type FinancialTransactionCreateWithoutBudgetInput = {
    id?: string
    amount: number
    currency?: string
    description: string
    notes?: string | null
    type: $Enums.TransactionType
    category: string
    subcategory?: string | null
    merchant?: string | null
    location?: string | null
    paymentMethod?: string | null
    tags?: FinancialTransactionCreatetagsInput | string[]
    gstAmount?: number | null
    taxCategory?: string | null
    transactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: LifeOSProfileCreateNestedOneWithoutTransactionsInput
  }

  export type FinancialTransactionUncheckedCreateWithoutBudgetInput = {
    id?: string
    profileId: string
    amount: number
    currency?: string
    description: string
    notes?: string | null
    type: $Enums.TransactionType
    category: string
    subcategory?: string | null
    merchant?: string | null
    location?: string | null
    paymentMethod?: string | null
    tags?: FinancialTransactionCreatetagsInput | string[]
    gstAmount?: number | null
    taxCategory?: string | null
    transactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialTransactionCreateOrConnectWithoutBudgetInput = {
    where: FinancialTransactionWhereUniqueInput
    create: XOR<FinancialTransactionCreateWithoutBudgetInput, FinancialTransactionUncheckedCreateWithoutBudgetInput>
  }

  export type FinancialTransactionCreateManyBudgetInputEnvelope = {
    data: FinancialTransactionCreateManyBudgetInput | FinancialTransactionCreateManyBudgetInput[]
    skipDuplicates?: boolean
  }

  export type LifeOSProfileUpsertWithoutBudgetsInput = {
    update: XOR<LifeOSProfileUpdateWithoutBudgetsInput, LifeOSProfileUncheckedUpdateWithoutBudgetsInput>
    create: XOR<LifeOSProfileCreateWithoutBudgetsInput, LifeOSProfileUncheckedCreateWithoutBudgetsInput>
    where?: LifeOSProfileWhereInput
  }

  export type LifeOSProfileUpdateToOneWithWhereWithoutBudgetsInput = {
    where?: LifeOSProfileWhereInput
    data: XOR<LifeOSProfileUpdateWithoutBudgetsInput, LifeOSProfileUncheckedUpdateWithoutBudgetsInput>
  }

  export type LifeOSProfileUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLifeOSProfileNestedInput
    habits?: HabitUpdateManyWithoutProfileNestedInput
    goals?: GoalUpdateManyWithoutProfileNestedInput
    moodEntries?: MoodEntryUpdateManyWithoutProfileNestedInput
    meditations?: MeditationSessionUpdateManyWithoutProfileNestedInput
    journals?: JournalUpdateManyWithoutProfileNestedInput
    transactions?: FinancialTransactionUpdateManyWithoutProfileNestedInput
  }

  export type LifeOSProfileUncheckedUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    themePreference?: StringFieldUpdateOperationsInput | string
    notificationSettings?: JsonNullValueInput | InputJsonValue
    privacySettings?: JsonNullValueInput | InputJsonValue
    extractiveSystemsTargeting?: BoolFieldUpdateOperationsInput | boolean
    communityControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    dataResidencyPreference?: StringFieldUpdateOperationsInput | string
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habits?: HabitUncheckedUpdateManyWithoutProfileNestedInput
    goals?: GoalUncheckedUpdateManyWithoutProfileNestedInput
    moodEntries?: MoodEntryUncheckedUpdateManyWithoutProfileNestedInput
    meditations?: MeditationSessionUncheckedUpdateManyWithoutProfileNestedInput
    journals?: JournalUncheckedUpdateManyWithoutProfileNestedInput
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type FinancialTransactionUpsertWithWhereUniqueWithoutBudgetInput = {
    where: FinancialTransactionWhereUniqueInput
    update: XOR<FinancialTransactionUpdateWithoutBudgetInput, FinancialTransactionUncheckedUpdateWithoutBudgetInput>
    create: XOR<FinancialTransactionCreateWithoutBudgetInput, FinancialTransactionUncheckedCreateWithoutBudgetInput>
  }

  export type FinancialTransactionUpdateWithWhereUniqueWithoutBudgetInput = {
    where: FinancialTransactionWhereUniqueInput
    data: XOR<FinancialTransactionUpdateWithoutBudgetInput, FinancialTransactionUncheckedUpdateWithoutBudgetInput>
  }

  export type FinancialTransactionUpdateManyWithWhereWithoutBudgetInput = {
    where: FinancialTransactionScalarWhereInput
    data: XOR<FinancialTransactionUpdateManyMutationInput, FinancialTransactionUncheckedUpdateManyWithoutBudgetInput>
  }

  export type StoryCreateManyAuthorInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    status?: $Enums.StoryStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: StoryCreatetagsInput | string[]
    coverImage?: string | null
    images?: StoryCreateimagesInput | string[]
    slug: string
    metaTitle?: string | null
    metaDescription?: string | null
    viewCount?: number
    shareCount?: number
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type ProjectMemberCreateManyUserInput = {
    id?: string
    projectId: string
    role?: $Enums.ProjectRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyAuthorInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    storyId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityApplicationCreateManyUserInput = {
    id?: string
    message: string
    resume?: string | null
    portfolio?: string | null
    status?: $Enums.ApplicationStatus
    opportunityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarEventCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    isAllDay?: boolean
    location?: string | null
    url?: string | null
    category?: string | null
    color?: string | null
    isRecurring?: boolean
    recurrenceRule?: string | null
    parentEventId?: string | null
    eventType?: $Enums.EventType
    visibility?: $Enums.Visibility
    projectId?: string | null
    communityEvent?: boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventAttendeeCreateManyUserInput = {
    id?: string
    eventId: string
    status?: $Enums.AttendeeStatus
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: StoryUpdateimagesInput | string[]
    slug?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneWithoutStoriesNestedInput
    comments?: CommentUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: StoryUpdateimagesInput | string[]
    slug?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: StoryUpdateimagesInput | string[]
    slug?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: StoryUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    storyId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    storyId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityApplicationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunity?: OpportunityUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type OpportunityApplicationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    opportunityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityApplicationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    opportunityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    parentEventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    communityEvent?: BoolFieldUpdateOperationsInput | boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutCalendarEventsNestedInput
    attendees?: EventAttendeeUpdateManyWithoutEventNestedInput
  }

  export type CalendarEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    parentEventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    communityEvent?: BoolFieldUpdateOperationsInput | boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendees?: EventAttendeeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type CalendarEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    parentEventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    communityEvent?: BoolFieldUpdateOperationsInput | boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventAttendeeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendeeStatusFieldUpdateOperationsInput | $Enums.AttendeeStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: CalendarEventUpdateOneRequiredWithoutAttendeesNestedInput
  }

  export type EventAttendeeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendeeStatusFieldUpdateOperationsInput | $Enums.AttendeeStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventAttendeeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendeeStatusFieldUpdateOperationsInput | $Enums.AttendeeStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateManyProjectInput = {
    id?: string
    userId: string
    role?: $Enums.ProjectRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryCreateManyProjectInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    status?: $Enums.StoryStatus
    visibility?: $Enums.Visibility
    category?: string | null
    tags?: StoryCreatetagsInput | string[]
    coverImage?: string | null
    images?: StoryCreateimagesInput | string[]
    slug: string
    metaTitle?: string | null
    metaDescription?: string | null
    viewCount?: number
    shareCount?: number
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type OpportunityCreateManyProjectInput = {
    id?: string
    title: string
    description: string
    content?: string | null
    type: $Enums.OpportunityType
    status?: $Enums.OpportunityStatus
    category?: string | null
    tags?: OpportunityCreatetagsInput | string[]
    skills?: OpportunityCreateskillsInput | string[]
    timeCommitment?: string | null
    location?: string | null
    remote?: boolean
    isPaid?: boolean
    compensation?: string | null
    deadline?: Date | string | null
    startDate?: Date | string | null
    duration?: string | null
    coverImage?: string | null
    images?: OpportunityCreateimagesInput | string[]
    contactEmail?: string | null
    contactPhone?: string | null
    applicationUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarEventCreateManyProjectInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime?: Date | string | null
    isAllDay?: boolean
    location?: string | null
    url?: string | null
    category?: string | null
    color?: string | null
    isRecurring?: boolean
    recurrenceRule?: string | null
    parentEventId?: string | null
    eventType?: $Enums.EventType
    visibility?: $Enums.Visibility
    communityEvent?: boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMemberUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: StoryUpdateimagesInput | string[]
    slug?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: UserUpdateOneRequiredWithoutStoriesNestedInput
    comments?: CommentUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: StoryUpdateimagesInput | string[]
    slug?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStoryStatusFieldUpdateOperationsInput | $Enums.StoryStatus
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StoryUpdatetagsInput | string[]
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: StoryUpdateimagesInput | string[]
    slug?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OpportunityUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: OpportunityUpdatetagsInput | string[]
    skills?: OpportunityUpdateskillsInput | string[]
    timeCommitment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    remote?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    compensation?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: OpportunityUpdateimagesInput | string[]
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: OpportunityApplicationUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: OpportunityUpdatetagsInput | string[]
    skills?: OpportunityUpdateskillsInput | string[]
    timeCommitment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    remote?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    compensation?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: OpportunityUpdateimagesInput | string[]
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: OpportunityApplicationUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumOpportunityTypeFieldUpdateOperationsInput | $Enums.OpportunityType
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: OpportunityUpdatetagsInput | string[]
    skills?: OpportunityUpdateskillsInput | string[]
    timeCommitment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    remote?: BoolFieldUpdateOperationsInput | boolean
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    compensation?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: OpportunityUpdateimagesInput | string[]
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    applicationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    parentEventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    communityEvent?: BoolFieldUpdateOperationsInput | boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCalendarEventsNestedInput
    attendees?: EventAttendeeUpdateManyWithoutEventNestedInput
  }

  export type CalendarEventUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    parentEventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    communityEvent?: BoolFieldUpdateOperationsInput | boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendees?: EventAttendeeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type CalendarEventUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrenceRule?: NullableStringFieldUpdateOperationsInput | string | null
    parentEventId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    communityEvent?: BoolFieldUpdateOperationsInput | boolean
    reminders?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyStoryInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    authorId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyParentInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    authorId: string
    storyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    story?: StoryUpdateOneRequiredWithoutCommentsNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    authorId?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    authorId?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityApplicationCreateManyOpportunityInput = {
    id?: string
    message: string
    resume?: string | null
    portfolio?: string | null
    status?: $Enums.ApplicationStatus
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityApplicationUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOpportunitiesNestedInput
  }

  export type OpportunityApplicationUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityApplicationUncheckedUpdateManyWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitCreateManyProfileInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    frequency?: $Enums.HabitFrequency
    targetValue?: number
    unit?: string | null
    color?: string | null
    icon?: string | null
    reminder?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalCreateManyProfileInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    targetValue?: number | null
    currentValue?: number
    unit?: string | null
    startDate?: Date | string
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.GoalStatus
    priority?: $Enums.Priority
    progress?: number
    motivation?: string | null
    visualisation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodEntryCreateManyProfileInput = {
    id?: string
    mood: string
    intensity: number
    emotions?: MoodEntryCreateemotionsInput | string[]
    activities?: MoodEntryCreateactivitiesInput | string[]
    location?: string | null
    weather?: string | null
    notes?: string | null
    triggers?: string | null
    gratitude?: string | null
    recordedAt?: Date | string
    createdAt?: Date | string
  }

  export type MeditationSessionCreateManyProfileInput = {
    id?: string
    duration: number
    technique?: string | null
    guidedSession?: boolean
    guideUrl?: string | null
    rating?: number | null
    notes?: string | null
    mood?: string | null
    location?: string | null
    distractions?: string | null
    createdAt?: Date | string
  }

  export type JournalCreateManyProfileInput = {
    id?: string
    title?: string | null
    content: string
    mood?: string | null
    tags?: JournalCreatetagsInput | string[]
    isPrivate?: boolean
    template?: string | null
    prompts?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialTransactionCreateManyProfileInput = {
    id?: string
    amount: number
    currency?: string
    description: string
    notes?: string | null
    type: $Enums.TransactionType
    category: string
    subcategory?: string | null
    merchant?: string | null
    location?: string | null
    paymentMethod?: string | null
    budgetId?: string | null
    tags?: FinancialTransactionCreatetagsInput | string[]
    gstAmount?: number | null
    taxCategory?: string | null
    transactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCreateManyProfileInput = {
    id?: string
    name: string
    description?: string | null
    totalAmount: number
    spentAmount?: number
    period?: $Enums.BudgetPeriod
    startDate?: Date | string
    endDate?: Date | string | null
    categories?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    alertThreshold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumHabitFrequencyFieldUpdateOperationsInput | $Enums.HabitFrequency
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    reminder?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completions?: HabitCompletionUpdateManyWithoutHabitNestedInput
  }

  export type HabitUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumHabitFrequencyFieldUpdateOperationsInput | $Enums.HabitFrequency
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    reminder?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completions?: HabitCompletionUncheckedUpdateManyWithoutHabitNestedInput
  }

  export type HabitUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumHabitFrequencyFieldUpdateOperationsInput | $Enums.HabitFrequency
    targetValue?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    reminder?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    progress?: FloatFieldUpdateOperationsInput | number
    motivation?: NullableStringFieldUpdateOperationsInput | string | null
    visualisation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: GoalMilestoneUpdateManyWithoutGoalNestedInput
    updates?: GoalUpdateUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    progress?: FloatFieldUpdateOperationsInput | number
    motivation?: NullableStringFieldUpdateOperationsInput | string | null
    visualisation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: GoalMilestoneUncheckedUpdateManyWithoutGoalNestedInput
    updates?: GoalUpdateUncheckedUpdateManyWithoutGoalNestedInput
  }

  export type GoalUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumGoalStatusFieldUpdateOperationsInput | $Enums.GoalStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    progress?: FloatFieldUpdateOperationsInput | number
    motivation?: NullableStringFieldUpdateOperationsInput | string | null
    visualisation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodEntryUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    intensity?: IntFieldUpdateOperationsInput | number
    emotions?: MoodEntryUpdateemotionsInput | string[]
    activities?: MoodEntryUpdateactivitiesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    triggers?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodEntryUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    intensity?: IntFieldUpdateOperationsInput | number
    emotions?: MoodEntryUpdateemotionsInput | string[]
    activities?: MoodEntryUpdateactivitiesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    triggers?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodEntryUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    intensity?: IntFieldUpdateOperationsInput | number
    emotions?: MoodEntryUpdateemotionsInput | string[]
    activities?: MoodEntryUpdateactivitiesInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    weather?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    triggers?: NullableStringFieldUpdateOperationsInput | string | null
    gratitude?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeditationSessionUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    technique?: NullableStringFieldUpdateOperationsInput | string | null
    guidedSession?: BoolFieldUpdateOperationsInput | boolean
    guideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distractions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeditationSessionUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    technique?: NullableStringFieldUpdateOperationsInput | string | null
    guidedSession?: BoolFieldUpdateOperationsInput | boolean
    guideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distractions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeditationSessionUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    technique?: NullableStringFieldUpdateOperationsInput | string | null
    guidedSession?: BoolFieldUpdateOperationsInput | boolean
    guideUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    distractions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JournalUpdatetagsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    template?: NullableStringFieldUpdateOperationsInput | string | null
    prompts?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JournalUpdatetagsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    template?: NullableStringFieldUpdateOperationsInput | string | null
    prompts?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    mood?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JournalUpdatetagsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    template?: NullableStringFieldUpdateOperationsInput | string | null
    prompts?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialTransactionUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: FinancialTransactionUpdatetagsInput | string[]
    gstAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxCategory?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: BudgetUpdateOneWithoutTransactionsNestedInput
  }

  export type FinancialTransactionUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    budgetId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: FinancialTransactionUpdatetagsInput | string[]
    gstAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxCategory?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialTransactionUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    budgetId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: FinancialTransactionUpdatetagsInput | string[]
    gstAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxCategory?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: FinancialTransactionUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: FinancialTransactionUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    spentAmount?: FloatFieldUpdateOperationsInput | number
    period?: EnumBudgetPeriodFieldUpdateOperationsInput | $Enums.BudgetPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitCompletionCreateManyHabitInput = {
    id?: string
    completedAt?: Date | string
    value?: number
    notes?: string | null
    satisfaction?: number | null
    difficulty?: number | null
  }

  export type HabitCompletionUpdateWithoutHabitInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HabitCompletionUncheckedUpdateWithoutHabitInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HabitCompletionUncheckedUpdateManyWithoutHabitInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GoalMilestoneCreateManyGoalInput = {
    id?: string
    title: string
    description?: string | null
    targetDate?: Date | string | null
    completedAt?: Date | string | null
    targetValue?: number | null
    currentValue?: number
    status?: $Enums.MilestoneStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalUpdateCreateManyGoalInput = {
    id?: string
    content: string
    value?: number | null
    createdAt?: Date | string
  }

  export type GoalMilestoneUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalMilestoneUncheckedUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalMilestoneUncheckedUpdateManyWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    currentValue?: FloatFieldUpdateOperationsInput | number
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUpdateUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUpdateUncheckedUpdateWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalUpdateUncheckedUpdateManyWithoutGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventAttendeeCreateManyEventInput = {
    id?: string
    userId: string
    status?: $Enums.AttendeeStatus
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventAttendeeUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendeeStatusFieldUpdateOperationsInput | $Enums.AttendeeStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEventAttendanceNestedInput
  }

  export type EventAttendeeUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendeeStatusFieldUpdateOperationsInput | $Enums.AttendeeStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventAttendeeUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendeeStatusFieldUpdateOperationsInput | $Enums.AttendeeStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialTransactionCreateManyBudgetInput = {
    id?: string
    profileId: string
    amount: number
    currency?: string
    description: string
    notes?: string | null
    type: $Enums.TransactionType
    category: string
    subcategory?: string | null
    merchant?: string | null
    location?: string | null
    paymentMethod?: string | null
    tags?: FinancialTransactionCreatetagsInput | string[]
    gstAmount?: number | null
    taxCategory?: string | null
    transactionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialTransactionUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: FinancialTransactionUpdatetagsInput | string[]
    gstAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxCategory?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: LifeOSProfileUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type FinancialTransactionUncheckedUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: FinancialTransactionUpdatetagsInput | string[]
    gstAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxCategory?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialTransactionUncheckedUpdateManyWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchant?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: FinancialTransactionUpdatetagsInput | string[]
    gstAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    taxCategory?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoryCountOutputTypeDefaultArgs instead
     */
    export type StoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentCountOutputTypeDefaultArgs instead
     */
    export type CommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OpportunityCountOutputTypeDefaultArgs instead
     */
    export type OpportunityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OpportunityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LifeOSProfileCountOutputTypeDefaultArgs instead
     */
    export type LifeOSProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LifeOSProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HabitCountOutputTypeDefaultArgs instead
     */
    export type HabitCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HabitCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GoalCountOutputTypeDefaultArgs instead
     */
    export type GoalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GoalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CalendarEventCountOutputTypeDefaultArgs instead
     */
    export type CalendarEventCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CalendarEventCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudgetCountOutputTypeDefaultArgs instead
     */
    export type BudgetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudgetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectMemberDefaultArgs instead
     */
    export type ProjectMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoryDefaultArgs instead
     */
    export type StoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OpportunityDefaultArgs instead
     */
    export type OpportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OpportunityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OpportunityApplicationDefaultArgs instead
     */
    export type OpportunityApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OpportunityApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PageViewDefaultArgs instead
     */
    export type PageViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PageViewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SearchQueryDefaultArgs instead
     */
    export type SearchQueryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SearchQueryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SettingDefaultArgs instead
     */
    export type SettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaDefaultArgs instead
     */
    export type MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LifeOSProfileDefaultArgs instead
     */
    export type LifeOSProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LifeOSProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HabitDefaultArgs instead
     */
    export type HabitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HabitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HabitCompletionDefaultArgs instead
     */
    export type HabitCompletionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HabitCompletionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GoalDefaultArgs instead
     */
    export type GoalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GoalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GoalMilestoneDefaultArgs instead
     */
    export type GoalMilestoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GoalMilestoneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MeditationSessionDefaultArgs instead
     */
    export type MeditationSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MeditationSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MoodEntryDefaultArgs instead
     */
    export type MoodEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MoodEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JournalDefaultArgs instead
     */
    export type JournalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JournalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CalendarEventDefaultArgs instead
     */
    export type CalendarEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CalendarEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventAttendeeDefaultArgs instead
     */
    export type EventAttendeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventAttendeeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FinancialTransactionDefaultArgs instead
     */
    export type FinancialTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FinancialTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudgetDefaultArgs instead
     */
    export type BudgetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudgetDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}