import { useState, useEffect } from 'react';
import { 
  BellIcon,
  ExclamationTriangleIcon,
  InformationCircleIcon,
  CheckCircleIcon,
  XMarkIcon,
  ClockIcon,
  ArrowPathIcon
} from '@heroicons/react/24/outline';
import { useProjects, useOpportunities, useOrganizations, usePeople } from '../../hooks';

interface DataAlert {
  id: string;
  type: 'urgent' | 'info' | 'success' | 'warning';
  title: string;
  message: string;
  entityType: string;
  entityId: string;
  entityName: string;
  action?: string;
  actionUrl?: string;
  timestamp: Date;
  read: boolean;
  autoGenerated: boolean;
}

interface AlertRule {
  id: string;
  name: string;
  description: string;
  condition: (data: any) => boolean;
  severity: 'urgent' | 'info' | 'success' | 'warning';
  enabled: boolean;
}

/**
 * Data update alert system that monitors changes and notifies users
 * Provides smart alerts for data discrepancies, updates, and maintenance
 */
const DataUpdateAlerts = () => {
  const [alerts, setAlerts] = useState<DataAlert[]>([]);
  const [alertRules, setAlertRules] = useState<AlertRule[]>([]);
  const [isExpanded, setIsExpanded] = useState(false);
  const [showSettings, setShowSettings] = useState(false);

  // Load all data for monitoring
  const { data: projects = [] } = useProjects();
  const { data: opportunities = [] } = useOpportunities();
  const { data: organizations = [] } = useOrganizations();
  const { data: people = [] } = usePeople();

  // Default alert rules
  const defaultRules: AlertRule[] = [
    {
      id: 'milestone-overdue',
      name: 'Overdue Milestones',
      description: 'Alert when project milestones are past due',
      condition: (project) => project.nextMilestone && new Date(project.nextMilestone) < new Date(),
      severity: 'urgent',
      enabled: true
    },
    {
      id: 'opportunity-deadline',
      name: 'Opportunity Deadlines',
      description: 'Alert when opportunity deadlines are approaching (7 days)',
      condition: (opp) => {
        if (!opp.deadline) return false;
        const daysDiff = (new Date(opp.deadline).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24);
        return daysDiff <= 7 && daysDiff >= 0;
      },
      severity: 'warning',
      enabled: true
    },
    {
      id: 'missing-contacts',
      name: 'Organizations Without Contacts',
      description: 'Alert when organizations have no key contacts',
      condition: (org) => org.keyContacts.length === 0,
      severity: 'info',
      enabled: true
    },
    {
      id: 'revenue-mismatch',
      name: 'Revenue vs Opportunity Mismatch',
      description: 'Alert when projects have revenue potential but no opportunities',
      condition: (project) => project.revenuePotential > 0 && project.relatedOpportunities.length === 0,
      severity: 'warning',
      enabled: true
    },
    {
      id: 'contact-follow-up',
      name: 'Contact Follow-up Due',
      description: 'Alert when it\'s time to follow up with contacts',
      condition: (person) => {
        if (!person.nextContactDate) return false;
        return new Date(person.nextContactDate) <= new Date();
      },
      severity: 'info',
      enabled: true
    },
    {
      id: 'project-success',
      name: 'Project Milestones Achieved',
      description: 'Celebrate when projects reach milestones',
      condition: (project) => {
        // Check if milestone was recently achieved (last 7 days)
        if (!project.lastModified) return false;
        const daysSince = (new Date().getTime() - new Date(project.lastModified).getTime()) / (1000 * 60 * 60 * 24);
        return daysSince <= 7 && project.status === 'Active ðŸ”¥';
      },
      severity: 'success',
      enabled: true
    }
  ];

  // Initialize alert rules
  useEffect(() => {
    setAlertRules(defaultRules);
  }, []);

  // Monitor data and generate alerts
  useEffect(() => {
    const newAlerts: DataAlert[] = [];

    // Check projects
    projects.forEach(project => {
      alertRules.filter(rule => rule.enabled).forEach(rule => {
        if (rule.condition(project)) {
          const alertId = `${rule.id}-${project.id}`;
          
          // Don't duplicate existing alerts
          if (!alerts.some(alert => alert.id === alertId)) {
            newAlerts.push({
              id: alertId,
              type: rule.severity,
              title: rule.name,
              message: generateAlertMessage(rule.id, project),
              entityType: 'Project',
              entityId: project.id,
              entityName: project.name,
              action: getAlertAction(rule.id),
              timestamp: new Date(),
              read: false,
              autoGenerated: true
            });
          }
        }
      });
    });

    // Check opportunities
    opportunities.forEach(opp => {
      alertRules.filter(rule => rule.enabled).forEach(rule => {
        if (rule.condition(opp)) {
          const alertId = `${rule.id}-${opp.id}`;
          
          if (!alerts.some(alert => alert.id === alertId)) {
            newAlerts.push({
              id: alertId,
              type: rule.severity,
              title: rule.name,
              message: generateAlertMessage(rule.id, opp),
              entityType: 'Opportunity',
              entityId: opp.id,
              entityName: opp.name,
              action: getAlertAction(rule.id),
              timestamp: new Date(),
              read: false,
              autoGenerated: true
            });
          }
        }
      });
    });

    // Check organizations
    organizations.forEach(org => {
      alertRules.filter(rule => rule.enabled).forEach(rule => {
        if (rule.condition(org)) {
          const alertId = `${rule.id}-${org.id}`;
          
          if (!alerts.some(alert => alert.id === alertId)) {
            newAlerts.push({
              id: alertId,
              type: rule.severity,
              title: rule.name,
              message: generateAlertMessage(rule.id, org),
              entityType: 'Organization',
              entityId: org.id,
              entityName: org.name,
              action: getAlertAction(rule.id),
              timestamp: new Date(),
              read: false,
              autoGenerated: true
            });
          }
        }
      });
    });

    // Check people
    people.forEach(person => {
      alertRules.filter(rule => rule.enabled).forEach(rule => {
        if (rule.condition(person)) {
          const alertId = `${rule.id}-${person.id}`;
          
          if (!alerts.some(alert => alert.id === alertId)) {
            newAlerts.push({
              id: alertId,
              type: rule.severity,
              title: rule.name,
              message: generateAlertMessage(rule.id, person),
              entityType: 'Person',
              entityId: person.id,
              entityName: person.fullName,
              action: getAlertAction(rule.id),
              timestamp: new Date(),
              read: false,
              autoGenerated: true
            });
          }
        }
      });
    });

    if (newAlerts.length > 0) {
      setAlerts(prev => [...newAlerts, ...prev]);
    }
  }, [projects, opportunities, organizations, people, alertRules]);

  // Generate context-specific alert messages
  const generateAlertMessage = (ruleId: string, entity: any): string => {
    switch (ruleId) {
      case 'milestone-overdue':
        const daysOverdue = Math.floor((new Date().getTime() - new Date(entity.nextMilestone).getTime()) / (1000 * 60 * 60 * 24));
        return `Milestone was due ${daysOverdue} day${daysOverdue !== 1 ? 's' : ''} ago`;
      
      case 'opportunity-deadline':
        const daysUntil = Math.ceil((new Date(entity.deadline).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24));
        return `Deadline in ${daysUntil} day${daysUntil !== 1 ? 's' : ''} - ${new Date(entity.deadline).toLocaleDateString()}`;
      
      case 'missing-contacts':
        return `No key contacts listed. Consider adding contact information to maintain relationships.`;
      
      case 'revenue-mismatch':
        return `Has $${(entity.revenuePotential / 1000).toFixed(0)}K revenue potential but no linked opportunities`;
      
      case 'contact-follow-up':
        return `Follow-up scheduled for ${new Date(entity.nextContactDate).toLocaleDateString()}`;
      
      case 'project-success':
        return `Project recently updated and showing progress!`;
      
      default:
        return 'Data update detected';
    }
  };

  // Get suggested action for alert type
  const getAlertAction = (ruleId: string): string => {
    switch (ruleId) {
      case 'milestone-overdue': return 'Update Milestone';
      case 'opportunity-deadline': return 'Review Deadline';
      case 'missing-contacts': return 'Add Contacts';
      case 'revenue-mismatch': return 'Create Opportunity';
      case 'contact-follow-up': return 'Schedule Follow-up';
      case 'project-success': return 'View Project';
      default: return 'Review';
    }
  };

  // Mark alert as read
  const markAsRead = (alertId: string) => {
    setAlerts(prev => 
      prev.map(alert => 
        alert.id === alertId ? { ...alert, read: true } : alert
      )
    );
  };

  // Clear alert
  const clearAlert = (alertId: string) => {
    setAlerts(prev => prev.filter(alert => alert.id !== alertId));
  };

  // Get alert icon and styling
  const getAlertDisplay = (type: string) => {
    switch (type) {
      case 'urgent':
        return { 
          icon: ExclamationTriangleIcon, 
          color: 'text-red-600', 
          bg: 'bg-red-50', 
          border: 'border-red-200' 
        };
      case 'warning':
        return { 
          icon: ClockIcon, 
          color: 'text-amber-600', 
          bg: 'bg-amber-50', 
          border: 'border-amber-200' 
        };
      case 'info':
        return { 
          icon: InformationCircleIcon, 
          color: 'text-blue-600', 
          bg: 'bg-blue-50', 
          border: 'border-blue-200' 
        };
      case 'success':
        return { 
          icon: CheckCircleIcon, 
          color: 'text-green-600', 
          bg: 'bg-green-50', 
          border: 'border-green-200' 
        };
      default:
        return { 
          icon: InformationCircleIcon, 
          color: 'text-gray-600', 
          bg: 'bg-gray-50', 
          border: 'border-gray-200' 
        };
    }
  };

  const unreadCount = alerts.filter(alert => !alert.read).length;

  return (
    <div className="relative">
      {/* Alert Bell */}
      <button
        onClick={() => setIsExpanded(!isExpanded)}
        className={`relative p-2 rounded-lg transition-colors ${
          unreadCount > 0 
            ? 'text-red-600 bg-red-50 hover:bg-red-100' 
            : 'text-gray-600 bg-gray-50 hover:bg-gray-100'
        }`}
      >
        <BellIcon className="h-6 w-6" />
        {unreadCount > 0 && (
          <span className="absolute -top-1 -right-1 h-5 w-5 bg-red-500 text-white text-xs font-bold rounded-full flex items-center justify-center">
            {unreadCount > 9 ? '9+' : unreadCount}
          </span>
        )}
      </button>

      {/* Alert Panel */}
      {isExpanded && (
        <div className="absolute right-0 top-12 w-96 bg-white border border-gray-200 rounded-lg shadow-lg z-50">
          {/* Header */}
          <div className="flex items-center justify-between p-4 border-b border-gray-200">
            <h3 className="font-semibold text-gray-900">
              Alerts ({unreadCount} new)
            </h3>
            <div className="flex items-center gap-2">
              <button
                onClick={() => setShowSettings(!showSettings)}
                className="p-1 text-gray-400 hover:text-gray-600"
              >
                <ArrowPathIcon className="h-4 w-4" />
              </button>
              <button
                onClick={() => setIsExpanded(false)}
                className="p-1 text-gray-400 hover:text-gray-600"
              >
                <XMarkIcon className="h-4 w-4" />
              </button>
            </div>
          </div>

          {/* Alerts List */}
          <div className="max-h-96 overflow-y-auto">
            {alerts.length === 0 ? (
              <div className="p-8 text-center text-gray-500">
                <BellIcon className="h-12 w-12 mx-auto mb-2 text-gray-300" />
                <p>No alerts at this time</p>
                <p className="text-sm">You're all caught up!</p>
              </div>
            ) : (
              <div className="divide-y divide-gray-200">
                {alerts.slice(0, 10).map((alert) => {
                  const display = getAlertDisplay(alert.type);
                  const IconComponent = display.icon;
                  
                  return (
                    <div
                      key={alert.id}
                      className={`p-4 ${!alert.read ? 'bg-blue-50' : ''} hover:bg-gray-50 transition-colors`}
                    >
                      <div className="flex items-start gap-3">
                        <div className={`p-1 rounded ${display.bg} ${display.border} border`}>
                          <IconComponent className={`h-4 w-4 ${display.color}`} />
                        </div>
                        
                        <div className="flex-1 min-w-0">
                          <div className="flex items-center justify-between">
                            <p className={`text-sm font-medium ${alert.read ? 'text-gray-600' : 'text-gray-900'}`}>
                              {alert.title}
                            </p>
                            <button
                              onClick={() => clearAlert(alert.id)}
                              className="text-gray-400 hover:text-gray-600"
                            >
                              <XMarkIcon className="h-4 w-4" />
                            </button>
                          </div>
                          
                          <p className="text-sm text-gray-600 mt-1">
                            <span className="font-medium">{alert.entityName}</span>: {alert.message}
                          </p>
                          
                          <div className="flex items-center justify-between mt-2">
                            <span className="text-xs text-gray-500">
                              {alert.timestamp.toLocaleTimeString()}
                            </span>
                            
                            <div className="flex items-center gap-2">
                              {alert.action && (
                                <button
                                  onClick={() => {
                                    console.log('Action:', alert.action, alert.entityId);
                                    markAsRead(alert.id);
                                  }}
                                  className="text-xs font-medium text-primary-600 hover:text-primary-800"
                                >
                                  {alert.action}
                                </button>
                              )}
                              
                              {!alert.read && (
                                <button
                                  onClick={() => markAsRead(alert.id)}
                                  className="text-xs text-gray-500 hover:text-gray-700"
                                >
                                  Mark read
                                </button>
                              )}
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            )}
          </div>

          {/* Footer */}
          {alerts.length > 10 && (
            <div className="p-3 border-t border-gray-200 text-center">
              <button className="text-sm text-primary-600 hover:text-primary-800 font-medium">
                View all {alerts.length} alerts
              </button>
            </div>
          )}
        </div>
      )}

      {/* Settings Panel */}
      {showSettings && (
        <div className="absolute right-0 top-12 w-80 bg-white border border-gray-200 rounded-lg shadow-lg z-50">
          <div className="p-4 border-b border-gray-200">
            <h3 className="font-semibold text-gray-900">Alert Settings</h3>
          </div>
          
          <div className="p-4 space-y-3">
            {alertRules.map((rule) => (
              <div key={rule.id} className="flex items-center justify-between">
                <div className="flex-1">
                  <p className="text-sm font-medium text-gray-900">{rule.name}</p>
                  <p className="text-xs text-gray-500">{rule.description}</p>
                </div>
                <label className="relative inline-flex items-center cursor-pointer">
                  <input
                    type="checkbox"
                    checked={rule.enabled}
                    onChange={(e) => {
                      setAlertRules(prev => 
                        prev.map(r => 
                          r.id === rule.id ? { ...r, enabled: e.target.checked } : r
                        )
                      );
                    }}
                    className="sr-only peer"
                  />
                  <div className="w-9 h-5 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-primary-600"></div>
                </label>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

export default DataUpdateAlerts;